{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":1},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":1},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":1},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":1},{"_id":"themes/next/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1}],"Cache":[{"_id":"source/404.html","shasum":"75f79c7a9f1072300986dc8b56e6cca36b2b7646","modified":1451905716000},{"_id":"source/_posts/Android图片库-Glide.md","shasum":"c1c26a0916c56fb6ebd5aea04dd30b7fe910aa91","modified":1454293282000},{"_id":"source/_posts/Android注入框架Dagger2学习笔记.md","shasum":"b1cfc192f21ffad1e456c02301d739738fdb7c3b","modified":1457242843000},{"_id":"source/_posts/Google推荐的Android应用框架之demo.md","shasum":"c2c5e5fc0204d2904166e3badf40e86ef5cb5658","modified":1454329187000},{"_id":"source/_posts/始发站，将通往何处.md","shasum":"b5cd80786f1713f3b3296517f67cebe16053b887","modified":1454395744000},{"_id":"source/_posts/抢红包插件分析以及应用.md","shasum":"2c060be2b341b3330864742815a0709ffcca43cb","modified":1453024390000},{"_id":"source/_posts/是时候开始写博客了.md","shasum":"9f22e296976c2ee3cfd63f6205609dd5ecbd3486","modified":1451905716000},{"_id":"source/about/index.md","shasum":"9a5dd3ddba5289a4e4d759d771f2053cc2b2a672","modified":1452400127000},{"_id":"source/categories/index.md","shasum":"bf42a9ac12d34c166f93214af0b26fafc0ebd2a0","modified":1451905716000},{"_id":"source/images/avatar.jpg","shasum":"6cd06578fa0ccaa6fd0c819e30f23b796b083c20","modified":1451905716000},{"_id":"source/read/index.md","shasum":"8d892e35818d348fe94ec1db8d24f7f4fccdfb61","modified":1451908452000},{"_id":"source/tags/index.md","shasum":"a37dfc7257f428ee34d31cb7d43c4568fa5c092c","modified":1451905716000},{"_id":"source/tools/index.md","shasum":"399b77c4ba3310def845421c9a726b185e7e0512","modified":1454394097000},{"_id":"themes/next/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1451905989000},{"_id":"themes/next/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1451905989000},{"_id":"themes/next/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1451905989000},{"_id":"themes/next/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1451905989000},{"_id":"themes/next/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1451905989000},{"_id":"themes/next/_config.yml","shasum":"793426fda9a30a58765604c4c077b266127f4f82","modified":1451907704000},{"_id":"themes/next/languages/de.yml","shasum":"7a8de0e5665c52a1bf168c1e7dd222c8a74fb0ab","modified":1451905989000},{"_id":"themes/next/languages/default.yml","shasum":"f57623e47f533c8d53d859628fa6a368a5298a00","modified":1451905989000},{"_id":"themes/next/languages/en.yml","shasum":"f57623e47f533c8d53d859628fa6a368a5298a00","modified":1451905989000},{"_id":"themes/next/languages/fr-FR.yml","shasum":"2cec663601ac8d178e97aee91d967fa99a95ad4e","modified":1451905989000},{"_id":"themes/next/languages/pt.yml","shasum":"8e38fdf3a5232b428d2e4a641666dbabab87c3d1","modified":1451905989000},{"_id":"themes/next/languages/ru.yml","shasum":"1d1b158f9cff1b38978086043f299b3fc590e007","modified":1451905989000},{"_id":"themes/next/languages/zh-Hans.yml","shasum":"f48a7886c95bffc233d26f4f9614fb0546ba89d6","modified":1451907734000},{"_id":"themes/next/languages/zh-hk.yml","shasum":"248b88c825fde8e35839f3954d38df4e72a0537c","modified":1451905989000},{"_id":"themes/next/languages/zh-tw.yml","shasum":"42ba1d0c6b6026ba1e613ad11efb75432a8132ac","modified":1451905989000},{"_id":"themes/next/layout/_layout.swig","shasum":"4efe52f310b797f4bdedacbd979caf285d2bc731","modified":1451905989000},{"_id":"themes/next/layout/_macro/post-collapse.swig","shasum":"9032ae9056cb19b4c2d069d66ead7abf828f9922","modified":1451905989000},{"_id":"themes/next/layout/_macro/post.swig","shasum":"0674b9bf3103ca32e04f16c7f7a6adad7e32e011","modified":1454295933000},{"_id":"themes/next/layout/_macro/sidebar.swig","shasum":"88e179ff660874135b17d0febc91d04749053a73","modified":1451905989000},{"_id":"themes/next/layout/_partials/comments.swig","shasum":"a612a4eca51ffc87b53a5470b451071a7ad6a031","modified":1451905989000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","shasum":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1451905989000},{"_id":"themes/next/layout/_partials/footer.swig","shasum":"26636bbd41c01946fb21e07f36a8c56c5f8b23b3","modified":1454305159000},{"_id":"themes/next/layout/_partials/head.swig","shasum":"fcef099c268bd4964e65cfe3109e3fe99d0b925c","modified":1451905989000},{"_id":"themes/next/layout/_partials/header.swig","shasum":"476333c49a1e7e0402a68a826f67527ac258969d","modified":1451905989000},{"_id":"themes/next/layout/_partials/old-browsers.swig","shasum":"dbbfea810bf3a2ed9c83b9a6683037175aacfc67","modified":1451905989000},{"_id":"themes/next/layout/_partials/pagination.swig","shasum":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1451905989000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","shasum":"00c2b49f6289198b0b2b4e157e4ee783277f32a7","modified":1451905989000},{"_id":"themes/next/bower.json","shasum":"4a53cab758c7d69be2ce773b2afff7dd962b7cb0","modified":1451905989000},{"_id":"themes/next/README.en.md","shasum":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1451905989000},{"_id":"themes/next/README.md","shasum":"0b709591995001cd860384d6c189e51d91690714","modified":1451905989000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","shasum":"eefe2388ff3d424694045eda21346989b123977c","modified":1451905989000},{"_id":"themes/next/layout/_partials/search.swig","shasum":"64f14da26792a17bc27836c4e9d83190175f36e6","modified":1451905989000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","shasum":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1451905989000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","shasum":"63315fcf210799f894208c9f512737096df84962","modified":1451905989000},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","shasum":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1451905989000},{"_id":"themes/next/layout/_scripts/analytics/facebook-sdk.swig","shasum":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1451905989000},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","shasum":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1451905989000},{"_id":"themes/next/layout/_scripts/analytics.swig","shasum":"33ca06b9bd9a15a19432d5396b85bd319f017319","modified":1451905989000},{"_id":"themes/next/layout/_scripts/baidushare.swig","shasum":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1451905989000},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","shasum":"85295f126836b95f0837d03e58228bb3cf8c4490","modified":1451905989000},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","shasum":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1451905989000},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","shasum":"44e3d567fd49c2a093f4a0a8af9f00542c935a58","modified":1451905989000},{"_id":"themes/next/layout/_scripts/fancy-box.swig","shasum":"41b4ff1446060c88c33bf666a32277dcf12129f0","modified":1451905989000},{"_id":"themes/next/layout/_scripts/helpers.swig","shasum":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1451905989000},{"_id":"themes/next/layout/_scripts/mathjax.swig","shasum":"df03220eb8526e17dc9c9f17780c2d6699367181","modified":1451905989000},{"_id":"themes/next/layout/_scripts/motion.swig","shasum":"0d9761e3b1bb9e666ccc71bad59f035deb5a88c6","modified":1451905989000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","shasum":"7a34b02808f144ee4a11032ae3a149eb634a7e82","modified":1451905989000},{"_id":"themes/next/layout/_scripts/tinysou.swig","shasum":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1451905989000},{"_id":"themes/next/layout/archive.swig","shasum":"0c3ce594759f347ea90a4ce592a7a18e2ae4cc5c","modified":1451905989000},{"_id":"themes/next/layout/category.swig","shasum":"d6b3e1dc5e0b8deade9a084c463126e70188ee9b","modified":1451905989000},{"_id":"themes/next/layout/index.swig","shasum":"38b1ad401b748965369296b86327d23082a1fe93","modified":1451905989000},{"_id":"themes/next/layout/page.swig","shasum":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1451905989000},{"_id":"themes/next/layout/post.swig","shasum":"a84457e8ced46e63bc7a8a9e0541a6ba53122a92","modified":1451905989000},{"_id":"themes/next/layout/tag.swig","shasum":"aab44af54fcbc66fea4ad12b2767ffca3eadd451","modified":1451905989000},{"_id":"themes/next/scripts/filters/sticky.js","shasum":"6b1ea0c09105352813357d0fff4e1d3f4c821fa3","modified":1451905989000},{"_id":"themes/next/scripts/merge-configs.js","shasum":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1451905989000},{"_id":"themes/next/scripts/tags/center-quote.js","shasum":"535fc542781021c4326dec24d8495cbb1387634a","modified":1451905989000},{"_id":"themes/next/scripts/tags/full-image.js","shasum":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1451905989000},{"_id":"themes/next/scripts/tags/group-pictures.js","shasum":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","shasum":"88cd66910260006aa8e9e795df4948d4b67bfa11","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/blockquote-center.styl","shasum":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/buttons.styl","shasum":"81063e0979f04a0f9af37f321d7321dda9abf593","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/comments.styl","shasum":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","shasum":"2d2da815ab0981b219ea1973a4aedede48801411","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/gallery.styl","shasum":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/group-pictures.styl","shasum":"1ee40743000173495728855f734081eb2b6167cc","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","shasum":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/pagination.styl","shasum":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","shasum":"6750b61236eb359028da8f2c4765f7c89b03dc9a","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","shasum":"672d5fa7e5b7642d86a4bda176b501508b54860f","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","shasum":"40b593134bf96d1d6095b3439d47820659d7f10b","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/posts.styl","shasum":"b05ac51dd266d27f12e39e59a94383fe6474b7b3","modified":1451905989000},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","shasum":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1451905989000},{"_id":"themes/next/source/css/_common/_core/base.styl","shasum":"388aa7c69c97728c64941db01e0f29a88837120c","modified":1451905989000},{"_id":"themes/next/source/css/_common/_core/helpers.styl","shasum":"d339d114e52a9abbc797ec236a8a770c29e288a6","modified":1451905989000},{"_id":"themes/next/source/css/_common/_core/normalize.styl","shasum":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1451905989000},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","shasum":"1f8acb3331300eec696a09e7859e11f191e16d7f","modified":1451905989000},{"_id":"themes/next/source/css/_common/_core/tables.styl","shasum":"5f766cf26f966dbf9dcfe681f40ab9032e3e8a08","modified":1451905989000},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","shasum":"8b809aef383bebaeb3f282b47675f3a364ce3569","modified":1451905989000},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","shasum":"80413afacfa656322100ce1900fed1ebcd8f8f44","modified":1451905989000},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","shasum":"ec3f86739bede393cafcd3e31052c01115ae20d6","modified":1451905989000},{"_id":"themes/next/source/css/_common/_page/archive.styl","shasum":"dff879f55ca65fa79c07e9098719e53eeea7ac88","modified":1451905989000},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"249f75bafa26b99d272352c0646e7497ea680b39","modified":1451905989000},{"_id":"themes/next/source/css/_common/_page/categories.styl","shasum":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1451905989000},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","shasum":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1451905989000},{"_id":"themes/next/source/css/_common/_section/body.styl","shasum":"ca1a4766cbe25baac757c6b47a4858d221afdc40","modified":1451905989000},{"_id":"themes/next/source/css/_common/_section/footer.styl","shasum":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1451905989000},{"_id":"themes/next/source/css/_common/_section/header.styl","shasum":"a6aa8a56f9f645ae5a76a1034f79adf73b053aa0","modified":1451905989000},{"_id":"themes/next/source/css/_common/_section/media.styl","shasum":"fa9809d2ecc753cf32f70803c1d0821c405211f4","modified":1451905989000},{"_id":"themes/next/source/css/_common/_section/layout.styl","shasum":"03ae7b808dde9065412968aa69916162e790455d","modified":1451905989000},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","shasum":"6242be4307a3b3dafc14e556f51c8875c41a1ddd","modified":1451905989000},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","shasum":"bc106c3e759cd752c2b4c53ac27bc5ef5e3b18ea","modified":1451905989000},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","shasum":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1451905989000},{"_id":"themes/next/source/css/_custom/custom.styl","shasum":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1451905989000},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","shasum":"9cdbedb3627ac941cfb063b152abe5a75c3c699a","modified":1451905989000},{"_id":"themes/next/source/css/_mixins/base.styl","shasum":"4e49707c99c8bbcfa0a607dfdaff0fbb7dffd2a3","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","shasum":"1631a430655eadb485574d1a9bedd49460988b11","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","shasum":"d50c2a9ae363d26ed2e9bc226a9dc7abeb9ace1b","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","shasum":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","shasum":"5a8036fc61207ca0fe38c9782ed2f686fbf764be","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","shasum":"fc7d96b897290dbd93bc8c515a2058fc4c374ea7","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","shasum":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/default/_logo.styl","shasum":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","shasum":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1451905989000},{"_id":"themes/next/source/css/_variables/Mist.styl","shasum":"9f8791860cc1ca724d2dfe609e8cd6abc44d6926","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/default/_search.styl","shasum":"c524bccdc554349106d1c8be9c3f275d4c0d4281","modified":1451905989000},{"_id":"themes/next/source/css/_variables/base.styl","shasum":"f532d6b0f961a8f3867c06e132233286f110180d","modified":1451905989000},{"_id":"themes/next/source/css/_schemes/default/index.styl","shasum":"159464cb8a7e01e32db9ec70dec391ec70a72f9c","modified":1451905989000},{"_id":"themes/next/source/css/main.styl","shasum":"56dacee56c5eaa4b2676d196452314fb50f758aa","modified":1451905989000},{"_id":"themes/next/source/css/_variables/default.styl","shasum":"8ec3307fe42d738b1bbda4b6419d0995f5560222","modified":1451905989000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1451905989000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1451905989000},{"_id":"themes/next/source/images/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1451905989000},{"_id":"themes/next/source/images/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1451905989000},{"_id":"themes/next/source/images/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1451905989000},{"_id":"themes/next/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1451905989000},{"_id":"themes/next/source/images/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1451905989000},{"_id":"themes/next/source/images/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1451905989000},{"_id":"themes/next/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1451905989000},{"_id":"themes/next/source/images/quote-l.svg","shasum":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1451905989000},{"_id":"themes/next/source/js/bootstrap.js","shasum":"f9b637b6d064f728d7dc2b6b5058a006a4454299","modified":1451905989000},{"_id":"themes/next/source/js/fancy-box.js","shasum":"b5fa638ed371b5f658b0826ec4afee25d9986ef2","modified":1451905989000},{"_id":"themes/next/source/js/helpers.js","shasum":"c15216ef897334362789ba37464298948b2eef95","modified":1451905989000},{"_id":"themes/next/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1451905989000},{"_id":"themes/next/source/js/motion.js","shasum":"b4132517fe499538ad725094593fb7ead8c04bf7","modified":1451905989000},{"_id":"themes/next/source/images/quote-r.svg","shasum":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1451905989000},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1451905989000},{"_id":"themes/next/source/js/hook-duoshuo.js","shasum":"ccb32e0a1acf798337c9697e1aab5484b52f9df4","modified":1451905989000},{"_id":"themes/next/source/js/ua-parser.min.js","shasum":"1148fa2bcb8b2e40c31e5f597bf794a57369a2e6","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"53360764b429c212f424399384417ccc233bb3be","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1451905989000},{"_id":"themes/next/source/vendors/fastclick/README.md","shasum":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1451905989000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","shasum":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1451905989000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1451905989000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","shasum":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1451905989000},{"_id":"themes/next/source/vendors/fastclick/bower.json","shasum":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1451905989000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","shasum":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","shasum":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","shasum":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","shasum":"0189d278706509412bac4745f96c83984e1d59f4","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1451905989000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","shasum":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1451905989000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","shasum":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1451905989000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","shasum":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1451905989000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","shasum":"895d50fa29759af7835256522e9dd7dac597765c","modified":1451905989000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1451905989000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","shasum":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1451905989000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1451905989000},{"_id":"themes/next/source/vendors/velocity/bower.json","shasum":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1451905989000},{"_id":"themes/next/test/intern.js","shasum":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1451905989000},{"_id":"themes/next/test/helpers.js","shasum":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1451905989000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","shasum":"0112e96f327d413938d37c1693806f468ffdbace","modified":1451905989000},{"_id":"themes/next/source/vendors/jquery/index.js","shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1451905989000},{"_id":"themes/next/source/vendors/velocity/velocity.js","shasum":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1451905989000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","shasum":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1451905989000}],"Category":[{"name":"杂谈","_id":"cilg4yv6800070uc9bhips80e"},{"name":"技术","_id":"cilg4yv6e000a0uc96jflhsfh"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","date":"2016-01-04T11:08:36.000Z","updated":"2016-01-04T11:08:36.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cilg4yv4t00000uc9592g85lf"},{"title":"利器","date":"2015-12-11T03:02:26.000Z","type":"tools","_content":"# 工欲善其事，必先利其器\n介绍一些神器\n\n## App\n* 即刻 \n\n\n\n## Mac\n* alfred\n* dash\n* iterm+zsh\n\n## [Alfred插件](https://www.zhihu.com/question/20656680)\n* [workflow list](http://alfredworkflow.com/) - 搜索常用的alfred workflow插件，wf+空格+关键字\n* 有道词典翻译 - yd+空格+关键字 \n* [tinyPNG](http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng) - 选中文件，然后打开alfred，输入tiny,需要先配置。\n* [terminalfinder](http://www.packal.org/workflow/terminalfinder) - 快速终端/iterm，finder切换，注意对应版本。\n* [其他推荐](http://sspai.com/32680)\n\n## 命令行\n* cheat","source":"tools/index.md","raw":"title: 利器\ndate: 2015-12-11 11:02:26\ntype: \"tools\"\n---\n# 工欲善其事，必先利其器\n介绍一些神器\n\n## App\n* 即刻 \n\n\n\n## Mac\n* alfred\n* dash\n* iterm+zsh\n\n## [Alfred插件](https://www.zhihu.com/question/20656680)\n* [workflow list](http://alfredworkflow.com/) - 搜索常用的alfred workflow插件，wf+空格+关键字\n* 有道词典翻译 - yd+空格+关键字 \n* [tinyPNG](http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng) - 选中文件，然后打开alfred，输入tiny,需要先配置。\n* [terminalfinder](http://www.packal.org/workflow/terminalfinder) - 快速终端/iterm，finder切换，注意对应版本。\n* [其他推荐](http://sspai.com/32680)\n\n## 命令行\n* cheat","updated":"2016-02-02T06:21:37.000Z","path":"tools/index.html","comments":1,"layout":"page","_id":"cilg4yv5j00010uc9etnvcayw"},{"title":"tags","date":"2015-12-11T02:59:14.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-12-11 10:59:14\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-01-04T11:08:36.000Z","path":"tags/index.html","layout":"page","_id":"cilg4yv5m00020uc9pldlap3t"},{"title":"阅读","date":"2016-01-04T03:17:02.000Z","_content":"# About Read\n分享一些书籍和阅读资源\n\n\n# 博客\n* [Android开发技术周报](http://www.androidweekly.cn)\n\n# 微信公众号\n* 学习学习再学习\n\n# 网站\n\n* 【】","source":"read/index.md","raw":"title: 阅读\ndate: 2016-01-04 11:17:02\n---\n# About Read\n分享一些书籍和阅读资源\n\n\n# 博客\n* [Android开发技术周报](http://www.androidweekly.cn)\n\n# 微信公众号\n* 学习学习再学习\n\n# 网站\n\n* 【】","updated":"2016-01-04T11:54:12.000Z","path":"read/index.html","comments":1,"layout":"page","_id":"cilg4yv5o00030uc9sxwkuaoo"},{"title":"categories","date":"2015-12-11T03:02:26.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-12-11 11:02:26\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-01-04T11:08:36.000Z","path":"categories/index.html","layout":"page","_id":"cilg4yv5u00040uc9owxve35m"},{"title":"about","date":"2016-01-04T03:17:02.000Z","_content":"# About Me\n\n\n# 感兴趣的技术\n* RxJava：流行的开发框架，适应高性能app的开发趋势\n* ReactNative：一种有前途的app跨平台方案\n* Flux：Fb提出的单向数据流开发思想\n* MVP MVVM：Android开发常用的设计模式","source":"about/index.md","raw":"title: about\ndate: 2016-01-04 11:17:02\n---\n# About Me\n\n\n# 感兴趣的技术\n* RxJava：流行的开发框架，适应高性能app的开发趋势\n* ReactNative：一种有前途的app跨平台方案\n* Flux：Fb提出的单向数据流开发思想\n* MVP MVVM：Android开发常用的设计模式","updated":"2016-01-10T04:28:47.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cilg4yv5x00050uc9jf0wwna3"}],"Post":[{"title":"是时候开始写博客了","date":"2016-01-04T06:03:30.000Z","_content":"## 开写咯\n新的一年又开始啦，和去年一样，每年都要做一件有价值的事情。\n话说写博客真的计划了好久，一直都在计划ing，似乎可以写一个大纪事了。好吧，我承认这是拖延症晚期。\n\n## 大纪事\n\n* 2014-07 刚毕业，计划开始写博客，开通了CSDN，仅仅是开通了。\n* 2015-06 和朋友聊天，决定要写博客，买了域名[limuzhi.com](http://www.limuzhi.com)，折腾了备案那些破事，虚拟机和wordpress，好low，然后就没有然后了。\n* 2015-12 闲逛的时候发现可以用github搭建。一看node.js && hexo && macdown，瞬间高大上，花了半天配置完。\n* 2016-01 正式开始写，目标**至少一周一更**。\n\n## 目标\n\n从大学开始就有做笔记[^1]的习惯 ，可惜发现一些问题，一个是自己看的笔记质量没有保障，本着『大概看懂』就行。其次，很少回去回顾，写了就放那，没有后续收益。希望在线博客这种\"新方式\"能带来一些改变,下面给自己设定一些目标。\n\n* 一周一更，一周一更，一周一更，重要的事情说三遍\n* 干货\n* 信达雅。。。尽力吧\n\n## Enjoy\n\n\n``` java\nSystem.out.println(\"hello world\");\n```\n\n\n\n[^1]: 用wiz笔记，目录+tag的方式，记录的很多且乱，被当成收藏夹用了。","source":"_posts/是时候开始写博客了.md","raw":"title: 是时候开始写博客了\ndate: 2016-01-04 14:03:30\ncategories:\n- 杂谈\ntags:  \n---\n## 开写咯\n新的一年又开始啦，和去年一样，每年都要做一件有价值的事情。\n话说写博客真的计划了好久，一直都在计划ing，似乎可以写一个大纪事了。好吧，我承认这是拖延症晚期。\n\n## 大纪事\n\n* 2014-07 刚毕业，计划开始写博客，开通了CSDN，仅仅是开通了。\n* 2015-06 和朋友聊天，决定要写博客，买了域名[limuzhi.com](http://www.limuzhi.com)，折腾了备案那些破事，虚拟机和wordpress，好low，然后就没有然后了。\n* 2015-12 闲逛的时候发现可以用github搭建。一看node.js && hexo && macdown，瞬间高大上，花了半天配置完。\n* 2016-01 正式开始写，目标**至少一周一更**。\n\n## 目标\n\n从大学开始就有做笔记[^1]的习惯 ，可惜发现一些问题，一个是自己看的笔记质量没有保障，本着『大概看懂』就行。其次，很少回去回顾，写了就放那，没有后续收益。希望在线博客这种\"新方式\"能带来一些改变,下面给自己设定一些目标。\n\n* 一周一更，一周一更，一周一更，重要的事情说三遍\n* 干货\n* 信达雅。。。尽力吧\n\n## Enjoy\n\n\n``` java\nSystem.out.println(\"hello world\");\n```\n\n\n\n[^1]: 用wiz笔记，目录+tag的方式，记录的很多且乱，被当成收藏夹用了。","slug":"是时候开始写博客了","published":1,"updated":"2016-01-04T11:08:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilg4yv6300060uc9kcrde9w6","sticky":0},{"title":"抢红包插件分析以及应用","date":"2016-01-17T08:07:44.000Z","_content":"临近春节，群里的红包又多了（也许仅仅是群多了），由于流行了各种抢红包插件，红包基本是秒没的节奏。在好奇心的驱使下研究了一下抢红包插件的原理，发现既简单又很有意思。还能用来干些其他羞羞的事情😉。。\n\n> 参考Github项目源码  [微信抢红包插件](https://github.com/geeeeeeeeek/WeChatLuckyMoney)\n\n## 基本原理\n\n在没有看Github上的实现的时候，我天真地以为这种插件的原理类似于PC平台上的按键精灵（Android版也有），或者一些测试化工具。这一类软件实现起来应当比较复杂，Too Yang Too Simple。Android已经提供了完备的系统。\n> AccessibilityService 服务（Service），初衷是用于辅助服务，总之它的**功能是根据用户的一些操作给用户相应的提示**，如给残疾人自动读出选择的文字。\n\n我们需要做的是\n1. 继承AccessibilityService，写自定义的辅助服务\n2. 当用户App的界面发送变化时，会触发Service的相关回调，在该回调中可以获取**当前界面中的UI界面元素节点**（不是view本身，是它的一个映射而且可能不是一一映射）。\n3. 根据**关键字/元素id**查找需要的view，处理之,如模拟点击。\n4. done\n\n## 源码分析\n\n### 学习AccessibilityService\n官方文档两篇文章通读之 [Android Train](http://developer.android.com/intl/zh-cn/training/accessibility/service.html) && [Android API指南](http://developer.android.com/intl/zh-cn/guide/topics/ui/accessibility/services.html)\n中文可以学习的文章 [Android中微信抢红包插件原理解析和开发实现](http://blog.csdn.net/jiangwei0910410003/article/details/48895153)\n\n### 关键API\n* Service配置\n\n```xml\n<!--自定义的服务和指定配置文件res/xml/accessible_service_config.xml-->\n<service\n            android:name=\".HongbaoService\"\n            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n            <intent-filter>\n                <action android:name=\"android.accessibilityservice.AccessibilityService\"/>\n            </intent-filter>\n            <meta-data android:name=\"android.accessibilityservice\"\n                       android:resource=\"@xml/accessible_service_config\"/>\n</service>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:description=\"@string/app_name\"\n    android:accessibilityEventTypes=\"typeWindowStateChanged|typeWindowContentChanged\"\n    android:accessibilityFeedbackType=\"feedbackAllMask\"\n    android:packageNames=\"com.tencent.mm\"\n    android:notificationTimeout=\"10\"\n    android:accessibilityFlags=\"\"\n    android:canRetrieveWindowContent=\"true\"/>\n```\n> android:packageNames=\"com.tencent.mm\" 指定要监听的程序的包名\n> android:canRetrieveWindowContent=\"true\" 可以获取具体的内容\n> android:accessibilityEventTypes 监听的事件\n> android:accessibilityFeedbackType=\"feedbackAllMask\" 设置反馈事件（如振动一下提示用户），这里是屏蔽所有反馈。\n\n* Servive回调\n\n```Java\n public void onAccessibilityEvent(AccessibilityEvent event) {\n // 回调\n }\n```\n* 节点查找\n\n```Java \n// 获取所有阶段\nAccessibilityNodeInfo nodeInfo = event.getSource();\n// 查找所有有\"领取红包\"的View\nList<AccessibilityNodeInfo> node1 = nodeInfo.findAccessibilityNodeInfosByText(\"领取红包\");\n// 查找所有id是com.tencent.mm:id/ar6\nList<AccessibilityNodeInfo> node2 = nodeInfo.findAccessibilityNodeInfosByViewId(\"com.tencent.mm:id/ar6\");\n```\n注：可以通过DDMS里的Dump View Hierarchy For UI Automator 分析UI结构来获取id\n\n* 出发操作\n\n```Java\n// 对某个节点操作\ncellNode.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n// 按下手机的后退键\nperformGlobalAction(GLOBAL_ACTION_BACK);\n```\n* 启动Accessibility的系统设置界面，需要用户手动打开服务\n\n```Java\nIntent intent =\n            new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);\nstartActivity(intent);\n```\n\n### 几个注意点\n* AccessibilityService 建议在Android4.0以及以上版本中使用，也有support_v4 向下兼容。\n* Services配置可以通过xml配置，也可以通过代码配置\n* **不同系统的Api可能结果不同**（如API16），如查找不到一些元素\n\n> In Android 4.1 (API Level 16) and higher, the getSource() method, as well as AccessibilityNodeInfo.getChild() and getParent(), return only view objects that are considered important for accessibility (views that draw content or respond to user actions). If your service requires all views, it can request them by setting the flags member of the service's AccessibilityServiceInfo instance to **FLAG_INCLUDE_NOT_IMPORTANT_VIEWS**\n\n* AccessibilityNode可能有一个实例池的设计。获取当前窗体节点树的时候，从一个可重用的实例池中获取一个辅助节点信息 (AccessibilityNodeInfo)实例。在接下来的获取时，仍然从实例池中获取节点实例，这时可能会重用之前的实例。这样的设计是有好处的，可以防止每次返回都创建大量的实例，影响性能。AccessibilityNodeProvider的源码表明了这样的设计。\n\n\n### 抢红包\n\n[微信抢红包插件](https://github.com/geeeeeeeeek/WeChatLuckyMoney)的dev分支的逻辑比较复杂（参考工程的README文件，致力于区分各种状态和不重复抢相同红包），实测不稳定，**stable分支逻辑比较简单也较稳定**。具体代码就不说了。\n\n## Do Something\n抢红包插件网上有很多实现，我所见的都是用AccessibilityService来做的。用这个Service的确可以做一些有趣的事情，打算在后续阶段用这个原理**写一个微信自动聊天程序**，当然是要建立在自己搭建的框架之上的。\n\n","source":"_posts/抢红包插件分析以及应用.md","raw":"title: 抢红包插件分析以及应用\ndate: 2016-01-17 16:07:44\ncategories:\n- 技术\ntags:\n- Android\n- 其他\n---\n临近春节，群里的红包又多了（也许仅仅是群多了），由于流行了各种抢红包插件，红包基本是秒没的节奏。在好奇心的驱使下研究了一下抢红包插件的原理，发现既简单又很有意思。还能用来干些其他羞羞的事情😉。。\n\n> 参考Github项目源码  [微信抢红包插件](https://github.com/geeeeeeeeek/WeChatLuckyMoney)\n\n## 基本原理\n\n在没有看Github上的实现的时候，我天真地以为这种插件的原理类似于PC平台上的按键精灵（Android版也有），或者一些测试化工具。这一类软件实现起来应当比较复杂，Too Yang Too Simple。Android已经提供了完备的系统。\n> AccessibilityService 服务（Service），初衷是用于辅助服务，总之它的**功能是根据用户的一些操作给用户相应的提示**，如给残疾人自动读出选择的文字。\n\n我们需要做的是\n1. 继承AccessibilityService，写自定义的辅助服务\n2. 当用户App的界面发送变化时，会触发Service的相关回调，在该回调中可以获取**当前界面中的UI界面元素节点**（不是view本身，是它的一个映射而且可能不是一一映射）。\n3. 根据**关键字/元素id**查找需要的view，处理之,如模拟点击。\n4. done\n\n## 源码分析\n\n### 学习AccessibilityService\n官方文档两篇文章通读之 [Android Train](http://developer.android.com/intl/zh-cn/training/accessibility/service.html) && [Android API指南](http://developer.android.com/intl/zh-cn/guide/topics/ui/accessibility/services.html)\n中文可以学习的文章 [Android中微信抢红包插件原理解析和开发实现](http://blog.csdn.net/jiangwei0910410003/article/details/48895153)\n\n### 关键API\n* Service配置\n\n```xml\n<!--自定义的服务和指定配置文件res/xml/accessible_service_config.xml-->\n<service\n            android:name=\".HongbaoService\"\n            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n            <intent-filter>\n                <action android:name=\"android.accessibilityservice.AccessibilityService\"/>\n            </intent-filter>\n            <meta-data android:name=\"android.accessibilityservice\"\n                       android:resource=\"@xml/accessible_service_config\"/>\n</service>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:description=\"@string/app_name\"\n    android:accessibilityEventTypes=\"typeWindowStateChanged|typeWindowContentChanged\"\n    android:accessibilityFeedbackType=\"feedbackAllMask\"\n    android:packageNames=\"com.tencent.mm\"\n    android:notificationTimeout=\"10\"\n    android:accessibilityFlags=\"\"\n    android:canRetrieveWindowContent=\"true\"/>\n```\n> android:packageNames=\"com.tencent.mm\" 指定要监听的程序的包名\n> android:canRetrieveWindowContent=\"true\" 可以获取具体的内容\n> android:accessibilityEventTypes 监听的事件\n> android:accessibilityFeedbackType=\"feedbackAllMask\" 设置反馈事件（如振动一下提示用户），这里是屏蔽所有反馈。\n\n* Servive回调\n\n```Java\n public void onAccessibilityEvent(AccessibilityEvent event) {\n // 回调\n }\n```\n* 节点查找\n\n```Java \n// 获取所有阶段\nAccessibilityNodeInfo nodeInfo = event.getSource();\n// 查找所有有\"领取红包\"的View\nList<AccessibilityNodeInfo> node1 = nodeInfo.findAccessibilityNodeInfosByText(\"领取红包\");\n// 查找所有id是com.tencent.mm:id/ar6\nList<AccessibilityNodeInfo> node2 = nodeInfo.findAccessibilityNodeInfosByViewId(\"com.tencent.mm:id/ar6\");\n```\n注：可以通过DDMS里的Dump View Hierarchy For UI Automator 分析UI结构来获取id\n\n* 出发操作\n\n```Java\n// 对某个节点操作\ncellNode.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n// 按下手机的后退键\nperformGlobalAction(GLOBAL_ACTION_BACK);\n```\n* 启动Accessibility的系统设置界面，需要用户手动打开服务\n\n```Java\nIntent intent =\n            new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);\nstartActivity(intent);\n```\n\n### 几个注意点\n* AccessibilityService 建议在Android4.0以及以上版本中使用，也有support_v4 向下兼容。\n* Services配置可以通过xml配置，也可以通过代码配置\n* **不同系统的Api可能结果不同**（如API16），如查找不到一些元素\n\n> In Android 4.1 (API Level 16) and higher, the getSource() method, as well as AccessibilityNodeInfo.getChild() and getParent(), return only view objects that are considered important for accessibility (views that draw content or respond to user actions). If your service requires all views, it can request them by setting the flags member of the service's AccessibilityServiceInfo instance to **FLAG_INCLUDE_NOT_IMPORTANT_VIEWS**\n\n* AccessibilityNode可能有一个实例池的设计。获取当前窗体节点树的时候，从一个可重用的实例池中获取一个辅助节点信息 (AccessibilityNodeInfo)实例。在接下来的获取时，仍然从实例池中获取节点实例，这时可能会重用之前的实例。这样的设计是有好处的，可以防止每次返回都创建大量的实例，影响性能。AccessibilityNodeProvider的源码表明了这样的设计。\n\n\n### 抢红包\n\n[微信抢红包插件](https://github.com/geeeeeeeeek/WeChatLuckyMoney)的dev分支的逻辑比较复杂（参考工程的README文件，致力于区分各种状态和不重复抢相同红包），实测不稳定，**stable分支逻辑比较简单也较稳定**。具体代码就不说了。\n\n## Do Something\n抢红包插件网上有很多实现，我所见的都是用AccessibilityService来做的。用这个Service的确可以做一些有趣的事情，打算在后续阶段用这个原理**写一个微信自动聊天程序**，当然是要建立在自己搭建的框架之上的。\n\n","slug":"抢红包插件分析以及应用","published":1,"updated":"2016-01-17T09:53:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilg4yv6d00090uc98nobv7vb","sticky":0},{"title":"始发站，将通往何处","date":"2016-01-10T04:36:26.000Z","sticky":10,"description":"从零开始构建一个用于生产环境的Android App，要走这些路。这篇文章是博客的总目录，会持续更新。同时也是我的一个起点，一些思考。优先写一些感兴趣的技术点，最后形成一个体系，完成构建一个可持续改进的用于生产环境的App的目标。当然也可能扩展到Server和IOS的其他方面。","_content":"\n起床，吃饭，就到了晌午。\n这周的任务还没有完成，在家里总是慵懒的状态，转念来到楼下的咖啡馆--HappyTree，躺在沙发上思考这个奇怪的问题。不想写鸡汤或者感悟，但是这文风不对啊！\n这是一篇Guide，罗列**一些技术的兴奋点**（G点？）。虽然我属于杂牌军系列，什么都想搞一些，可是现在还是专注于Android方向。\n\n## 切入点\n不管在哪工作，一直都在思考或者观察这两个问题\n\n* **如何搭建一个高效的开发框架**\n* 如何组建一个有战斗力的团队\n\n本文主要从第一点思考问题，一个合格的框架是怎样组成的？谈谈我经历的两个团队（有机会写文章细谈），第一团队，简单规范的开发框架，入门程序员也可以完成开发，第二个团队，项目太久，框架太多导致没有框架，自由发挥。理所当然地认为前者niubility，后者太low。但是在第一个团队有一种错觉，技术就是这些东西，没有什么可以说的了。直到现在，**当自己思考如何构建一个框架的时候，发现世界如此精彩。**\n用时刻准备创业的心态去思考工作。所以，现在我在始发站，总有一天会启程。最近有一篇很不错的微信团队的文章[《创业码农的一些建议》](https://simpleton.gitbooks.io/sim-tech-note/content/Android/AndroidStartupTutorial.html)，核心思想:**\"不要重复发明轮子\"，当然这不意味着不需要知道怎么制造轮子。**那么，看看如何用这些轮子来造车。\n\n\n## 构建一个App\n一个完备的app应当具有这些基础能力\n\n* 网络能力（https、下载、升级等）\n* 图片库\n* 开发框架（模式）\n* 公共库/控件库/工具库\n* apk打包与瘦身\n* bug跟踪机制/质量保证\n* 用户分析系统\n* 推送机制/长连接方案\n* 对内规范（工程结构、代码style等）\n* 对外规范（接口规范、沟通规范）\n\n\n一个优秀的app应当具有这些技术能力\n\n* 灰度发布能力\n* 插件化技术\n* 热修复技术\n* Android测试技术\n* mock系统\n* 性能优化（内存，启动时间等）\n* apk安全问题\n\n团队协作的基础设施\n\n* 版本管理工具\n* Code Review工具\n* 持续集成\n\n### 网络能力\n[okhttp](https://github.com/square/okhttp) 现在使用中，http基础库，良好的同步/异步接口\n\n[android-async-http](https://github.com/loopj/android-async-http) 之前使用，比较老，功能也比较完备\n\n> okhttp\\android-async-http\\volley\\retrofit 比较\n> okhttp 和 async http是一个基础的通信库，都很强大，但需要自己封装使用才更方便。另外okhttp已经被谷歌官方用在android源码中了。 retrofit和 volley是属于比较高级点的封装库了。其中 retrofit是默认使用okhttp，volley也支持okhttp作为其底层通信的部件。retrofit的特点是使用清晰简单的接口，非常方便，而 volley在使用的时候也还简单，不过要使用高级一点的功能需要自己自定义很多东西，个人常用 **retrofit+okhttp**\n链接：https://www.zhihu.com/question/35189851/answer/62857319\n来源：知乎\n\n[Gson](https://github.com/google/gson) json解析，一直使用这个库\n\n[jackson]() 没有使用过，有空研究一下\n\n> jackson gson fastjson\n> jackson 似乎有优势，尤其是大文件多并发的情况下\n\n\n### 图片库\n[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader) 使用过且阅读过源码，比较简单，功能较弱，无法很好应当OOM\n\n[Glide]() 目前使用的的库，在非专业图片应用中强烈推荐，综合各种数据最优秀的Lib，同时也是Google推荐的。支持gif（webp动图不支持？video支持？）源码中大量的接口的设计，十分值得学习。大小500kb以内。\n\n[fresco](https://github.com/facebook/fresco) 最优秀的内存管理和最强大的功能，支持WebP动图。FB出品，一些黑科技，代码复杂，压缩后通用安装包代码1M（包含两个平台的so）。\n\n> Fresco vs UIL vs Glide vs Piasso\n> UIL 比较老，功能比较弱（不支持Gif WebP）,\n> Fresco最为强大，问题是对外接口不友好（需要替换ImageView），在使用过程遇到问题很难修改源码解决问题，比较复杂，建议不是图片特别重的App不要使用。\n> Piasso 都没有使用过，对外接口简单。据说：『Glide的性能更好一些，并且支持更多格式的图片』，以后有时间调研一下Glide。\n\n### 公共库/控件库/工具库\n待补充，主要是一些通用的公共组件和工具类，可能包含BaseActivity\\BaseFragment,xxxUtils。一些动画库nineOld\n\n### 开发框架\n这里包括且不限于：一些设计模式（MVC等），一些多线程工具库（代替AsyncTask，如Bolts等）\n\n[Bolts-Android](https://github.com/BoltsFramework/Bolts-Android) android多线程，取代AsyncTask作为统一的线程池。具有链式调用的结构，可指定运行的不通线程。FB出品，现在在使用中，入门简单，使用代价很小。\n\n[MVP && MVVM](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)    MVP是在开发中常用的设计模式，当前使用中。\n\n[Flow 思想](http://zhuanlan.zhihu.com/FrontendMagazine/19900243) 一种单向数据流的思想，在React框架中使用，可以在移动开发中使用。FB出名，学习ing，没有实践过。\n> Flow VS MVP ?\n\n[RxJava RxAndroid](https://github.com/ReactiveX/RxAndroid) ReactiveX的Java版本和Android扩展，强大！链式调用，可以代替Bolts的所有功能（也可以封装后代替EventBus），一种完备的开发框架（思想）。微软出品，学习中，入门较难，对团队要求很高，可以极大简化代码。\n\n[EventBus](https://github.com/greenrobot/EventBus) 一种总线机制，使用发布-订阅的方式解耦模块，没有使用过。类似的还有[Otto](https://github.com/square/otto)\n\n> 关于一些团队内部使用的框架：大致思想类似于bolts这一类框架再封装一下网络框架。方便开发者快速发起Rest请求并且在合适的线程处理数据和UI。\n> \n> 其他：\n> [EventBus VS RxJava ](https://www.zhihu.com/question/32179258)\n> \n> 待补充：一些其他的注入框架，和如何联合使用这些框架。\n\n### bug跟踪机制/质量保证\n发现问题的能力是App的一种重要的能力，类似百度使用的Crab平台跟踪用户崩溃和bug率是重要的。\n\n[bug跟踪系统](https://get.fabric.io/?locale=zh-cn) 上报用户崩溃数据，部分用户分析工具具备此功能（如GA），但是建议加入专门的bug上报工具，类似百，功能强大。\n\n[用户反馈的设计]() 一般app都需要反馈模块供用户主动反应问题。\n\n[性能、内存监控]() 主要是开发阶段使用，暴露问题。例如LeakCanary、BlockCanary\n\n### 用户分析系统\n跟踪用户行为，收集数据是持续优化的基础，也是产品重要能力。基本的埋点机制或者类似于Google Analyse的分析系统\n\n[App埋点设计与数据上报]()\n\n[接入第三方分析系统]() 获取用户行为数据，形成画像是这些系统的重要功能。\n\n### 推送机制/长连接方案\n推送的第三方方案，信鸽、other？\n部分应用可能需要长连接，MQTT\n\n### 对内规范\n[构建工程结构]() 如何构建合理的工程结构，依据业务？功能？，如何方便扩展功能，发布不通版本？\n\n[代码Style](https://github.com/square/java-code-styles) Square的java-code-styles,也可以自己fork做相应的修改\n\n[资源Style]() Android特有的问题，dimens,styles,strings中按照UI需求设计一些基本的公共值（业务无关？）。否则会导致不可控。\n\n[代码检测]() 代码静态检测，动态检测，提前发现潜在问题，提高代码质量。\n\n[CodeReview]() 代码提交commit前的审核流程\n\n### 对外规范\n[网络请求]() http or https，get or post ,是否使用私有证书？\n\n[json格式规范]() 使用标准的json格式，定义合理的返回结构和状态码（错误码建议不要使用http head中的代码，部分广告工具/防火墙拦截，而是定义在json中）。\n\n[加密方式服规范]() 定义不同信息的安全等级以及对应加密算法--DES or RSA or MD5校验\n\n[迭代流程与发版规范]() 敏捷流程，灰度/发版标准（bug率？）\n\n[问题解决流程]() 次奥，这些问题太多了\n\n### 灰度发布\n待研究，GooglePlay具有此功能，也可以自行开发，对于用户量较多的App此功能具有重要意义，防止新版本问题影响到全部用户和验证功能效果都有作用。\n\n### 插件化技术\n[简单可靠的插件化技术](https://github.com/wequick/Small) 插件化是大型产品的框架需求，尤其是平台化产品或者对App安装包大小有严格限制的应用。同时也是对65535限制的技术解决方案。\n\n### 热修复技术\n[热修复技术研究](http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/) 热修复技术是产品上线后紧急修复的需要，是对灰度发布补充。\n\n### mock系统\nclient团队内部开发使用，可以部分解决server与client开发不协调的问题，尤其是server进度慢于client的情况，也可以用于client程序员自己调试程序。\n\n### 性能优化\nApp迭代到一定阶段，自然而然地会进入这么一个阶段。一个好的框架可能会暂时隐藏这些问题。但是对系统的持续监控（性能分析报告）是必不可少，及早发现问题与定位，寻求时间优化问题十分重要。\n\n### 版本管理工具\n[git](http://www.bootcss.com/p/git-guide/) 使用较多的版本管理工具，代替svn等传统工具\n[git flow](http://nvie.com/posts/a-successful-git-branching-model/)  git版本管理的工作流的最佳实践。满足正式开发、新特性预研、灰度、Release等版本的发布需求。\n[git服务器搭建]()\n[gitlab](https://about.gitlab.com/gitlab-com/) 开源的本地管理系统，类似github的功能\n\n### Code Review工具\n[Gerrit]() 适用于团队内部开发代码提交审核的工具。以及该工具与IDE、Git的集成。\n\n### 持续集成\n[jenkins+git+gerrit方案]() 将Android的Gradle build 持续集成\n\n> 是否考虑第三方服务？\n\n\n## 趋势\n作为一个程序员，能感受到Android开发技术发展迅速，新技术目不暇接。**分享一些信息获取[渠道](http://www.limuzhi.com/read/)**。对于趋势，类比于其他技术是种不错的思路，[《从中间件的历史来看移动App开发的未来》](http://blog.jobbole.com/91662/)给我一些启发。\n\n[React](http://www.ruanyifeng.com/blog/2015/03/react.html) FB提出的一种Js的mvc开发框架，虚拟dom具有高效的特点，并且可以扩展到App中。JavaScript有望占领前后端(Node.js)和各个平台。\n\n[React Native](http://www.androidweekly.cn/android-dev-special-weekly-react-native/) React的android版本，有望取代其他的hybrid开发框架。\n\n\n## 最后一些话\n至此，基本总结了App开发的技术点，留了很多坑等着以后慢慢填，每一点展开都能写很多。后续会不断更新这些文章到自己的博文，也可能增删一些内容。从哪里开始写还没有想好，期间会插入一些小项目。打算在春节前写一个抢红包的系列文章，主要分析一些抢红包插件的源码。\n\n本人一年多的工作经验，大部分的内容也在探索中或者只有一些概念，任何问题欢迎提出。","source":"_posts/始发站，将通往何处.md","raw":"title: 始发站，将通往何处\ndate: 2016-01-10 12:36:26\nsticky: 10\ndescription: 从零开始构建一个用于生产环境的Android App，要走这些路。这篇文章是博客的总目录，会持续更新。同时也是我的一个起点，一些思考。优先写一些感兴趣的技术点，最后形成一个体系，完成构建一个可持续改进的用于生产环境的App的目标。当然也可能扩展到Server和IOS的其他方面。\ncategories:\n- 技术\ntags:\n- Android\n- Guide\n- 最佳实践 \n---\n\n起床，吃饭，就到了晌午。\n这周的任务还没有完成，在家里总是慵懒的状态，转念来到楼下的咖啡馆--HappyTree，躺在沙发上思考这个奇怪的问题。不想写鸡汤或者感悟，但是这文风不对啊！\n这是一篇Guide，罗列**一些技术的兴奋点**（G点？）。虽然我属于杂牌军系列，什么都想搞一些，可是现在还是专注于Android方向。\n\n## 切入点\n不管在哪工作，一直都在思考或者观察这两个问题\n\n* **如何搭建一个高效的开发框架**\n* 如何组建一个有战斗力的团队\n\n本文主要从第一点思考问题，一个合格的框架是怎样组成的？谈谈我经历的两个团队（有机会写文章细谈），第一团队，简单规范的开发框架，入门程序员也可以完成开发，第二个团队，项目太久，框架太多导致没有框架，自由发挥。理所当然地认为前者niubility，后者太low。但是在第一个团队有一种错觉，技术就是这些东西，没有什么可以说的了。直到现在，**当自己思考如何构建一个框架的时候，发现世界如此精彩。**\n用时刻准备创业的心态去思考工作。所以，现在我在始发站，总有一天会启程。最近有一篇很不错的微信团队的文章[《创业码农的一些建议》](https://simpleton.gitbooks.io/sim-tech-note/content/Android/AndroidStartupTutorial.html)，核心思想:**\"不要重复发明轮子\"，当然这不意味着不需要知道怎么制造轮子。**那么，看看如何用这些轮子来造车。\n\n\n## 构建一个App\n一个完备的app应当具有这些基础能力\n\n* 网络能力（https、下载、升级等）\n* 图片库\n* 开发框架（模式）\n* 公共库/控件库/工具库\n* apk打包与瘦身\n* bug跟踪机制/质量保证\n* 用户分析系统\n* 推送机制/长连接方案\n* 对内规范（工程结构、代码style等）\n* 对外规范（接口规范、沟通规范）\n\n\n一个优秀的app应当具有这些技术能力\n\n* 灰度发布能力\n* 插件化技术\n* 热修复技术\n* Android测试技术\n* mock系统\n* 性能优化（内存，启动时间等）\n* apk安全问题\n\n团队协作的基础设施\n\n* 版本管理工具\n* Code Review工具\n* 持续集成\n\n### 网络能力\n[okhttp](https://github.com/square/okhttp) 现在使用中，http基础库，良好的同步/异步接口\n\n[android-async-http](https://github.com/loopj/android-async-http) 之前使用，比较老，功能也比较完备\n\n> okhttp\\android-async-http\\volley\\retrofit 比较\n> okhttp 和 async http是一个基础的通信库，都很强大，但需要自己封装使用才更方便。另外okhttp已经被谷歌官方用在android源码中了。 retrofit和 volley是属于比较高级点的封装库了。其中 retrofit是默认使用okhttp，volley也支持okhttp作为其底层通信的部件。retrofit的特点是使用清晰简单的接口，非常方便，而 volley在使用的时候也还简单，不过要使用高级一点的功能需要自己自定义很多东西，个人常用 **retrofit+okhttp**\n链接：https://www.zhihu.com/question/35189851/answer/62857319\n来源：知乎\n\n[Gson](https://github.com/google/gson) json解析，一直使用这个库\n\n[jackson]() 没有使用过，有空研究一下\n\n> jackson gson fastjson\n> jackson 似乎有优势，尤其是大文件多并发的情况下\n\n\n### 图片库\n[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader) 使用过且阅读过源码，比较简单，功能较弱，无法很好应当OOM\n\n[Glide]() 目前使用的的库，在非专业图片应用中强烈推荐，综合各种数据最优秀的Lib，同时也是Google推荐的。支持gif（webp动图不支持？video支持？）源码中大量的接口的设计，十分值得学习。大小500kb以内。\n\n[fresco](https://github.com/facebook/fresco) 最优秀的内存管理和最强大的功能，支持WebP动图。FB出品，一些黑科技，代码复杂，压缩后通用安装包代码1M（包含两个平台的so）。\n\n> Fresco vs UIL vs Glide vs Piasso\n> UIL 比较老，功能比较弱（不支持Gif WebP）,\n> Fresco最为强大，问题是对外接口不友好（需要替换ImageView），在使用过程遇到问题很难修改源码解决问题，比较复杂，建议不是图片特别重的App不要使用。\n> Piasso 都没有使用过，对外接口简单。据说：『Glide的性能更好一些，并且支持更多格式的图片』，以后有时间调研一下Glide。\n\n### 公共库/控件库/工具库\n待补充，主要是一些通用的公共组件和工具类，可能包含BaseActivity\\BaseFragment,xxxUtils。一些动画库nineOld\n\n### 开发框架\n这里包括且不限于：一些设计模式（MVC等），一些多线程工具库（代替AsyncTask，如Bolts等）\n\n[Bolts-Android](https://github.com/BoltsFramework/Bolts-Android) android多线程，取代AsyncTask作为统一的线程池。具有链式调用的结构，可指定运行的不通线程。FB出品，现在在使用中，入门简单，使用代价很小。\n\n[MVP && MVVM](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)    MVP是在开发中常用的设计模式，当前使用中。\n\n[Flow 思想](http://zhuanlan.zhihu.com/FrontendMagazine/19900243) 一种单向数据流的思想，在React框架中使用，可以在移动开发中使用。FB出名，学习ing，没有实践过。\n> Flow VS MVP ?\n\n[RxJava RxAndroid](https://github.com/ReactiveX/RxAndroid) ReactiveX的Java版本和Android扩展，强大！链式调用，可以代替Bolts的所有功能（也可以封装后代替EventBus），一种完备的开发框架（思想）。微软出品，学习中，入门较难，对团队要求很高，可以极大简化代码。\n\n[EventBus](https://github.com/greenrobot/EventBus) 一种总线机制，使用发布-订阅的方式解耦模块，没有使用过。类似的还有[Otto](https://github.com/square/otto)\n\n> 关于一些团队内部使用的框架：大致思想类似于bolts这一类框架再封装一下网络框架。方便开发者快速发起Rest请求并且在合适的线程处理数据和UI。\n> \n> 其他：\n> [EventBus VS RxJava ](https://www.zhihu.com/question/32179258)\n> \n> 待补充：一些其他的注入框架，和如何联合使用这些框架。\n\n### bug跟踪机制/质量保证\n发现问题的能力是App的一种重要的能力，类似百度使用的Crab平台跟踪用户崩溃和bug率是重要的。\n\n[bug跟踪系统](https://get.fabric.io/?locale=zh-cn) 上报用户崩溃数据，部分用户分析工具具备此功能（如GA），但是建议加入专门的bug上报工具，类似百，功能强大。\n\n[用户反馈的设计]() 一般app都需要反馈模块供用户主动反应问题。\n\n[性能、内存监控]() 主要是开发阶段使用，暴露问题。例如LeakCanary、BlockCanary\n\n### 用户分析系统\n跟踪用户行为，收集数据是持续优化的基础，也是产品重要能力。基本的埋点机制或者类似于Google Analyse的分析系统\n\n[App埋点设计与数据上报]()\n\n[接入第三方分析系统]() 获取用户行为数据，形成画像是这些系统的重要功能。\n\n### 推送机制/长连接方案\n推送的第三方方案，信鸽、other？\n部分应用可能需要长连接，MQTT\n\n### 对内规范\n[构建工程结构]() 如何构建合理的工程结构，依据业务？功能？，如何方便扩展功能，发布不通版本？\n\n[代码Style](https://github.com/square/java-code-styles) Square的java-code-styles,也可以自己fork做相应的修改\n\n[资源Style]() Android特有的问题，dimens,styles,strings中按照UI需求设计一些基本的公共值（业务无关？）。否则会导致不可控。\n\n[代码检测]() 代码静态检测，动态检测，提前发现潜在问题，提高代码质量。\n\n[CodeReview]() 代码提交commit前的审核流程\n\n### 对外规范\n[网络请求]() http or https，get or post ,是否使用私有证书？\n\n[json格式规范]() 使用标准的json格式，定义合理的返回结构和状态码（错误码建议不要使用http head中的代码，部分广告工具/防火墙拦截，而是定义在json中）。\n\n[加密方式服规范]() 定义不同信息的安全等级以及对应加密算法--DES or RSA or MD5校验\n\n[迭代流程与发版规范]() 敏捷流程，灰度/发版标准（bug率？）\n\n[问题解决流程]() 次奥，这些问题太多了\n\n### 灰度发布\n待研究，GooglePlay具有此功能，也可以自行开发，对于用户量较多的App此功能具有重要意义，防止新版本问题影响到全部用户和验证功能效果都有作用。\n\n### 插件化技术\n[简单可靠的插件化技术](https://github.com/wequick/Small) 插件化是大型产品的框架需求，尤其是平台化产品或者对App安装包大小有严格限制的应用。同时也是对65535限制的技术解决方案。\n\n### 热修复技术\n[热修复技术研究](http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/) 热修复技术是产品上线后紧急修复的需要，是对灰度发布补充。\n\n### mock系统\nclient团队内部开发使用，可以部分解决server与client开发不协调的问题，尤其是server进度慢于client的情况，也可以用于client程序员自己调试程序。\n\n### 性能优化\nApp迭代到一定阶段，自然而然地会进入这么一个阶段。一个好的框架可能会暂时隐藏这些问题。但是对系统的持续监控（性能分析报告）是必不可少，及早发现问题与定位，寻求时间优化问题十分重要。\n\n### 版本管理工具\n[git](http://www.bootcss.com/p/git-guide/) 使用较多的版本管理工具，代替svn等传统工具\n[git flow](http://nvie.com/posts/a-successful-git-branching-model/)  git版本管理的工作流的最佳实践。满足正式开发、新特性预研、灰度、Release等版本的发布需求。\n[git服务器搭建]()\n[gitlab](https://about.gitlab.com/gitlab-com/) 开源的本地管理系统，类似github的功能\n\n### Code Review工具\n[Gerrit]() 适用于团队内部开发代码提交审核的工具。以及该工具与IDE、Git的集成。\n\n### 持续集成\n[jenkins+git+gerrit方案]() 将Android的Gradle build 持续集成\n\n> 是否考虑第三方服务？\n\n\n## 趋势\n作为一个程序员，能感受到Android开发技术发展迅速，新技术目不暇接。**分享一些信息获取[渠道](http://www.limuzhi.com/read/)**。对于趋势，类比于其他技术是种不错的思路，[《从中间件的历史来看移动App开发的未来》](http://blog.jobbole.com/91662/)给我一些启发。\n\n[React](http://www.ruanyifeng.com/blog/2015/03/react.html) FB提出的一种Js的mvc开发框架，虚拟dom具有高效的特点，并且可以扩展到App中。JavaScript有望占领前后端(Node.js)和各个平台。\n\n[React Native](http://www.androidweekly.cn/android-dev-special-weekly-react-native/) React的android版本，有望取代其他的hybrid开发框架。\n\n\n## 最后一些话\n至此，基本总结了App开发的技术点，留了很多坑等着以后慢慢填，每一点展开都能写很多。后续会不断更新这些文章到自己的博文，也可能增删一些内容。从哪里开始写还没有想好，期间会插入一些小项目。打算在春节前写一个抢红包的系列文章，主要分析一些抢红包插件的源码。\n\n本人一年多的工作经验，大部分的内容也在探索中或者只有一些概念，任何问题欢迎提出。","slug":"始发站，将通往何处","published":1,"updated":"2016-02-02T06:49:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilg4yv6j000g0uc9dmwulntc"},{"title":"Google推荐的Android应用框架之demo","date":"2016-01-31T08:04:50.000Z","_content":"近日，在Google开发者的微博上推荐了一个视频，是2015年开发者峰会上两位Google的Coder的演讲，关于Android应用框架，中文相关介绍文章[看这里](http://blog.zhaiyifan.cn/2016/01/29/android-app-architecture-2015/)。\n演讲中有个demo，类似于一个QQ的聊天界面的程序，用这个例子讲解了如何优雅地处理在各种网络异常的情况下的UI界面，既如何设计一个offline的应用。\n网络请求与本地缓存相结合以获取最好的用户体验应当是几乎所有Android应用的基本需求。从我的开发经验看，我们往往会忽略之一点。大部分情况下，都是直接从网络拿回数据显示在界面上，如果网络不好，就不断loading。。。在无网情况下，app是不可用的。\n\n* 拉逻辑--获取列表，此过程是我们最常用，我们大部分是获取数据然后展示给用户，仅仅需要本地有一份数据以备在无网时使用。这个逻辑在应用中基本是通用的。\n* 推逻辑--提交post，demo中对某些请求进行排队，在后台不断重试，这种逻辑对于某些应用应该是不适用的，毕竟大部分应用是不需要这种『强同步』的（既server与local完全一致，如聊天list或记账，微信发朋友圈）。在一般应用中以下两种情况更加常见：\n\n\t* 结果失败与否并不重要。如点赞这些功能，当然也可以这么干。\n\t* 操作是一些重要的不可重复操作，必须锁死屏幕。如提交订单，付款等。\n\n选择哪一种交互是设计阶段必须考虑的，这直接决定了编码方式。当然，一个设计良好的框架必须要提供这些能力:\n\n* 封装网络请求与本地数据支持拉逻辑的操作，开发者可以选择是否先使用本地数据再等待网络更新。还是只使用网络数据。\n* 支持简单请求，锁死等待，还是异步的。\n* 支持后台可重复发送的请求--强同步--既Act locally, Sync globally。\n\n扯远了，需要一篇文章写一些app中可能用到各种交互与请求逻辑。\n\n下面翻译下Google这个demo的README文件。了解一下设计思想。\n\n## 简介\n这是个简单的社交软件，列表可以展示其他人的消息（我们叫他feed流），用户还可以发送文本信息。\n\n本文的目的是讲述如何设计一个应用，可以离线使用，并在网络可用时同步信息到服务器，尽量不影响用户。\n\n* 如何工作\n* 组件\n* 数据流\n\t* 发送信息\n\t* 同步feed流\n\t* 保持UI更新\n* 安装&运行&测试\n\t* 安装\n\t* 运行\n\t* 测试\n* 其他\n\t* 避免重复发送信息 \n* 版权许可\n\n## 如何工作\n关于『离线设计』这个主题，许多解决方案都是依赖于特定的需求，如果想要运用到其他场景，需要一些修改。因此，这个demo的同步逻辑可能并不适合你的需求。你应当把它当做一个例子学习，然后找出适合你的应用的解决方案。不幸的是，没有设计离线应用的万金油。\n这里，我们会解释用户的交互流是如何工作的，会给你的应用提供一些不错的想法。\n这个例子没有严格依照任何的构架模式，它使用混合方法满足自己的需求。我们假设这个应用会不断成长为一个大的app（因此下面比较复杂）。尽管增加了复杂度，但是我没尽量是这个demo更加真实有用。\n\n## 组件\n* Value Objects:\n\t* 这些对象通常保持着数据库中存储的数据，这些对象也知道如何校验这些数据的合法性。如果Server发送了一下无效数据（比如，API改变了），我们可以在它们影响Model之前就忽略它们。\n* Models:\n\t* 扶着数据持久化，保持到本地，并提供方法获取数据。\n* Controllers:\n\t* 保存着应用程序主要逻辑，它决定如何做某事（如发送消息），处理gcm消息等。\n* Activities:\n\t* 控制用户界面，他们知道哪里需要加载数据，什么时候需要刷新自己。\n* Events:\n\t* 本demo使用一个全局的EventBus，它唯一的作用是通知UI更新。\n\t* 当UI需要从应用逻辑那里获取数据，直接调用相关方法就可以。这种设计符合Android这个UI生命周期短的设计。这种数据流也避免了UI和后台线程的循环引用。\n* Jobs:\n\t* 他们可能是定义良好的网络操作（这比较典型，但未必）， 可以把你的应用逻辑拆分成多个job，这更方便测试和扩展。例如发送用户的文本消息到服务器就是一个job，同步用户的feed流到服务器也是个job。\n\n## 数据流\n\n### 发送消息\n当用户点击按钮，首先会发生这么4步：1.验证消息合法性。2.保持消息到本地磁盘存储（这个例子中这是一个job）。3.更新PostModel添加新的信息。4.发送event通知有消息更新。\n（可选的）4.a.如果UI可见，在收到event后更新内容。\n注意：上面这些步骤没有涉及网络，但是我已经更新了用户界面&&保持必要的数据到磁盘。最后，我们需要与Server同步。\n\n同步的步骤如下\n![Sync To Server](https://camo.githubusercontent.com/590b0315c04a7e5c0b429fbd521f99062aacde1d/68747470733a2f2f7777772e657665726e6f74652e636f6d2f73686172642f7331392f73682f31313036313730662d346637332d343531392d616537642d3466346166313364343138322f366562656436376534613734613461342f7265732f62656166626235362d633564632d346563622d393934662d3330653036616232313961342f736b697463682e706e67)\n\n* 优先级作业队列，负责处理持久化job，失败时的回退操作等，所以图中没有这些细节。\n* 一个真实环境的app应该与JobScheduler结合，确保消息在应用关闭后也可以发送。\n* 当job失败时，你最好保持一些信息到磁盘，那样下次用户打开app时，你可以通知他们发生了什么。这个demo中，当FeedActivity不可见时会显示系统通知。\n\n### 同步Feed流\n同步操作有下面三个组件负责：\n\n* FeedModel：\n\t* 为每个feed流保存最后一条FeedItem（既发送的消息）的时间戳。这个时间戳有两个作用\n\t\t* 当我们刷新feed流时，只接收最新的item。\n\t\t* 创建保存在本地的消息。本地创建的消息会显示在feed查询中是很重要的。 客户端的时间戳可能与server不同，只有当消息与Server同步时，我们分配feed最新的时间戳给这个新的消息。？？？\n\t* 给UI层提供从数据库获取feed流的方法。\n* FeedController：\n\t* 负责创建`FetchFeedJob`\n\t* 监听消息更新失败，使用系统的通知栏通知用户。除非其他的UI组件（如FeedActivity）已经处理了错误。\n\t* 这个示例的app很基础，在真实环境中，它可能还要负责当有GCM推送到达时刷新feed流。以及包括一些防止用户频繁刷新的逻辑。\n* FetFeedJob：\n\t* 发出API调用，获取某个feed流的最新消息列表。还负责更新model和发出event。\n\n### 保持UI更新\n后台与UI的交互需要良好的定义。\n\n* 等界面需要做某件事情时，UI直接调用某个方法（如发送消息）。\n* 后台任务结束时发出event通知UI更新（如更新失败）。\n\nUI组件根据自身的生命周期负责注册/反注册EventBus，因为后台永远不会持有UI的引用，我们不想有内存泄漏的风险。\n\n* EventBus的使用可能引起一些特殊的情况：由于UI错过了一些event时，导致不同步。本Demo使用下面的规则避免这种清空。\n\t* 当组件的生命周期开始时，先注册event，然后在再从model加载数据。\n\t* 当正在加载数据时，如果有event到来，会在数据加载完成后再次触发一次同步。\n\t* 所有的event都含有一个时间戳，它表示与该event相关的最老的item的时间。当UI访问model层时会使用这个时间戳，那么，如果item插入数据库时顺序不同，我们依然可以获取到这些item，因为我们使用了最老的时间戳。？？？\n\t* 当组件的生命周期结束时（例如`Activity#onStop`）,停止监听event。如果，我们再返回应用，他会做一个完整的同步，确保不会丢失在这期间发生的event。\n\n**这不是唯一的办法**：示例中使用的是一个全局的EventBus，你也可以用Rx实现相似的功能，或者手动设置listener，以及其他相似的技术。总之，你需要根据自己的应用来评估。\n\n## 安装&&运行&&测试\n### 安装\ndemo包含一个简单的server，你需要安装Ruby On Rails来运行它。建议你通过[Ruby Version Manager](https://rvm.io/)来安装。安装完之后，使用下面命令启动server：\n\n```xml\n> cd server;\n> bundle install;\n> rake db:migrate RAILS_ENV=development;\n```\n这会安装依赖，创建数据库。\n\n### 运行\n#### 服务器\n\n```xml\n> cd server;\n> rails s\n```\n\n#### 客户端\ndemo中app使用模拟器环境默认的host地址。（`http://10.0.2.2:3000`）。如果你在模拟器里运行，已经可以正常工作。你可以在设置菜单中修改，或者在`DemoConfig`类中直接修改。\n\n### 测试\n\n* 服务器：服务端没有。。我又不关心。\n* 客户端：你可以这样运行测试 `> cd client; > ./gradlew clean app:connectedCheck app:test`\n\n## 其他\n### 避免重复发送消息\n编写移动应用意味着你要处理不可靠的网络。通过使用持久化的job（存储在本地），在网络可用时，app工作了很不错，可是并不完美。在不可靠的网络条件下，我们的应用可能出现这种情况：服务端那数据已经更新存储了，但是客户端没有收到成功的返回。那么客户端依然认为消息没有上传，会不断重试。如果server的返回有问题，这就会变得更糟糕。\n通常情况下，重试就以为这重复上传消息。有很多策略可以解决这个问题。demo中我们使用一个唯一的二维元组`(userId, clientId)`来避免重复，它的原理如下：\n\n* 客户端创建消息时，生成一个唯一的`clientId`（`UUID.randomUUID().toString()`,注：随着时间会变化）。这个UUID和用户ID的组合在客户端和服务端都是唯一的。\n* 当服务端收到消息时，检查这个元组是否存在，如果以及存在，不会新增一条存储记录，而是仅仅返回这个条目已经存在。\n* 当客户端获取feed时，如果发现一个消息的` (userId, client Id)`与某个存在的消息相同，会覆盖这存在的消息。这可能发生在这种情况下发生：客户端没有收到服务端的返回，只是本地保存了这个消息，，但是这个消息出现在其他某个请求的返回里面。？？需要这样吗\n\n你可以在`server/app/controllers/posts_controller.rb`中使用`error_before_saving_post`和`error_after_saving_post`来触发这种特殊的情况。\n\n## 版权许可\n>Copyright (C) 2015 The Android Open Source Project\n\n>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\n\n>You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n\n>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n>See the License for the specific language governing permissions and limitations under the License.","source":"_posts/Google推荐的Android应用框架之demo.md","raw":"title: Google推荐的Android应用框架之demo\ndate: 2016-01-31 16:04:50\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n近日，在Google开发者的微博上推荐了一个视频，是2015年开发者峰会上两位Google的Coder的演讲，关于Android应用框架，中文相关介绍文章[看这里](http://blog.zhaiyifan.cn/2016/01/29/android-app-architecture-2015/)。\n演讲中有个demo，类似于一个QQ的聊天界面的程序，用这个例子讲解了如何优雅地处理在各种网络异常的情况下的UI界面，既如何设计一个offline的应用。\n网络请求与本地缓存相结合以获取最好的用户体验应当是几乎所有Android应用的基本需求。从我的开发经验看，我们往往会忽略之一点。大部分情况下，都是直接从网络拿回数据显示在界面上，如果网络不好，就不断loading。。。在无网情况下，app是不可用的。\n\n* 拉逻辑--获取列表，此过程是我们最常用，我们大部分是获取数据然后展示给用户，仅仅需要本地有一份数据以备在无网时使用。这个逻辑在应用中基本是通用的。\n* 推逻辑--提交post，demo中对某些请求进行排队，在后台不断重试，这种逻辑对于某些应用应该是不适用的，毕竟大部分应用是不需要这种『强同步』的（既server与local完全一致，如聊天list或记账，微信发朋友圈）。在一般应用中以下两种情况更加常见：\n\n\t* 结果失败与否并不重要。如点赞这些功能，当然也可以这么干。\n\t* 操作是一些重要的不可重复操作，必须锁死屏幕。如提交订单，付款等。\n\n选择哪一种交互是设计阶段必须考虑的，这直接决定了编码方式。当然，一个设计良好的框架必须要提供这些能力:\n\n* 封装网络请求与本地数据支持拉逻辑的操作，开发者可以选择是否先使用本地数据再等待网络更新。还是只使用网络数据。\n* 支持简单请求，锁死等待，还是异步的。\n* 支持后台可重复发送的请求--强同步--既Act locally, Sync globally。\n\n扯远了，需要一篇文章写一些app中可能用到各种交互与请求逻辑。\n\n下面翻译下Google这个demo的README文件。了解一下设计思想。\n\n## 简介\n这是个简单的社交软件，列表可以展示其他人的消息（我们叫他feed流），用户还可以发送文本信息。\n\n本文的目的是讲述如何设计一个应用，可以离线使用，并在网络可用时同步信息到服务器，尽量不影响用户。\n\n* 如何工作\n* 组件\n* 数据流\n\t* 发送信息\n\t* 同步feed流\n\t* 保持UI更新\n* 安装&运行&测试\n\t* 安装\n\t* 运行\n\t* 测试\n* 其他\n\t* 避免重复发送信息 \n* 版权许可\n\n## 如何工作\n关于『离线设计』这个主题，许多解决方案都是依赖于特定的需求，如果想要运用到其他场景，需要一些修改。因此，这个demo的同步逻辑可能并不适合你的需求。你应当把它当做一个例子学习，然后找出适合你的应用的解决方案。不幸的是，没有设计离线应用的万金油。\n这里，我们会解释用户的交互流是如何工作的，会给你的应用提供一些不错的想法。\n这个例子没有严格依照任何的构架模式，它使用混合方法满足自己的需求。我们假设这个应用会不断成长为一个大的app（因此下面比较复杂）。尽管增加了复杂度，但是我没尽量是这个demo更加真实有用。\n\n## 组件\n* Value Objects:\n\t* 这些对象通常保持着数据库中存储的数据，这些对象也知道如何校验这些数据的合法性。如果Server发送了一下无效数据（比如，API改变了），我们可以在它们影响Model之前就忽略它们。\n* Models:\n\t* 扶着数据持久化，保持到本地，并提供方法获取数据。\n* Controllers:\n\t* 保存着应用程序主要逻辑，它决定如何做某事（如发送消息），处理gcm消息等。\n* Activities:\n\t* 控制用户界面，他们知道哪里需要加载数据，什么时候需要刷新自己。\n* Events:\n\t* 本demo使用一个全局的EventBus，它唯一的作用是通知UI更新。\n\t* 当UI需要从应用逻辑那里获取数据，直接调用相关方法就可以。这种设计符合Android这个UI生命周期短的设计。这种数据流也避免了UI和后台线程的循环引用。\n* Jobs:\n\t* 他们可能是定义良好的网络操作（这比较典型，但未必）， 可以把你的应用逻辑拆分成多个job，这更方便测试和扩展。例如发送用户的文本消息到服务器就是一个job，同步用户的feed流到服务器也是个job。\n\n## 数据流\n\n### 发送消息\n当用户点击按钮，首先会发生这么4步：1.验证消息合法性。2.保持消息到本地磁盘存储（这个例子中这是一个job）。3.更新PostModel添加新的信息。4.发送event通知有消息更新。\n（可选的）4.a.如果UI可见，在收到event后更新内容。\n注意：上面这些步骤没有涉及网络，但是我已经更新了用户界面&&保持必要的数据到磁盘。最后，我们需要与Server同步。\n\n同步的步骤如下\n![Sync To Server](https://camo.githubusercontent.com/590b0315c04a7e5c0b429fbd521f99062aacde1d/68747470733a2f2f7777772e657665726e6f74652e636f6d2f73686172642f7331392f73682f31313036313730662d346637332d343531392d616537642d3466346166313364343138322f366562656436376534613734613461342f7265732f62656166626235362d633564632d346563622d393934662d3330653036616232313961342f736b697463682e706e67)\n\n* 优先级作业队列，负责处理持久化job，失败时的回退操作等，所以图中没有这些细节。\n* 一个真实环境的app应该与JobScheduler结合，确保消息在应用关闭后也可以发送。\n* 当job失败时，你最好保持一些信息到磁盘，那样下次用户打开app时，你可以通知他们发生了什么。这个demo中，当FeedActivity不可见时会显示系统通知。\n\n### 同步Feed流\n同步操作有下面三个组件负责：\n\n* FeedModel：\n\t* 为每个feed流保存最后一条FeedItem（既发送的消息）的时间戳。这个时间戳有两个作用\n\t\t* 当我们刷新feed流时，只接收最新的item。\n\t\t* 创建保存在本地的消息。本地创建的消息会显示在feed查询中是很重要的。 客户端的时间戳可能与server不同，只有当消息与Server同步时，我们分配feed最新的时间戳给这个新的消息。？？？\n\t* 给UI层提供从数据库获取feed流的方法。\n* FeedController：\n\t* 负责创建`FetchFeedJob`\n\t* 监听消息更新失败，使用系统的通知栏通知用户。除非其他的UI组件（如FeedActivity）已经处理了错误。\n\t* 这个示例的app很基础，在真实环境中，它可能还要负责当有GCM推送到达时刷新feed流。以及包括一些防止用户频繁刷新的逻辑。\n* FetFeedJob：\n\t* 发出API调用，获取某个feed流的最新消息列表。还负责更新model和发出event。\n\n### 保持UI更新\n后台与UI的交互需要良好的定义。\n\n* 等界面需要做某件事情时，UI直接调用某个方法（如发送消息）。\n* 后台任务结束时发出event通知UI更新（如更新失败）。\n\nUI组件根据自身的生命周期负责注册/反注册EventBus，因为后台永远不会持有UI的引用，我们不想有内存泄漏的风险。\n\n* EventBus的使用可能引起一些特殊的情况：由于UI错过了一些event时，导致不同步。本Demo使用下面的规则避免这种清空。\n\t* 当组件的生命周期开始时，先注册event，然后在再从model加载数据。\n\t* 当正在加载数据时，如果有event到来，会在数据加载完成后再次触发一次同步。\n\t* 所有的event都含有一个时间戳，它表示与该event相关的最老的item的时间。当UI访问model层时会使用这个时间戳，那么，如果item插入数据库时顺序不同，我们依然可以获取到这些item，因为我们使用了最老的时间戳。？？？\n\t* 当组件的生命周期结束时（例如`Activity#onStop`）,停止监听event。如果，我们再返回应用，他会做一个完整的同步，确保不会丢失在这期间发生的event。\n\n**这不是唯一的办法**：示例中使用的是一个全局的EventBus，你也可以用Rx实现相似的功能，或者手动设置listener，以及其他相似的技术。总之，你需要根据自己的应用来评估。\n\n## 安装&&运行&&测试\n### 安装\ndemo包含一个简单的server，你需要安装Ruby On Rails来运行它。建议你通过[Ruby Version Manager](https://rvm.io/)来安装。安装完之后，使用下面命令启动server：\n\n```xml\n> cd server;\n> bundle install;\n> rake db:migrate RAILS_ENV=development;\n```\n这会安装依赖，创建数据库。\n\n### 运行\n#### 服务器\n\n```xml\n> cd server;\n> rails s\n```\n\n#### 客户端\ndemo中app使用模拟器环境默认的host地址。（`http://10.0.2.2:3000`）。如果你在模拟器里运行，已经可以正常工作。你可以在设置菜单中修改，或者在`DemoConfig`类中直接修改。\n\n### 测试\n\n* 服务器：服务端没有。。我又不关心。\n* 客户端：你可以这样运行测试 `> cd client; > ./gradlew clean app:connectedCheck app:test`\n\n## 其他\n### 避免重复发送消息\n编写移动应用意味着你要处理不可靠的网络。通过使用持久化的job（存储在本地），在网络可用时，app工作了很不错，可是并不完美。在不可靠的网络条件下，我们的应用可能出现这种情况：服务端那数据已经更新存储了，但是客户端没有收到成功的返回。那么客户端依然认为消息没有上传，会不断重试。如果server的返回有问题，这就会变得更糟糕。\n通常情况下，重试就以为这重复上传消息。有很多策略可以解决这个问题。demo中我们使用一个唯一的二维元组`(userId, clientId)`来避免重复，它的原理如下：\n\n* 客户端创建消息时，生成一个唯一的`clientId`（`UUID.randomUUID().toString()`,注：随着时间会变化）。这个UUID和用户ID的组合在客户端和服务端都是唯一的。\n* 当服务端收到消息时，检查这个元组是否存在，如果以及存在，不会新增一条存储记录，而是仅仅返回这个条目已经存在。\n* 当客户端获取feed时，如果发现一个消息的` (userId, client Id)`与某个存在的消息相同，会覆盖这存在的消息。这可能发生在这种情况下发生：客户端没有收到服务端的返回，只是本地保存了这个消息，，但是这个消息出现在其他某个请求的返回里面。？？需要这样吗\n\n你可以在`server/app/controllers/posts_controller.rb`中使用`error_before_saving_post`和`error_after_saving_post`来触发这种特殊的情况。\n\n## 版权许可\n>Copyright (C) 2015 The Android Open Source Project\n\n>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\n\n>You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n\n>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n>See the License for the specific language governing permissions and limitations under the License.","slug":"Google推荐的Android应用框架之demo","published":1,"updated":"2016-02-01T12:19:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilg4yv6n000n0uc9ljtc70xb","sticky":0},{"title":"Android注入框架Dagger2学习笔记","date":"2016-03-06T04:47:07.000Z","_content":"\n## 简介\nDagger2是一个Google推荐的注入框架，关于什么是注入，为什么需要注入，可以参考下面的疑问以及解答文章。如果你在项目中使用MVP架构开发，强烈建议配合dagger2一起使用。\nDagger2大量使用注解，使开发者可以优雅的构造对象，同时，这些注解仅在编译期间生成代码，没有用到运行时的反射，对性能的影响可以忽略。使用者可以查看编译期间生成的代码，方便debug。\n本文是学习Dagger2的笔记，需要先学习下面的文章，了解Dagger2，然后在学习过程中有一些疑问，形成一些思考与测试，形成此文。但是我还没有机会在项目中实际使用，若以后有实践经验会不断补充。\n\n主要学习的文章：\n\n*  [Android常用开源工具（1）-Dagger2入门](http://blog.csdn.net/duo2005duo/article/details/50618171)：dagger2的基本用法，很好的文章。\n*  [Android常用开源工具（2）-Dagger2进阶](http://blog.csdn.net/duo2005duo/article/details/50696166)：dagger2的一些高级用法，如限定符。\n*   [详解Dagger2](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html)：这篇文章翻译的不好，参考英文原文。\n\n### 疑问以及解答\n* [什么是依赖注入](<http://www.codekk.com/open-source-project-analysis/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>)\n\n* [Dagger 源码解析](http://www.codekk.com/blogs/detail/54cfab086c4761e5001b2537)：dagger第一代的讲解，参考了解两者的差异。\n\n* [Android中是否有必要使用依赖注入的争议](<http://dk-exp.com/2015/01/28/use-ioc-in-android/>)\n\n## 一个非常容易的错误\ninject的参数。。。不能是父类，必须是你注入的那个内\n\n## 一个重要的概念：向子图暴露\n即在component中写如下方法向把它依赖的component来暴露构造方法，且只能暴露一层。\n\n```java\n//定义ComponentB,modules可以不写，也可以与其他Component依赖的modules相同\n@Component(modules={××××××××})\ninterface ComponentB{\n    // 必须暴露出来，给A注入的对象用\n    Apple apple()\n}\n//定义ComponentA，dependencies是A依赖的，区分 extend ComponentB\n@Component(dependencies={ComponentB.class},modules={××××××××})//使用dependencies\ninterface ComponentA{\n    // 注意注入的必须是具体的子类MyApp/XXActivity，不能是父类，如Application/Activity\n    void inject(MyApp app)\n}\n```\n\n## 错误汇总\n1. 错误: com.android.example.devsummit.archdemo.di.module.Apple is bound multiple times:\n\n\t原因：一个类定义了多个provider：\n\t* component关联的（n个或者1个）module中有重复的provider\n\t* component A有dependencies的component B，A关联的Module A中有provider，component B关联的Module B中也有provider，**且在component B中暴露出来了**（不暴露不影响）\n\n\t下面的情况**没有**影响：\n\t\n\t* component 关联的module有provider，且类自己的构造函数有Inject标志，不影响，且provider优先。\n\t* component A有dependencies的component B， A关联的Module A中有provider，component B关联的Module B中也有provider，但是component B中没有暴露，不影响\n \n\n2. 错误: Types may only contain one @Inject constructor.\n\n\t原因：一个类的构造函数只能有一个有@inject\n\n3. 错误: com.android.example.devsummit.archdemo.di.module.Apple cannot be provided without an @Inject constructor or from an @Provides-annotated method.\n\n\t原因：\n\t* 没有provider或者inject\n\t* 如果component含有dependencies，可能没有向外面暴露\n\n##区分易混淆的概念\n\n1. component与module\n2. component的dependencies与component接口的继承（extend）\n\n## 关于Scope的粗浅理解\n### 概念\nscope是范围，标志一个注入器/对象的使用范围，那么可以理解：\n\n* 父类（dependencies）有范围，子类必须有，且要小于它\n* 父类子类范围不能一样？\n* component中某一个对象构造有范围（Module中的一个方法有范围），那么该component就有范围。\n\n### 作用\n作用是允许对象被记录在正确的组件（component）。即module的构造方法用在正确的注入器（component）中，防止用错地方。**因为一个component关联的module中如果有其他的scope的provider会报错，因为component没有这个scope。**\n\n### 自定义scope\n```java\n@Scope\n@Documented\n@Retention(RUNTIME)\npublic @interface Singleton{}\n```\n\n### 使用scope时规则\n结合scope的概念理解\n\n* component关联的Model中的**任何一个被构造的对象**有scope，则该整个component要加上这个scope。在暴露或者注入时（不暴露且不注入时，既不使用它构造对象时，不报错），会有如下错误\n > Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) may not reference scoped bindings:\n@Provides @com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.vo.User com.android.example.devsummit.archdemo.di.module.TestModule.user()\n\n* component的dependencies与component自身的scope不能相同，即组件之间的scope不同\n* Singleton的组件不能依赖其他scope的组件，只能其他scope的组件依赖Singleton的组件。\n* 没有scope的不能依赖有scope的组件，理解一下。。。\n\n  > Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) cannot depend on scoped components:\n@com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.di.component.MyTestComponentX\n* 一个component不能同时有多个scope(Subcomponent除外)\n\n\t> Error:Execution failed for task ':app:compileDebugJavaWithJavac'.\n\t> java.lang.IllegalArgumentException: com.android.example.devsummit.archdemo.di.component.MyTestComponent was annotated with more than one @Scope annotation\n\n## 其他概念\n### @Subcomponent\nSubcomponent与dependencies区别：\ndependencies不会继承范围，Subcomponent会。子component同时具备两种不同生命周期的scope。\n\n## 实践\n### Module\ndagger使用的目的在于更多的使用面向接口的编程。在Module中构造的对象返回的应当尽量是：**构造具体的类的实现，但是返回接口**，如②中所示，参考[文章](http://www.jianshu.com/p/c2feb21064bb)，常用写法如下：\n\n```java\n@Module\npublic class AppModule {\n    private final MyApplication application;\n\n    public AppModule(MyApplication application) {\n        this.application = application;\n    }\n\n\t// ①这种情况是返回module内部保持的变量\n    @Provides\n    @Singleton\n    Context provideApplicationContext() { \n       return application;\n    }\n\n\t// ②这种含有参数的写法会自动构造参数，前提是provideThreadExecutor，有provider或者@inject，ThreadExecutor是接口，JobExecutor是具体的类\n\t// 注意一种错误:参数和返回值不能是相同的类！！\n    @Provides\n    @Singleton\n    ThreadExecutor provideThreadExecutor(JobExecutor jobExecutor) {\n        return jobExecutor;\n    }\n\n\t// ③这种写法会自动构造参数，前提是RetrofitManager，有provider或者@inject\n    @Provides\n    @Singleton\n    ApiService providesApiService(RetrofitManager retrofitManager) {\n        return retrofitManager.getService();\n    }\n\n\t// ④这种写法是比较常见的，内部new一个对象返回\n    @Provides\n    @Singleton\n    DBManager provideDBManager() {\n        return new DBManager(application);\n    }\n}\n```\t","source":"_posts/Android注入框架Dagger2学习笔记.md","raw":"title: Android注入框架Dagger2学习笔记\ndate: 2016-03-06 12:47:07\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n\n## 简介\nDagger2是一个Google推荐的注入框架，关于什么是注入，为什么需要注入，可以参考下面的疑问以及解答文章。如果你在项目中使用MVP架构开发，强烈建议配合dagger2一起使用。\nDagger2大量使用注解，使开发者可以优雅的构造对象，同时，这些注解仅在编译期间生成代码，没有用到运行时的反射，对性能的影响可以忽略。使用者可以查看编译期间生成的代码，方便debug。\n本文是学习Dagger2的笔记，需要先学习下面的文章，了解Dagger2，然后在学习过程中有一些疑问，形成一些思考与测试，形成此文。但是我还没有机会在项目中实际使用，若以后有实践经验会不断补充。\n\n主要学习的文章：\n\n*  [Android常用开源工具（1）-Dagger2入门](http://blog.csdn.net/duo2005duo/article/details/50618171)：dagger2的基本用法，很好的文章。\n*  [Android常用开源工具（2）-Dagger2进阶](http://blog.csdn.net/duo2005duo/article/details/50696166)：dagger2的一些高级用法，如限定符。\n*   [详解Dagger2](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html)：这篇文章翻译的不好，参考英文原文。\n\n### 疑问以及解答\n* [什么是依赖注入](<http://www.codekk.com/open-source-project-analysis/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>)\n\n* [Dagger 源码解析](http://www.codekk.com/blogs/detail/54cfab086c4761e5001b2537)：dagger第一代的讲解，参考了解两者的差异。\n\n* [Android中是否有必要使用依赖注入的争议](<http://dk-exp.com/2015/01/28/use-ioc-in-android/>)\n\n## 一个非常容易的错误\ninject的参数。。。不能是父类，必须是你注入的那个内\n\n## 一个重要的概念：向子图暴露\n即在component中写如下方法向把它依赖的component来暴露构造方法，且只能暴露一层。\n\n```java\n//定义ComponentB,modules可以不写，也可以与其他Component依赖的modules相同\n@Component(modules={××××××××})\ninterface ComponentB{\n    // 必须暴露出来，给A注入的对象用\n    Apple apple()\n}\n//定义ComponentA，dependencies是A依赖的，区分 extend ComponentB\n@Component(dependencies={ComponentB.class},modules={××××××××})//使用dependencies\ninterface ComponentA{\n    // 注意注入的必须是具体的子类MyApp/XXActivity，不能是父类，如Application/Activity\n    void inject(MyApp app)\n}\n```\n\n## 错误汇总\n1. 错误: com.android.example.devsummit.archdemo.di.module.Apple is bound multiple times:\n\n\t原因：一个类定义了多个provider：\n\t* component关联的（n个或者1个）module中有重复的provider\n\t* component A有dependencies的component B，A关联的Module A中有provider，component B关联的Module B中也有provider，**且在component B中暴露出来了**（不暴露不影响）\n\n\t下面的情况**没有**影响：\n\t\n\t* component 关联的module有provider，且类自己的构造函数有Inject标志，不影响，且provider优先。\n\t* component A有dependencies的component B， A关联的Module A中有provider，component B关联的Module B中也有provider，但是component B中没有暴露，不影响\n \n\n2. 错误: Types may only contain one @Inject constructor.\n\n\t原因：一个类的构造函数只能有一个有@inject\n\n3. 错误: com.android.example.devsummit.archdemo.di.module.Apple cannot be provided without an @Inject constructor or from an @Provides-annotated method.\n\n\t原因：\n\t* 没有provider或者inject\n\t* 如果component含有dependencies，可能没有向外面暴露\n\n##区分易混淆的概念\n\n1. component与module\n2. component的dependencies与component接口的继承（extend）\n\n## 关于Scope的粗浅理解\n### 概念\nscope是范围，标志一个注入器/对象的使用范围，那么可以理解：\n\n* 父类（dependencies）有范围，子类必须有，且要小于它\n* 父类子类范围不能一样？\n* component中某一个对象构造有范围（Module中的一个方法有范围），那么该component就有范围。\n\n### 作用\n作用是允许对象被记录在正确的组件（component）。即module的构造方法用在正确的注入器（component）中，防止用错地方。**因为一个component关联的module中如果有其他的scope的provider会报错，因为component没有这个scope。**\n\n### 自定义scope\n```java\n@Scope\n@Documented\n@Retention(RUNTIME)\npublic @interface Singleton{}\n```\n\n### 使用scope时规则\n结合scope的概念理解\n\n* component关联的Model中的**任何一个被构造的对象**有scope，则该整个component要加上这个scope。在暴露或者注入时（不暴露且不注入时，既不使用它构造对象时，不报错），会有如下错误\n > Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) may not reference scoped bindings:\n@Provides @com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.vo.User com.android.example.devsummit.archdemo.di.module.TestModule.user()\n\n* component的dependencies与component自身的scope不能相同，即组件之间的scope不同\n* Singleton的组件不能依赖其他scope的组件，只能其他scope的组件依赖Singleton的组件。\n* 没有scope的不能依赖有scope的组件，理解一下。。。\n\n  > Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) cannot depend on scoped components:\n@com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.di.component.MyTestComponentX\n* 一个component不能同时有多个scope(Subcomponent除外)\n\n\t> Error:Execution failed for task ':app:compileDebugJavaWithJavac'.\n\t> java.lang.IllegalArgumentException: com.android.example.devsummit.archdemo.di.component.MyTestComponent was annotated with more than one @Scope annotation\n\n## 其他概念\n### @Subcomponent\nSubcomponent与dependencies区别：\ndependencies不会继承范围，Subcomponent会。子component同时具备两种不同生命周期的scope。\n\n## 实践\n### Module\ndagger使用的目的在于更多的使用面向接口的编程。在Module中构造的对象返回的应当尽量是：**构造具体的类的实现，但是返回接口**，如②中所示，参考[文章](http://www.jianshu.com/p/c2feb21064bb)，常用写法如下：\n\n```java\n@Module\npublic class AppModule {\n    private final MyApplication application;\n\n    public AppModule(MyApplication application) {\n        this.application = application;\n    }\n\n\t// ①这种情况是返回module内部保持的变量\n    @Provides\n    @Singleton\n    Context provideApplicationContext() { \n       return application;\n    }\n\n\t// ②这种含有参数的写法会自动构造参数，前提是provideThreadExecutor，有provider或者@inject，ThreadExecutor是接口，JobExecutor是具体的类\n\t// 注意一种错误:参数和返回值不能是相同的类！！\n    @Provides\n    @Singleton\n    ThreadExecutor provideThreadExecutor(JobExecutor jobExecutor) {\n        return jobExecutor;\n    }\n\n\t// ③这种写法会自动构造参数，前提是RetrofitManager，有provider或者@inject\n    @Provides\n    @Singleton\n    ApiService providesApiService(RetrofitManager retrofitManager) {\n        return retrofitManager.getService();\n    }\n\n\t// ④这种写法是比较常见的，内部new一个对象返回\n    @Provides\n    @Singleton\n    DBManager provideDBManager() {\n        return new DBManager(application);\n    }\n}\n```\t","slug":"Android注入框架Dagger2学习笔记","published":1,"updated":"2016-03-06T05:40:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilg4yv6t000s0uc95qwtnlls","sticky":0},{"title":"Android图片库--Glide Wiki中文翻译","date":"2016-01-24T02:32:54.000Z","description":"Glide Wiki中文翻译。Glide是一个Android图片库，确切地说应当叫『媒体框架』。支持图片、Gif、原生视频的加载。使用简单，性能优异，Google推荐。","_content":"## 序\n最近，一直在捣鼓Glide这个图片库，确切地说应当叫『媒体框架』。为了支持Gif播放，项目中使用Glide代替了Universal Image Loader。起初我们打算使用的是Fresco方案，最终因为Lib体积的问题放弃。万万没想到apk的size这么敏感，国外很多推广服务是根据apk体积收费的，3M一个门槛，5M一个门槛。fresco引入之后即使proguard、7zip，apk的大小也增加了1M+，多平台的os库是个大头，第三世界的应用市场还不支持按平台分发😓。。\nGlide的使用还不深入，仅仅停留在Api的范畴，为了解决bug，跟踪了代码，也是云里雾里。不得不说，Glide源码的设计十分NB，面向接口的理念贯彻的很彻底，是一个学习设计的好demo。\nGitHub的README作为最简单的入门足够了，但是遇到具体问题还是要理解一些设计思想的，GitHub上的Wiki有一份不错的文档，可惜木有中文，正好学习的过程中翻译一下。\n在看wiki之前，可以先看这两篇中文入门，了解基本的用法。\n\n* [Google推荐的图片加载库Glide介绍](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html)\n* [Glide 一个专注于平滑滚动的图片加载和缓存库](http://www.jianshu.com/p/4a3177b57949)\n\n本文是基于**Glide 3.x**正式版的[Wiki文档](https://github.com/bumptech/glide/wiki)的翻译（原文编辑日期：2015-2-9,18 revision，当时Glide release的版本号3.6.1）。\n\n翻译Version：1.1 简单校对\n\n### 名词解释\nGlide中有一部分单词，我不知道用什么中文可以确切的表达出含义，用英文单词可能在行文中更加合适，还有一些词在Glide中有特别的含义，我理解的可能也不深入，这里先记录一下。\n\n* View： 一般情况下，指Android中的View及其子类控件（包括自定义的），尤其指ImageView。这些控件可在上面绘制Drawable\n* Target： Glide中重要的概念，目标。它即可以指封装了一个View的Target（ViewTarget），也可以不包含View（SimpleTarget）。\n* Drawable： 指Android中的Drawable类或者它的子类，如BitmapDrawable等。或者Glide中基础Drawable实现的自定义Drawable（如GifDrawable等）\n* Request - 加载请求，可以是网络请求或者其他任何下载图片的请求，也是Glide中的一个类。\n* Model：数据源的提供者，如Url，文件路径等，可以从model中获取InputStream。\n* Signature：签名，可以唯一地标识一个对象。\n* recycle()：Glide中Resource类有此方法，表示该资源不被引用，可以放入池中（此时并没有释放空间）。Android中Bitmap也有此方法，表示释放Bitmap占用的内存。\n\n## 目录\n* 主目录\n* 缓存机制与缓存失效\n* Glide配置\n* 自定义Target\n* 调试与错误处理\n* 使用Glide下载自定义大小图片\n* 集成库-与其他库相整合\n* 在后台线程中加载与缓存数据\n* Glide中的资源复用\n* 快照（Snapshots）\n* 图形变换（Transformations）\n\n---------\n\n## 主目录\n\n### 报告问题\n如果你有任何问题，可以在[Github上提出](https://github.com/bumptech/glide/issues/)或者发送e-mail到我们的[邮件列表](https://groups.google.com/forum/#!forum/glidelibrary)，也可以在IRC(Internet Relay Chat 网络中继聊天？)频道上联系我们：[irc.freenode.net#glide-library](http://webchat.freenode.net/?channels=glide-library)。\n\n### 3.0版本的新特性\n* 支持Gif动画的解码 - 与加载图片相同，只要调用Glide.with(...).load(...)，如果你加载的图片是一个可以播放的Gif，Glide会自动加载它并显示在一个自定义的Drawable上（注：GifDrawable）。此外，你还可以控制的更多，比如\n\n\t```java\n// 你想加载Gif为一张静态图片\nGlide.with(context).load(...).asBitmap()。\n// 或者你想只有加载对象是Gif时才能加载成功\nGlide.with(context).load(...).asGif()。\n```\n\n* 本地视频播放技术 - 除了解码Gif，Glide也能解码你设备上的视频（video）。使用方法和加载gif相同，Glide支持所有Android可以直接解码的视频。\n* 支持缩略图加载 - 有时我们希望减少用户等待的时间又不想牺牲图片的质量，我们可以同时加载多张图片到一个View中，先加载缩略图（只有view的1/10大小），然后再加载一个完整的图像覆盖在上面。使用下面的代码\n\n\t```java\nGlide.with(yourFragment).load(yourUrl).thumbnail(0.1f).into(yourView)\n```\n\n当然，你也可以传入一个Request到`.thumbnail()`函数中作为参数。\n\n* 与生命周期集成 - 加载请求现在会自动在onStop中暂停在，onStart中重新开始。为了节约电量，Gif动画也会在onStop中自动暂停。此外，当设备的连接状态改变时，所有失败的请求会自动重试，确保Glide不会因为临时性的连接问题，导致请求永远失败。\n* 转码 - 除了解码资源，Glide的`.toBytes()`和`.transcode()`方法允许你在后台正常地获取、解码、变换一张图片。你还可以在这些调用中把图片转码成更有用的格式，比如，上传一张大小为250*250像素的用户头像的图片bytes数据，代码如下\n\n\t```java\nGlide.with(context)\n    .load(“/user/profile/photo/path”)\n    .asBitmap()\n    .toBytes()\n    .centerCrop()\n    .into(new SimpleTarget<byte[]>(250, 250) {\n        @Override\n        public void onResourceReady(byte[] data, GlideAnimation anim) {\n            // 在此处，将bytes数据传入后台线程，再上传他们\n        }\n    });\n```\n\n* 动画 - Glide3.X支持『淡入淡出』动画（`.crossFade()`）和view的属性动画(`.animate(ViewPropertyAnimation.Animator)`)。此外，还有Glide2.0就支持的android view动画。\n* 支持 OkHttp 和 Volley - 现在你可以选择用OkHttp、Volley或者默认的HttpUrlConnection作为网络栈。OkHttp和Volley可以通过添加对应的集成库(integration library)和注册相应的`ModelLoaderFactory`来引入。具体查看ReadMe文件。\n* 其他 - 可以使用Drawable对象作为加载中的占位图、请求优先级、覆盖自定义宽和高、可以缓存变换后的缩略图或者缓存原始文件\n\n### 从2.0迁移到3.0\n* 将所有的`Glide.load()`替换为`Glide.with([fragment/activity/context]).load()`。\n* 将所有的自定义的加载调用`Glide.load(url).into(new SimpleTarget(){ ... }).with(context)`替换成`Glide.with(context).load(url).into(new SimpleTarget(width, height) { ... })`。\n\n### 特性\n除了3.0引入的新功能，Glide继承了2.0的所有功能：\n\n* 后台图片加载\n* 如果你使用了listview的复用机制，那么Glide会自动取消作业（job）\n* 内存和磁盘缓存\n* Bitmap和资源池来减少内存抖动\n* 支持任意的图像变换\n\n---------\n\n## 缓存机制与缓存失效\n缓存失效是一个比较复杂的话题，理想情况下，你尽可能不要考虑这个问题。这一节主要是让你粗略的了解一下Glide中cache的key是如何生成，以及提供一些关于如何合理利用缓存的提示。\n### 缓存的key\n`DiskCacheStrategy.RESULT`磁盘缓存策略（注：我们配置的一种磁盘缓存策略）使用的key由以下四个主要部分组成：\n\n* DataFetcher的方法`getId()`返回的字符。典型地，DataFetcher仅仅返回由数据Model的`toString()`方法得到的值。所以，如果Model是一个**URL**，那么会返回URL的字符串，如果Model是是一个文件，那么会返回文件的**路径**。。。\n* 宽和高。如果你调用过override(width,height)方法，那么就是是它传入的值。没有调用过，默认是通过**Target**的`getSize()`方法获得这个值。\n* 各种编码器、解码器的`getId()`方法返回的字符串。这些编码器、解码器用于加载和缓存你的图片。仅有哪些堆bytes数据有影响的编码器、解码器才会有这些`id`值。比如，你只有一个将bytes数据写入磁盘的编码器，那么它就没有id值，因为不管怎样它都不会修改数据。\n* 可选地，你可以为图片加载提供签名(Signature)，请看下面的缓存失效部分。\n\n所有的这些key，以特定的顺序计算出hash值，并将这个值作为保存图片到磁盘上的唯一且安全的文件名。\n\n### 缓存失效\n由于文件名是hash值，没有简便的方式删除磁盘上某个特定url或者文件路径的所有缓存文件。如果仅仅缓存原文件，问题可能还比较简单，但是Glide会缓存缩略图，各种变换后的图片，所有这些缓存都会产生新文件。跟踪和删除所有文件是十分困难的。\n\n### 自定义缓存失效\n通常情况下改变缓存的标志（key）是困难的。Glide提供了`signature()`API来混入其他数据，帮助你控制缓存的key。签名（Signature）对于多媒体或者有版本信息的内容来说都很有用。\n\n* 媒体库内容 - 对于媒体库内容，你可以使用Glide的`MediaStoreSignature`类作为签名， MediaStoreSignature类允许你混入文件修改时间、mime类型、媒体库的方向(orientation?)这些值作为缓存的key，这三个值足以让你可靠的捕捉到任何修改和更新，使你可以缓存媒体库的缩略图.?\n* 文件 - 你可以使用`StringSignature`混入文件修改时间\n* url - 虽然使url失效最好的方式是当内容变化时，服务器修改url并更新客户端，但是你也可以用`StringSignature`混入任意的元数据（如版本号）来使缓存失效。\n\n使用String Signature加载数据很简单：\n\n```java\nGlide.with(yourFragment)\n    .load(yourFileDataModel)\n    .signature(new StringSignature(yourVersionMetadata))\n    .into(yourImageView);\n```\n\n媒体库Signature可以直接使用从MeidaStore(注：一个android api）获得的数据\n\n```java\nGlide.with(fragment)\n    .load(mediaStoreUri)\n    .signature(new MediaStoreSignature(mimeType, dateModified, orientation))\n    .into(view);\n```\n\n你还可以通过实现`key`接口来自定义签名，确保实现了`equals()`, `hashCode()`和`updateDiskCacheKey()`这几个方法\n\n```java\npublic class IntegerVersionSignature implements Key {\n    private int currentVersion;\n \n    public IntegerVersionSignature(int currentVersion) {\n         this.currentVersion = currentVersion;\n    } \n \n    @Override \n    public boolean equals(Object o) {\n        if (o instanceof IntegerVersionSignature) {\n            IntegerVersionSignature other = (IntegerVersionSignature) o;\n            return currentVersion = other.currentVersion;\n        } \n        return false; \n    } \n \n    @Override \n    public int hashCode() { \n        return currentVersion;\n    } \n \n    @Override \n    public void updateDiskCacheKey(MessageDigest md) {\n        messageDigest.update(ByteBuffer.allocate(Integer.SIZE).putInt(signature).array());\n    } \n} \n```\n请牢记：为了避免性能下降，请在后台线程中批量加载版本元数据(metaData，注：一般查询数据库获得)，只有这样，才能确保当你想加载图片的时候，这些值是可用的。\n\n如果这些方法都失败了，比如，你不能改变标识符，也不能跟踪一个合理的版本号。你还可以使用`diskCacheStrategy()`和`DiskCacheStrategy.NONE.`来完全关闭磁盘缓存。\n\n---------\n\n## 配置\n\n### 懒加载配置\n从Glide3.5开始，你可以使用`GlideModule`接口来懒加载配置Glide以及注册组件（如`ModelLoaders`)，这些配置将会在第一个Glide请求发起的时候被调用。\n\n### 创建一个GlideModule\n为了使用和注册GlideModule，首先需要实现该接口，加入你的配置和组件。\n\n```java\npackage com.mypackage; \n \npublic class MyGlideModule implements GlideModule { \n    @Override public void applyOptions(Context context, GlideBuilder builder) {\n        // Apply options to the builder here. \n    } \n \n    @Override public void registerComponents(Context context, Glide glide) {\n        // register ModelLoaders here. \n    } \n} \n```\n\n然后，添加你的实现类到`proguard.cfg`文件中，让你的module可以被反射调用到。这个性能开支很少，因为每个module只会在Glide第一次请求的时候实例化一次。\n\n```xml\n-keepnames class com.mypackage.MyGlideModule\n# or more generally:\n#-keep public class * implements com.bumptech.glide.module.GlideModule\n```\n\n最后，添加meta-data标记到`AndroidManifest.xml`，那样Glide才能找到它。\n\n```xml\n<manifest ...>\n    <!-- ... permissions -->\n    <application ...>\n        <meta-data\n            android:name=\"com.mypackage.MyGlideModule\"\n            android:value=\"GlideModule\" />\n        <!-- ... activities and other components -->\n    </application>\n</manifest>\n```\n\n你可以实现任意个`GlideModule`，但是每一个都要添加到`proguard.cfg`，而且每一个GlideModule都要在manifest有自己的meta-data标记。\n\n### Library工程\nLibrary工程可能含有一个或多个`GlideModule`。当我们使用Gradle（或者任何支持manifest合并的构建工具）构建app时，如果我们所依赖的Library工程的manifest中含有module，那么这些module会自动并入到app中。如果构建工具不支持manifest合并，那么这些library工程中的module必须手动添加到你app的manifest中。\n\n### GlideModule冲突\n虽然Glide允许每个app注册多个`Glidemodule`，但是不会以某种特定的顺序调用这些module。所以，如果你的app中多个`GlideModules`或者依赖的library工程中有多个`GlideModules`，你必须负责避免他们之间的冲突。\n如果冲突不可避免，app应该定义自己的默认module，这个module需要手动解决这些冲突，提供所有Library工程所需要的依赖。使用Gradle的开发者，或者使用manifest合并的开发者，可以通过下面的标签来排除冲突的module。\n\n```xml\n<meta-data android:name=”com.mypackage.MyGlideModule” tools:node=”remove” />\n```\n\n### 全局配置\n你可以配置一些作用于所有请求的全局性配置项。请使用`GlideModule#applyOptions`方法中（注：作为参数）提供给你的`GlideBuilder`来配置。本节代码示例中的`builder`就是一个GlideModule对象。\n\n### 磁盘缓存\n你可以使用`GlideBuilder`的`setDiskCache()`方法设置磁盘缓存的位置、大小（最大值）。你也可以使用`DiskCacheAdapter`彻底关闭缓存，或者自己实现`DiskCache`接口来换掉默认实现。磁盘缓存由`DiskCache.Factory`接口的实例在后台线程中创建，使用后台线程可以避免在严格模式中出现问题。\nGlide默认使用`InternalCacheDiskCacheFactory`类建立磁盘缓存。这个内部缓存工厂（internal cache factory）会把磁盘缓存放到应用程序的内部缓存目录中，并且设置最大空间是250MB，使用内部缓存的目录而不是SD卡的外部目录意味着其他应用程序无法访问到你下载的图片。具体请查看Android的[存储选项相关文档](http://developer.android.com/intl/zh-cn/guide/topics/data/data-storage.html#filesInternal)。\n\n#### 大小\n使用`InternalCacheDiskCacheFactory`设置磁盘缓存大小\n\n```java\nbuilder.setDiskCache(\n  new InternalCacheDiskCacheFactory(context, yourSizeInBytes));\n```\n\n#### 位置\n也可以设置磁盘缓存位置\n你可以使用`InternalCacheDiskCacheFactory `来把你的磁盘缓存放到应用程序私有的内部存储目录中：\n\n```java\nbuilder.setDiskCache(\n  new InternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));\n```\n还可以用`ExternalCacheDiskCacheFactory `来把你的磁盘缓存放到sd卡的公共缓存目录上。\n\n```java\nbuilder.setDiskCache(\n  new ExternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));\n```\n如果你想用其他自定义的路径，可以用`DiskLruCacheFactory`类的构造函数来实现。\n\n```java\n// If you can figure out the folder without I/O: \n// Calling Context and Environment class methods usually do I/O. \nbuilder.setDiskCache( \n  new DiskLruCacheFactory(getMyCacheLocationWithoutIO(), yourSizeInBytes)); \n \n// In case you want to specify a cache folder (\"glide\"): \nbuilder.setDiskCache( \n  new DiskLruCacheFactory(getMyCacheLocationWithoutIO(), \"glide\", yourSizeInBytes)); \n \n// In case you need to query the file system while determining the folder: \nbuilder.setDiskCache(new DiskLruCacheFactory(new CacheDirectoryGetter() { \n    @Override public File getCacheDirectory() {\n        return getMyCacheLocationBlockingIO(); \n    } \n}), yourSizeInBytes); \n```\n注意：请牢记，写死任何值都不是个好主意，尤其是目录的路径，因为自Android4.2开始，支持单设备多用户。\n\n如果你想完全控制缓存的创建，可以自己实现`DiskCache.Factory `接口，使用`DiskLruCacheWrapper`可以在你想要的位置创建一个新的缓存。\n\n```java\nbuilder.setDiskCache(new DiskCache.Factory() { \n    @Override public DiskCache build() { \n        File cacheLocation = getMyCacheLocationBlockingIO();\n        cacheLocation.mkdirs();\n        return DiskLruCacheWrapper.get(cacheLocation, yourSizeInBytes);\n    } \n}); \n```\n\n### 内存缓存和缓存池\n`GlideBuilder`类允许你设置内存缓存大小，而且可以实现自定义的`MemoryCache`和`BitmapPool`。\n\n#### 大小\n默认大小是由`MemorySizeCalculator`类决定的。MemorySizeCalculator类会考虑该设备的屏幕大小、可用内存来计算出一个合理的默认值。如果你想调整这个默认值，请构建自己的实例。\n\n```java\nMemorySizeCalculator calculator = new MemorySizeCalculator(context);\nint defaultMemoryCacheSize = calculator.getMemoryCacheSize();\nint defaultBitmapPoolSize = calculator.getBitmapPoolSize();\n```\n如果你想在应用的某个阶段动态调整Glide的内存占用，你可以选择一个`MemoryCategory`并使用`setMemoryCategory()`方法传入Glide中：\n\n```java\nGlide.get(context).setMemoryCategory(MemoryCategory.HIGH);\n```\n\n#### 内存缓存\nGlide的内存缓存会在内存中持有资源，它的作用是，我们可以不进行IO操作而快速获得可用资源。\n你可以使用`GlideBuilder`的`setMemoryCache()`方法设置大小，或者设置你关于内存缓存的自定义实现（自定义类）。`LruResourceCache`类是Glide的默认实现。你可以通过`LruResourceCache`的构造函数来配置内存占用的bytes的最大值。\n\n```java\nbuilder.setMemoryCache(new LruResourceCache(yourSizeInBytes));\n```\n\n#### Bitmap池\nGlide的Bitmap池主要作用是，可以让各种尺寸的Bitmap被复用，可以可观地减少由垃圾回收引起的内存抖动。在解码图片时，需要给像素数组分配空间，这会触发垃圾回收。\n你可以使用`GlideBuilder`的`setBitmapPool()`方法设置大小，或者设置你关于Bitmap池的自定义实现，`LruBitmapPool`类是Glide的默认实现。LruBitmapPool类使用了LRU算法维护最近最常使用的Bitmap的尺寸。你可以通过`LruBitmapPool`的构造函数配置内存占用的bytes的最大值。\n\n```java\nbuilder.setBitmapPool(new LruBitmapPool(sizeInBytes));\n```\n\n### Bitmap格式\n`GlideBuilder` 类也允许你配置一个App全局使用的Bitmap的Config属性。\nGlide默认使用RGB_565，因为它每个像素只需要2bytes（16bit）的空间，它仅需要高质量图片（既系统默认的`ARGB_8888 `）一半的内存空间。但是，这对于某些图片这可能会出现『条带』的问题，而且它也不支持透明度。\n如果在你的应用中『条带』是一个重要的问题，或者你需要尽可能好的图片质量，你可以使用`GlideBuilder`的`setDecodeFormat`方法设置DecodeFormat.ALWAYS_ARGB_8888作为首选配置。\n\n```java\nbuilder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);\n```\n\n---------\n\n## 自定义目标（Targets）\n除了可以加载图像，视频剧照，gif动画到View中，你还可以加载他们到实现了Target接口的自定义目标中。\n\n### SimpleTarget\n如果你只是想加载一个Bitmap，并不想直接展示给用户而是有一些特殊用途，比如在通知栏中显示或者作为头像上传。\nGlide也可以做到。\nSimpleTarget为Target接口提供了大部分的默认实现。你可以专注于处理加载的结果。\n为了使用SimpleTarget，你需要在它的构造函数中提供你要加载的资源的宽和高（单位像素），你还需要实现` onResourceReady(T resource, GlideAnimation animation)`方法。\n一个典型的使用SimpleTarget的例子如下：\n\n```java\nint myWidth = 512;\nint myHeight = 384;\n \nGlide.with(yourApplicationContext)) \n    .load(youUrl) \n    .asBitmap() \n    .into(new SimpleTarget<Bitmap>(myWidth, myHeight) {\n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            // Do something with bitmap here. \n        } \n    }; \n```\n\n#### 一些警告\n正常情况下，你加载一个资源会把他们放到view中。当你的Activity或者Fragment被pause或者destroy时，Glide会暂停或取消加载，确保你不会加载那些根本不会显示的资源。\n可是当我们使用SimpleTarget的时候，这可能并不是我们希望的行为。所以，当你调用`Glide.with(context)`的时候，你可以传入Application的context，而不是传入Activity或者Fragment。\n此外，考虑到长时间的加载操作可能导致内存泄漏，请考虑使用静态内部类，而不是匿名内部类。\n\n### ViewTarget\n如果你想加载一个图片到View中，但是你想观察或者覆盖Glide的默认行为。你可以覆盖ViewTarget或者它的子类。\n当你想让Glide来获取view的的大小，但是由自己来启动动画和设置资源到view中，ViewTarget是个不错的选择。如果你要加载一个图片到ImageView之外的自定义view中，那么ImageViewTarget或者它的子类就不能满足你的要求，此时继承ViewTarget就特别合适。\n你可以静态的定义一个ViewTarget的子类，或者传递一个匿名内部类到你的加载调用里：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .into(new ViewTarget<YourViewClass, GlideDrawable>(yourViewObject) {\n        @Override\n        public void onResourceReady(GlideDrawable resource, GlideAnimation anim) {\n            YourViewClass myView = this.view;\n            // Set your resource on myView and/or start your animation here.\n        }\n    });\n```\n注意，如果你想指定加载Bitmap还是GifDrawable，请在`.load(yourUrl)`调用后面直接添加`.asBitmap()`或者`.asGif()`，同时将ViewTarget的类型参数`GlideDrawable`换成对应加载的类型。\n为了更多控制，你也可以在Target实现`LifecycleListener`回调，`onStart()`、`onStop()`或者`onDestroy()`会和你view所在的fragment的生命周期保持同步。\n\n### 覆盖默认行为\n如果你只想观察不想修改Glide的默认行为，你可以继承任何一个Glide对ImageViewTargets的默认实现。\n\n* GlideDrawableImageViewTarget - 默认的Target，用于正常的加载和`asGif()`。\n* BitmapImageViewTarget - 当使用`asBitmap()`加载时，使用的默认Target。\n\n只有你在每个方法里面调用`super()`，将会保留默认的行为，同时还可以添加一些你希望的功能。\n\n例如，想要生成一个[调色板](http://chris.banes.me/2014/07/04/palette-preview/)，你可以这样做。\n\n```java\nGlide.with(yourFragment) \n    .load(yourUrl) \n    .asBitmap() \n    .into(new BitmapImageViewTarget(yourImageView)) { \n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            super.onResourceReady(bitmap, anim);\n            Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() {  \n                @Override \n                public void onGenerated(Palette palette) {\n                    // Here's your generated palette \n                } \n            }); \n        } \n    }); \n```\n虽然这个例子还不错，但是，通常情况下，我不推荐用这个方式生成调色板。请查看Glide的 `ResourceTranscoder` 接口和`.transcode()`方法，考虑返回一个包含Bitmap和调色板的自定义资源。调色板可在在后台线程生成。？？？？？更多内容会在以后推出。。。\n\n---------\n\n## 调试和错误处理\nGlide在加载过程中出现异常默认情况下不会打日志。Glide为你提供了两种方式查看和处理这些异常。\n\n### 调试\n仅仅为了查看异常的话，你可以为`GenericRequest`类打开Debug日志。这个类处理所有媒体资源的加载响应（response）。你可以在命令行里运行：\n\n```xml\nadb shell setprop log.tag.GenericRequest DEBUG\n```\n想要包括详细的请求时序信息，你可以把`DEBUG`缓存`VERBOSE`。\n\n关闭日志使用：\n\n```xml\nadb shell setprop log.tag.GenericRequest ERROR\n```\n\n### 调试[工作流](https://docs.google.com/drawings/d/1KyOJkNd5Dlm8_awZpftzW7KtqgNR6GURvuF6RfB210g/edit)\n为了查看内部引擎（engine）如何以及何时查找到资源，你可以打开日志：\n\n```xml\nadb shell setprop log.tag.Engine VERBOSE\nadb shell setprop log.tag.EngineJob VERBOSE\nadb shell setprop log.tag.DecodeJob VERBOSE\n```\n打开这个有助于你找出为什么某个资源没有从内存缓存中加载，为什么请求再次从外部的url下载数据。这也可以帮助你了解：如果想命中磁盘缓存，什么样的参数需要匹配。启用`DecodeJob`日志也可以帮助你去定位自定义transformation/decoder/encoder相关的问题。\n\n### 监听请求-RequestListener\n虽然启用debug日志很简单，但是只有在你可以连接到设备时才能这样干。为了把Glide集成到已有的更专业的错误日志系统。你可以使用`RequestListener`类的`onException()`。当请求失败时，该方法会告知你导致失败的`异常`(Exception)，如果解码器（Decoder）不能从数据中解析出任何有用的信息，Exception也可能传`null`。你可以使用`listener()`API传一个你的监听器（listener）到每一个请求中。\n请确保`onException()`返回`false`，以免覆盖了Glide的默认错误处理行为（例如，它默认会通知`Target`这个error）。\n这是一个快速调试的例子：\n\n```java\n// example usage: .listener(new LoggingListener<String, GlideDrawable>()) \npublic class LoggingListener<T, R> implements RequestListener<T, R> {\n    @Override public boolean onException(Exception e, Object model, Target target, boolean isFirstResource) {\n        android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT,\n                \"onException(%s, %s, %s, %s)\", e, model, target, isFirstResource), e);\n        return false; \n    } \n    @Override public boolean onResourceReady(Object resource, Object model, Target target, boolean isFromMemoryCache, boolean isFirstResource) {\n        android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT,\n                \"onResourceReady(%s, %s, %s, %s, %s)\", resource, model, target, isFromMemoryCache, isFirstResource));\n        return false; \n    } \n} \n```\n**确保发版前移除相关代码**\n\n### 更多日志\n这个列表是给3.6.0版本用的，可能不完整。\n\n```xml\ncd .../android-sdk/platform-tools\nadb shell setprop log.tag.AnimatedGifEncoder VERBOSE\nadb shell setprop log.tag.AssetUriFetcher VERBOSE\nadb shell setprop log.tag.BitmapEncoder VERBOSE\nadb shell setprop log.tag.BufferedIs VERBOSE\nadb shell setprop log.tag.ByteArrayPool VERBOSE\nadb shell setprop log.tag.CacheLoader VERBOSE\nadb shell setprop log.tag.ContentLengthStream VERBOSE\nadb shell setprop log.tag.DecodeJob VERBOSE\nadb shell setprop log.tag.DiskLruCacheWrapper VERBOSE\nadb shell setprop log.tag.Downsampler VERBOSE\nadb shell setprop log.tag.Engine VERBOSE\nadb shell setprop log.tag.EngineRunnable VERBOSE\nadb shell setprop log.tag.GenericRequest VERBOSE\nadb shell setprop log.tag.GifDecoder VERBOSE\nadb shell setprop log.tag.GifEncoder VERBOSE\nadb shell setprop log.tag.GifHeaderParser VERBOSE\nadb shell setprop log.tag.GifResourceDecoder VERBOSE\nadb shell setprop log.tag.Glide VERBOSE\nadb shell setprop log.tag.ImageHeaderParser VERBOSE\nadb shell setprop log.tag.ImageVideoDecoder VERBOSE\nadb shell setprop log.tag.IVML VERBOSE\nadb shell setprop log.tag.LocalUriFetcher VERBOSE\nadb shell setprop log.tag.LruBitmapPool VERBOSE\nadb shell setprop log.tag.MediaStoreThumbFetcher VERBOSE\nadb shell setprop log.tag.MemorySizeCalculator VERBOSE\nadb shell setprop log.tag.PreFillRunner VERBOSE\nadb shell setprop log.tag.ResourceLoader VERBOSE\nadb shell setprop log.tag.RMRetriever VERBOSE\nadb shell setprop log.tag.StreamEncoder VERBOSE\nadb shell setprop log.tag.TransformationUtils VERBOSE\n```\n\n---------\n\n## 使用Glide下载自定义大小的图片\n开发者可以通过Glide的ModelLoader接口获得图片大小，并根据这个大小来加载一个合适尺寸的图片url。\n使用合适尺寸的图片可以节约带宽，设备的存储空间，还可以提升app性能。\n2014年的Google I/O app团队写了一篇关于如何使用ModelLoader接口调整加载的图片大小的文章。请在GitHub上查看 [I/O app的源码](https://github.com/google/iosched/blob/master/doc/IMAGES.md)。\n为了实现自定义的ModelLoader来通过http/https下载图片，可以继承BaseGlideUrlLoader这个类\n\n```java\npublic interface MyDataModel { \n    public String buildUrl(int width, int height);\n}  \n \npublic class MyUrlLoader extends BaseGlideUrlLoader<MyDataModel> { \n    @Override \n    protected String getUrl(MyDataModel model, int width, int height) {\n        // Construct the url for the correct size here. \n        return model.buildUrl(width, height);\n    } \n} \n```\n\n然后，你就可以使用自定义的ModelLoader来加载图片了，其他的事情会自动完成：\n\n```java\nGlide.with(yourFragment)\n    .using(new MyUrlLoader())\n    .load(yourModel)\n    .into(yourView);\n```\n\n如果你想避免调用`.using(new  MyUrlLoader())`，你可以实现一个自定义的`ModelLoaderFactory`，并在`GlideModule`中注册它。\n\n```java\npublic class MyGlideModule implements GlideModule { \n    ... \n    @Override \n    public void registerComponents(Context context, Glide glide) {\n        glide.register(MyDataModel.class, InputStream.class, \n            new MyUrlLoader.Factory()); \n    } \n} \n```\n\n注册ModelLoaderFactory之后，你就不用调用`.using()`了：\n\n```java\nGlide.with(yourFragment)\n    .load(yourModel)\n    .into(yourView);\n```\n\n其他的例子，关于如何使用自定义ModelLoader加载各种尺寸的图片，请查看[Flicker示例应用](https://github.com/bumptech/glide/blob/master/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java)，和[Giphy示例应用](https://github.com/bumptech/glide/blob/master/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java)。\n\n---------\n\n## 集成（Integration）库-Glide与其他库整合\n\n### 介绍\n\n####什么是集成库（Integration Library）\nGlide包括一系列小巧可配置的集成库，这些库可以让Glide与外部的库相结合。现在集成库可以使Glide支持Volley和OkHttp的http/https请求。\n\n我们坚信，您所选择的客户端媒体库既不应该决定你在你的应用程序中使用的网络库，也不需要你仅仅为了加载图像额外添加网络库。集成库和Glide的ModelLoader系统，允许开发人员对所有网络请求使用统一的网络库。\n\n#### 为什么没有XXX库的实现\n因为我们还没有为这个库写集成库。OkHttp和Volley是十分流行的库，许多开发者都使用，但是，我们不是排斥其他库，如果你写了其他库的`ModelLoader`并且打算开源，我们很乐意看到这样的提交请求（pull request）。\n\n#### 我如何依赖一个集成库呢？\n依赖任何的集成库需要两g个步骤。\n\n1. 添加相应的继承库的Maven/Gradle/jar依赖，因为作为可选项的集成库并不包含在glide的jar依赖中。\n2. 确保app包含了集成库的GlideModule，具体内容看[配置wiki](https://github.com/bumptech/glide/wiki/Configuration)部分。对于Glide集成库的具体说明见下面。\n\n#### 我应当选择哪个版本？\n集成库的版本跟随着Glide的release版本。但是多了一个不同的数字。确保选择与所依赖的Glide对应的集成库。在[release页](https://github.com/bumptech/glide/releases)查看.\n网络库有自己的版本号。继承库会依赖的库就是你在Maven/Gradle中指定的库。你可以通过版本号来指定具体依赖的网络库。？？\n\n### Volley\nVolley是一个Http库，可以使Android上的网络请求更简单，更快速。\n\n#### Gradle中使用Volley\n\n```java\ndependencies {\n    compile 'com.github.bumptech.glide:volley-integration:1.3.1@aar'\n    //compile 'com.mcxiaoke.volley:library:1.0.8'\n}\n```\n集成库的`GlideModule`会自动合并到你app的manifest中。\n\n#### Maven中是Volley\n\n```xml\n<dependency>\n    <groupId>com.github.bumptech.glide</groupId>\n    <artifactId>volley-integration</artifactId>\n    <version>1.3.1</version>\n    <type>aar</type>\n</dependency>\n<dependency>\n    <groupId>com.mcxiaoke.volley</groupId>\n    <artifactId>library</artifactId>\n    <version>1.0.8</version>\n    <type>aar</type>\n</dependency>\n\n```\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### 手动添加Volley\n从[release页](https://github.com/bumptech/glide/releases)下载[glide-volley-integration-<version>.jar ](https://github.com/bumptech/glide/releases/download/v3.6.1/glide-volley-integration-1.3.1.jar)。并添加到你app的编译路径中(compile classpath)。\n\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### Volley的Manifest\n如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加`GlideModule`的metadata标签到`AndroidManifest.xml`中。\n\n```xml\n<meta-data\n    android:name=\"com.bumptech.glide.integration.volley.VolleyGlideModule\"\n    android:value=\"GlideModule\" />\n```\n\n#### Volley的混淆设置\n无论使用什么编译系统，不要混淆`VolleyGlideModule`类，它需要被反射来实例化。添加下面的代码到`proguard.cfg`文件（或者查看“通用部分”）。\n\n```java\n-keep class com.bumptech.glide.integration.volley.VolleyGlideModule\n```\n\n### OkHttp\nOKHttp是一个高效且易于使用的Http客户端。\n\n#### Gradle中使用OkHttp\n\n```java\ndependencies {\n    compile 'com.github.bumptech.glide:okhttp-integration:1.3.1@aar'\n    //compile 'com.squareup.okhttp:okhttp:2.2.0'\n}\n```\n集成库的`GlideModule`会自动合并到你app的manifest中。\n\n#### Maven中是OkHttp\n\n```xml\n<dependency>\n    <groupId>com.github.bumptech.glide</groupId>\n    <artifactId>okhttp-integration</artifactId>\n    <version>1.3.1</version>\n    <type>aar</type>\n</dependency>\n<!--\n<dependency>\n    <groupId>com.squareup.okhttp</groupId>\n    <artifactId>okhttp</artifactId>\n    <version>2.2.0</version>\n    <type>jar</type>\n</dependency>\n-->\n\n```\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### 手动添加OkHttp\n从[release页](https://github.com/bumptech/glide/releases)下载[glide-okhttp-integration-<version>.jar ](https://github.com/bumptech/glide/releases/download/v3.6.1/glide-okhttp-integration-1.3.1.jar)。并添加到你app的编译路径中(compile classpath)。\n\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### OkHttp的Manifest\n如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加`GlideModule`的metadata标签到`AndroidManifest.xml`中。\n\n```xml\n<meta-data\n    android:name=\"com.bumptech.glide.integration.okhttp.OkHttpGlideModule\"\n    android:value=\"GlideModule\" />\n```\n\n#### OkHttp的混淆设置\n无论使用什么编译系统，不要混淆`OkHttpGlideModule`类，它需要被反射来实例化。添加下面的代码到`proguard.cfg`文件（或者查看“通用部分”）。\n\n```java\n-keep class com.bumptech.glide.integration.okhttp.OkHttpGlideModule\n```\n\n### 更多选项\n\n#### 通用的混淆配置\n你也可以使用下面的配置来避免混淆所有的`GlideModule`。\n\n```java\n-keep public class * implements com.bumptech.glide.module.GlideModule\n```\n这种方式有其他的好处，当修改集成库或者自定义集成库的行为时，不需要修改。当你添加或者移动其他module的时候，也不需要修改什么。\n\n#### 覆盖默认的行为\n如果默认配置无法满足你，所有的集成库还有一些额外的选项。比如添加重试行为，请查看集成库的`GlideModule`的源码（位于[/integration/<lib>/src/main/java/<package>](https://github.com/bumptech/glide/tree/3.0/integration)）了解默认的注册做了些什么。你可以通过在自定义的`GlideModule`中修改参数为`UrlLoader.Factory`类来改变默认行为。\n当你要覆盖默认行为时，请确保自定义的`GlideModule`被注册，且默认的GlideModule被排除在外。排除GlideModule可能是从manifest中移除相应的的metadata，或者使用jar包依赖代替aar依赖。关于`GlideModule`的更多信息请查看[配置的wiki页](https://github.com/bumptech/glide/wiki/Configuration)\\\n\n---------\n\n## 在后台线程中加载和缓存\n为了使后台加载资源和与媒体交互更加容易，除了`Glide.with(fragment).load(url).into(view)`这个API外，Glide还提供了额外两个API。\n\n* `downloadOnly(int, int)`\n* `into(int, int)`\n\n### downloadOnly方法\nGlide的`downloadOnly(int, int)`方法允许你把图片bytes下载到磁盘缓存中，以便以后获取使用。你可以在UI线程异步地调用`downloadOnly()`，也可以在后台线程同步的使用。但是，注意他们的参数有些不同，异步API的参数是`Target`，同步api的参数是宽和高的整数值。\t\n为了在后台线程下载图片，你必须使用同步方法\n\n```java\nFutureTarget<File> future = Glide.with(applicationContext)\n    .load(yourUrl)\n    .downloadOnly(500, 500);\nFile cacheFile = future.get();\n```\n当future返回时，图片的bytes数据就在缓存中可用了。一种典型的情况是，你使用`downloadOnly()`API只是为了确保数据下载到了磁盘上。一般情况下，虽然你有权访问底层的缓存文件，但是你不需要直接和它交互。\n而是，当你想要获取这个图片时，你只要像平常加载图片时那样调用就行，**只有一点不同**：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .diskCacheStrategy(DiskCacheStrategy.ALL)\n    .into(yourView);\n```\n通过传入 `DiskCacheStrategy.ALL`或者`DiskCacheStrategy.SOURCE`，确保Glide可以使用你通过`downloadOnly()`下载的数据。\n\n### into方法\n如果你想在一个**后台线程**与一张已经解码的图片交互。你可以使用这个版本的`into()`方法来返回一个`FutureTarget`。例如，获取一张中心剪裁后的500*500像素的图片：\n\n```java\nBitmap myBitmap = Glide.with(applicationContext)\n    .load(yourUrl)\n    .asBitmap()\n    .centerCrop()\n    .into(500, 500)\n    .get()\n```\n虽然`into(int, int)`方法在后台线程中很有效，但是，你不能把它用在主线程中。即使这个同步方法在你的主线程中不会抛出异常，调用get()也会阻塞主线程。会使你的APP性能变差，反应迟钝。\n\n---------\n\n## Glide中的资源复用\n\n### 为什么 - 资源复用的作用\nGlide通过复用资源避免不必要的内存分配。Dalvik虚拟机（在Lollipop之前）有两种基本的垃圾回收方式，`GC_CONCURRENT` 和`GC_FOR_ALLOC`。每次`GC_CONCURRENT`会阻塞主线程5ms。由于每次操作的时间少于16ms（1帧的时间），`GC_CONCURRENT`并不会引起掉帧。相反的是`GC_FOR_ALLOC`，他会停止所有操作，阻塞主线程125+ms，事实上，GC_FOR_ALLOC总是会让你的app掉很多帧。尤其是在滑动时，导致明显的卡顿。\n很不幸，即使只是分配适当的空间（比如16kb的buffer）Dalvik表现的也很糟糕。不断的小内存分配，或者一次大的内存分配（比如说bitmap），将会引起GC_FOR_ALLOC。因此，你分配内存的越多，你会遇到垃圾回收器阻塞应用的情况就越多，应用掉帧就越严重。\n通过适度复用大块资源，Glide可以避免内存抖动，减少垃圾回收器阻塞app的次数。\n\n### 怎么做 - Glide是如何复用资源\nGlide的资源复用策略比较宽松。这意味着，当Glide认为该资源可以被安全的复用时，才有几率去复用它，并不需要开发者在每个request后面去手动释放资源。\n\n#### 标志-哪些资源可复用\nGlide有两个简单的标志来识别可复用的资源。\n\n1. `Glide.clear()` \n\n\t在`View`或者`Target`上调用`clear()`方法都表示，Glide要取消加载，可以安全地把Target占用的所有资源（Bitmap，bytes数组等）放入资源池中（pool）。用户可以在任何时候安全地手动调用`clear()`方法，但是典型情况下，我们不需要这样做，看第二条。\n\n2. View或者Target的复用 \n\n\t当用户把图片加载到一个已经存在的View或者Target上时（注：确切的说是调用`into(xxx)`方法之后），Glide会先调用`clear()`清空该View/Target上的加载请求并复用已经显示过的资源。因此，如果你的ListView或者RecyclerView中的view使用了复用机制（注：如ViewHolder），那么Glide会自动为他们缓存资源和管理加载请求。\n \n#### 引用计数\n如果两个请求指向同一个资源，为了避免额外的工作，Glide会把单个资源分配给他们。这就导致一个问题，当Glide得知某个资源不被某个调用者使用，这并不表示它不会被其他调用者使用。为了避免回收调依旧被使用的资源，Glide使用引用计数来跟踪资源。\n当把资源提供给View/Target时，该资源的引用计数加1，当清空View/Target时，引用计数减1。当引用计数为0时，Glide会回收资源，并把它的内容放回可用内存池中。\n\n#### 放入缓存池\nGlide的Resource API有一个`recycle()`方法，当Glide认为资源不再被引用时，会调用该方法，资源会放入缓存池中。\n\nGlide提供的BitmapPool接口可以让Resource获取`Bitmap`和复用Bitmap对象。Glide的BitmapPool可以通过Glide单例获得：\n\n```java\nGlide.get(context).getBitmapPool();\n```\nResourceDecoder可以返回Resource的任何实现。所有，开发者可以实现他们自己的Resource和ResourceDecoder来自定义地缓存一些特有类型的数据。\n同样地，开发者如果想更多地控制Bitmap缓存，可以实现自己的BitmapPool，然后通过GlideModule配置到Glide中。\n\n### 常见的错误\n不幸的是，缓存池设计使我们很难判断开发者是否误用了资源或者bitmap。但是，在Glide中有两个主要的现象会暗示你某些地方可能出了问题。\n\n#### 现象\n\n1. `Cannot draw a recycled Bitmap`\n\n\tGlide有个固定大小的Bitmap池。当Bitmap不再被复用（注：不是使用，区分使用和复用），会从池中移走。Glide会调用[`recycle()`](http://developer.android.com/reference/android/graphics/Bitmap.html#recycle())（注：指的是Bitmap真正的recycle，不是Resource类的recycle）。你告诉Glide放心地回收某个Bitmap，但是，你的应用不小心还持有这个Bitmap的引用，应用程序可能会绘制这个Bitmap，导致崩溃。\n\n2. View在多张图片之间闪烁，或者同样的图片出现在多个View中\n\n\t如果一张图片被放入BitmapPool中多次。或者虽然一张图片被放入了pool中，但是某个View依然持有这个图的引用，与此同时，另一张图片被解析成了Bitmap（注：此Bitmap正好用了刚才那张图片的控件来存放解析后的数据）。如果发生这种事情，Bitmap的内容就会被换成了新的图片内容。此时，View依然尝试着绘制Bitmap，导致原来的View中显示了一张新的图片！\n\n#### 原因\n这些问题主要有两个原因：\n\n1. 尝试加载两个不同的资源到同一Target中\n\n\t在Glide中，没有安全的方法来加载多个资源到单一的Target中。开发者可以使用`thumbnail()`来加载一系列资源到到某个Target中，但是对于每一个加载的资源来说，只有在下一个`onResourceReady()`被调用前，它的引用才是安全的。\n开发者如果想加载多个资源到同一个View中，可以使用两个独立的Target。为了确保加载过程不相互取消，开发者要么不使用ViewTarget的子类，要么在继承ViewTarget时，复写`setRequest()` 和 `getRequest()`，不要使用tag来存储Request。（注：需要一个demo)\n\n\t**译者注：对于同一个view，调用两次Glide.xxx.into(view)，第二次调用会先清空第一个加载的图片（出现空白），再去下载新的图片，如果想要在第二张图片下载下来之前依旧显示之前的，需要一些技巧**\n2. 加载一个资源放入到Target，然后清空或者复用了Target，但是依然引用这这个资源。\n\n\t最简单的避免这个错误的方法是在`onLoadCleared()`方法中把所有对资源对象的引用置null。一般情况下，加载一个Bitmap，然后引用它的Target是安全的。不安全的是，你清空了这个Target，却依然引用着这个Bitmap。\n\t\n---------\n\t\n## 使用快照\n\n### 关于快照\n对于那些不想等待Glide下个正式版本而愿意尝鲜的用户，我们在[Sonatype](https://travis-ci.org/bumptech/glide)上部署了这个库的快照。\n每一次我们push代码待GitHub的master分支，[travis-ci](https://oss.sonatype.org/content/repositories/snapshots/)会构建Glide.如果构建成功，会自动部署最新版本的库到Sonatype上。\n和Glide主库一样，每个Intergration库也有自己的快照，如果你使用快照版本的Glide库，请使用快照版本的Intergration库，反之依然。\n\n### 获取快照\nSonatype的快照库和其他的maven库一样，提供jar，maven，gradle等版本。\n\n#### Jar\nJar包可以直接从Sonatype上下载，再次检查一下日期，确保使用最新版本\n\n#### Gradle\n在仓库列表中添加快照仓库\n\n```xml\nrepositories {\n  jcenter()\n  maven {\n    url 'http://oss.sonatype.org/content/repositories/snapshots'\n  }\n}\n```\n然后修改依赖为快照版本\n\n```xml\ndependencies {\n  compile \"com.github.bumptech.glide:glide:3.6.0-SNAPSHOT\"\n  compile \"com.github.bumptech.glide:okhttp-integration:1.3.0-SNAPSHOT\"\n}\n```\n\n#### Maven\n这种方式没有测试，直接从[StackOverflow](http://stackoverflow.com/questions/7715321/how-to-download-snapshot-version-from-maven-snapshot-repository)拷过来的。欢迎改进下面的内容。\n添加下面的代码到`~/.m2/settings.xml`中：\n\n```xml\n<profiles>\n  <profile>\n     <id>allow-snapshots</id>\n     <activation><activeByDefault>true</activeByDefault></activation>\n     <repositories>\n       <repository>\n         <id>snapshots-repo</id>\n         <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n         <releases><enabled>false</enabled></releases>\n         <snapshots><enabled>true</enabled></snapshots>\n       </repository>\n     </repositories>\n   </profile>\n</profiles>\n```\n修改依赖为快照版本\n\n```xml\n<dependency>\n  <groupId>com.github.bumptech.glide</groupId>\n  <artifactId>glide</artifactId>\n  <version>3.6.0-SNAPSHOT</version>\n</dependency>\n<dependency>\n  <groupId>com.github.bumptech.glide</groupId>\n  <artifactId>okhttp-integration</artifactId>\n  <version>1.3.0-SNAPSHOT</version>\n</dependency>\n```\n\n---------\n\n## 图形变换\n\n### 默认的变换\nGlide包含两种默认的图像变换方式，fitCenter和centerCrop。如果开发者需要其他类型的变换，可以考虑使用这个独立的[变换库](https://github.com/wasabeef/glide-transformations)。\n\n#### Fit center\nFitCenter会按原始比例缩小图像，使图像可以在放在给定的区域内。FitCenter会尽可能少地缩小图片，使宽或者高的一边等于给定的值。另外一边会等于或者小于给定值。\nFitCenter和Android中的ScaleType.FIT_CENTER效果相同。\n#### CenterCrop\nCenterCrop会按原始比例缩小图像，使宽或者高的一边等于给定的值，另外一边会等于或者大于给定值。CenterCrop会裁剪掉多余部分。\nCenterCrop和Android中的ScaleType.CENTER_CROP效果相同。\n\n### 使用\nfit center效果使用`.fitCenter()`：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .fitCenter()\n    .into(yourView);\n```\ncenter crop效果使用`.centerCrop()`：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    . centerCrop()\n    .into(yourView);\n```\n如果你只加载Bitmap或者Gif，也可以使用这个变换：\n\n```java\n// For Bitmaps:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .centerCrop()\n    .into(yourView);\n\n// For gifs:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asGif()\n    .fitCenter()\n    .into(yourView);\n```\n当在类型间转码时，也可以使用这些变换。例如，获取一个变形后的jpeg图片的bytes数据：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .toBytes()\n    .centerCrop()\n    .into(new SimpleTarget<byte[]>(...) { ... });\n\n```\n自定义变换\n除了两个内置的变换，你还可以自定义变换。\n最简单的方式是继承BitmapTransformation。\n\n```java\nprivate static class MyTransformation extends BitmapTransformation { \n \n    public MyTransformation(Context context) {\n       super(context);\n    } \n \n    @Override \n    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, \n            int outWidth, int outHeight) {\n       Bitmap myTransformedBitmap = ... // apply some transformation here. \n       return myTransformedBitmap; \n    } \n \n    @Override \n    public String getId() {\n        // Return some id that uniquely identifies your transformation. \n        return \"com.example.myapp.MyTransformation\"; \n    } \n} \n```\n\n之后一就可以用同样的方式使用它。使用`.transform(...)`代替`.fitCenter()`/`.centerCrop()`。\n\n```java\n// For the default drawable type:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .transform(new MyTransformation(context))\n    .into(yourView);\n\n// For Bitmaps:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .transform(new MyTransformation(context))\n    .into(yourView);\n\n// For Gifs:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asGif()\n    .transform(new MyTransformation(context))\n    .into(yourView);\n```\n\n#### 调整大小\n你可能注意到上面的例子没有传入具体的尺寸，那么，Transformation中的尺寸是如何获得的呢？\nTransformation中的尺寸就是View或者Target的大小。Glide会根据布局文件中的weight，match_parent或者具体值算出View的大小。，当你拥有View/Target的具体大小，又拥有原始图片的大小时，就可以通过图像变换生成一个正确大小的图片。\n如果你想指定View/Target的自定义大小，可以使用`.override(int, int)`方法，如果你想加载一个图片有其他用途，而不是显示在View中，请查看『自定义Target』章节。\n\n#### Bitmap 复用\n为了减少垃圾回收，你可以说使用`BitmapPool`接口来释放不想要的Bitmap或者复用存在的Bitmap。一个在Transformation中复用Bitmap典型的例子：从pool中获取Bitmap，使用该Bitmap创建一个`Canvas`，然后使用Matrix/Paint/Shader来变换图像并绘制到Canvas上。为了正确有效地在Transformation中复用Bitmap中，遵守下面的规则：\n\n1. 在`transform()`不要回收资源或者把Bitmap放入Bitmap池中，这些步骤会自动完成。\n2. 如果你从Bitmap池中获取了多个Bitmap，或者没有使用从pool中获取到的Bitmap，确保把多余的Bitmap放回pool中。\n3. 如果你的Trasformation并没有替换调原始图片（比如，图片已经满足你要求的大小，直接返回了），请在`transform()`方法中返回原始的资源或者Bitmap。\n\n一个典型的用法如下：\n\n```java\nprotected Bitmap transform(BitmapPool bitmapPool, Bitmap original, int width, int height) {\n    Bitmap result = bitmapPool.get(width, height, Bitmap.Config.ARGB_8888);\n    // If no matching Bitmap is in the pool, get will return null, so we should allocate. \n    if (result == null) {\n        // Use ARGB_8888 since we're going to add alpha to the image. \n        result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n    } \n    // Create a Canvas backed by the result Bitmap. \n    Canvas canvas = new Canvas(result);\n    Paint paint = new Paint();\n    paint.setAlpha(128);\n    // Draw the original Bitmap onto the result Bitmap with a transformation. \n    canvas.drawBitmap(original, 0, 0, paint);\n    // Since we've replaced our original Bitmap, we return our new Bitmap here. Glide will \n    // will take care of returning our original Bitmap to the BitmapPool for us.  \n    return result;\n} \n```","source":"_posts/Android图片库-Glide.md","raw":"title: Android图片库--Glide Wiki中文翻译\ndate: 2016-01-24 10:32:54\ndescription: Glide Wiki中文翻译。Glide是一个Android图片库，确切地说应当叫『媒体框架』。支持图片、Gif、原生视频的加载。使用简单，性能优异，Google推荐。\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n## 序\n最近，一直在捣鼓Glide这个图片库，确切地说应当叫『媒体框架』。为了支持Gif播放，项目中使用Glide代替了Universal Image Loader。起初我们打算使用的是Fresco方案，最终因为Lib体积的问题放弃。万万没想到apk的size这么敏感，国外很多推广服务是根据apk体积收费的，3M一个门槛，5M一个门槛。fresco引入之后即使proguard、7zip，apk的大小也增加了1M+，多平台的os库是个大头，第三世界的应用市场还不支持按平台分发😓。。\nGlide的使用还不深入，仅仅停留在Api的范畴，为了解决bug，跟踪了代码，也是云里雾里。不得不说，Glide源码的设计十分NB，面向接口的理念贯彻的很彻底，是一个学习设计的好demo。\nGitHub的README作为最简单的入门足够了，但是遇到具体问题还是要理解一些设计思想的，GitHub上的Wiki有一份不错的文档，可惜木有中文，正好学习的过程中翻译一下。\n在看wiki之前，可以先看这两篇中文入门，了解基本的用法。\n\n* [Google推荐的图片加载库Glide介绍](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html)\n* [Glide 一个专注于平滑滚动的图片加载和缓存库](http://www.jianshu.com/p/4a3177b57949)\n\n本文是基于**Glide 3.x**正式版的[Wiki文档](https://github.com/bumptech/glide/wiki)的翻译（原文编辑日期：2015-2-9,18 revision，当时Glide release的版本号3.6.1）。\n\n翻译Version：1.1 简单校对\n\n### 名词解释\nGlide中有一部分单词，我不知道用什么中文可以确切的表达出含义，用英文单词可能在行文中更加合适，还有一些词在Glide中有特别的含义，我理解的可能也不深入，这里先记录一下。\n\n* View： 一般情况下，指Android中的View及其子类控件（包括自定义的），尤其指ImageView。这些控件可在上面绘制Drawable\n* Target： Glide中重要的概念，目标。它即可以指封装了一个View的Target（ViewTarget），也可以不包含View（SimpleTarget）。\n* Drawable： 指Android中的Drawable类或者它的子类，如BitmapDrawable等。或者Glide中基础Drawable实现的自定义Drawable（如GifDrawable等）\n* Request - 加载请求，可以是网络请求或者其他任何下载图片的请求，也是Glide中的一个类。\n* Model：数据源的提供者，如Url，文件路径等，可以从model中获取InputStream。\n* Signature：签名，可以唯一地标识一个对象。\n* recycle()：Glide中Resource类有此方法，表示该资源不被引用，可以放入池中（此时并没有释放空间）。Android中Bitmap也有此方法，表示释放Bitmap占用的内存。\n\n## 目录\n* 主目录\n* 缓存机制与缓存失效\n* Glide配置\n* 自定义Target\n* 调试与错误处理\n* 使用Glide下载自定义大小图片\n* 集成库-与其他库相整合\n* 在后台线程中加载与缓存数据\n* Glide中的资源复用\n* 快照（Snapshots）\n* 图形变换（Transformations）\n\n---------\n\n## 主目录\n\n### 报告问题\n如果你有任何问题，可以在[Github上提出](https://github.com/bumptech/glide/issues/)或者发送e-mail到我们的[邮件列表](https://groups.google.com/forum/#!forum/glidelibrary)，也可以在IRC(Internet Relay Chat 网络中继聊天？)频道上联系我们：[irc.freenode.net#glide-library](http://webchat.freenode.net/?channels=glide-library)。\n\n### 3.0版本的新特性\n* 支持Gif动画的解码 - 与加载图片相同，只要调用Glide.with(...).load(...)，如果你加载的图片是一个可以播放的Gif，Glide会自动加载它并显示在一个自定义的Drawable上（注：GifDrawable）。此外，你还可以控制的更多，比如\n\n\t```java\n// 你想加载Gif为一张静态图片\nGlide.with(context).load(...).asBitmap()。\n// 或者你想只有加载对象是Gif时才能加载成功\nGlide.with(context).load(...).asGif()。\n```\n\n* 本地视频播放技术 - 除了解码Gif，Glide也能解码你设备上的视频（video）。使用方法和加载gif相同，Glide支持所有Android可以直接解码的视频。\n* 支持缩略图加载 - 有时我们希望减少用户等待的时间又不想牺牲图片的质量，我们可以同时加载多张图片到一个View中，先加载缩略图（只有view的1/10大小），然后再加载一个完整的图像覆盖在上面。使用下面的代码\n\n\t```java\nGlide.with(yourFragment).load(yourUrl).thumbnail(0.1f).into(yourView)\n```\n\n当然，你也可以传入一个Request到`.thumbnail()`函数中作为参数。\n\n* 与生命周期集成 - 加载请求现在会自动在onStop中暂停在，onStart中重新开始。为了节约电量，Gif动画也会在onStop中自动暂停。此外，当设备的连接状态改变时，所有失败的请求会自动重试，确保Glide不会因为临时性的连接问题，导致请求永远失败。\n* 转码 - 除了解码资源，Glide的`.toBytes()`和`.transcode()`方法允许你在后台正常地获取、解码、变换一张图片。你还可以在这些调用中把图片转码成更有用的格式，比如，上传一张大小为250*250像素的用户头像的图片bytes数据，代码如下\n\n\t```java\nGlide.with(context)\n    .load(“/user/profile/photo/path”)\n    .asBitmap()\n    .toBytes()\n    .centerCrop()\n    .into(new SimpleTarget<byte[]>(250, 250) {\n        @Override\n        public void onResourceReady(byte[] data, GlideAnimation anim) {\n            // 在此处，将bytes数据传入后台线程，再上传他们\n        }\n    });\n```\n\n* 动画 - Glide3.X支持『淡入淡出』动画（`.crossFade()`）和view的属性动画(`.animate(ViewPropertyAnimation.Animator)`)。此外，还有Glide2.0就支持的android view动画。\n* 支持 OkHttp 和 Volley - 现在你可以选择用OkHttp、Volley或者默认的HttpUrlConnection作为网络栈。OkHttp和Volley可以通过添加对应的集成库(integration library)和注册相应的`ModelLoaderFactory`来引入。具体查看ReadMe文件。\n* 其他 - 可以使用Drawable对象作为加载中的占位图、请求优先级、覆盖自定义宽和高、可以缓存变换后的缩略图或者缓存原始文件\n\n### 从2.0迁移到3.0\n* 将所有的`Glide.load()`替换为`Glide.with([fragment/activity/context]).load()`。\n* 将所有的自定义的加载调用`Glide.load(url).into(new SimpleTarget(){ ... }).with(context)`替换成`Glide.with(context).load(url).into(new SimpleTarget(width, height) { ... })`。\n\n### 特性\n除了3.0引入的新功能，Glide继承了2.0的所有功能：\n\n* 后台图片加载\n* 如果你使用了listview的复用机制，那么Glide会自动取消作业（job）\n* 内存和磁盘缓存\n* Bitmap和资源池来减少内存抖动\n* 支持任意的图像变换\n\n---------\n\n## 缓存机制与缓存失效\n缓存失效是一个比较复杂的话题，理想情况下，你尽可能不要考虑这个问题。这一节主要是让你粗略的了解一下Glide中cache的key是如何生成，以及提供一些关于如何合理利用缓存的提示。\n### 缓存的key\n`DiskCacheStrategy.RESULT`磁盘缓存策略（注：我们配置的一种磁盘缓存策略）使用的key由以下四个主要部分组成：\n\n* DataFetcher的方法`getId()`返回的字符。典型地，DataFetcher仅仅返回由数据Model的`toString()`方法得到的值。所以，如果Model是一个**URL**，那么会返回URL的字符串，如果Model是是一个文件，那么会返回文件的**路径**。。。\n* 宽和高。如果你调用过override(width,height)方法，那么就是是它传入的值。没有调用过，默认是通过**Target**的`getSize()`方法获得这个值。\n* 各种编码器、解码器的`getId()`方法返回的字符串。这些编码器、解码器用于加载和缓存你的图片。仅有哪些堆bytes数据有影响的编码器、解码器才会有这些`id`值。比如，你只有一个将bytes数据写入磁盘的编码器，那么它就没有id值，因为不管怎样它都不会修改数据。\n* 可选地，你可以为图片加载提供签名(Signature)，请看下面的缓存失效部分。\n\n所有的这些key，以特定的顺序计算出hash值，并将这个值作为保存图片到磁盘上的唯一且安全的文件名。\n\n### 缓存失效\n由于文件名是hash值，没有简便的方式删除磁盘上某个特定url或者文件路径的所有缓存文件。如果仅仅缓存原文件，问题可能还比较简单，但是Glide会缓存缩略图，各种变换后的图片，所有这些缓存都会产生新文件。跟踪和删除所有文件是十分困难的。\n\n### 自定义缓存失效\n通常情况下改变缓存的标志（key）是困难的。Glide提供了`signature()`API来混入其他数据，帮助你控制缓存的key。签名（Signature）对于多媒体或者有版本信息的内容来说都很有用。\n\n* 媒体库内容 - 对于媒体库内容，你可以使用Glide的`MediaStoreSignature`类作为签名， MediaStoreSignature类允许你混入文件修改时间、mime类型、媒体库的方向(orientation?)这些值作为缓存的key，这三个值足以让你可靠的捕捉到任何修改和更新，使你可以缓存媒体库的缩略图.?\n* 文件 - 你可以使用`StringSignature`混入文件修改时间\n* url - 虽然使url失效最好的方式是当内容变化时，服务器修改url并更新客户端，但是你也可以用`StringSignature`混入任意的元数据（如版本号）来使缓存失效。\n\n使用String Signature加载数据很简单：\n\n```java\nGlide.with(yourFragment)\n    .load(yourFileDataModel)\n    .signature(new StringSignature(yourVersionMetadata))\n    .into(yourImageView);\n```\n\n媒体库Signature可以直接使用从MeidaStore(注：一个android api）获得的数据\n\n```java\nGlide.with(fragment)\n    .load(mediaStoreUri)\n    .signature(new MediaStoreSignature(mimeType, dateModified, orientation))\n    .into(view);\n```\n\n你还可以通过实现`key`接口来自定义签名，确保实现了`equals()`, `hashCode()`和`updateDiskCacheKey()`这几个方法\n\n```java\npublic class IntegerVersionSignature implements Key {\n    private int currentVersion;\n \n    public IntegerVersionSignature(int currentVersion) {\n         this.currentVersion = currentVersion;\n    } \n \n    @Override \n    public boolean equals(Object o) {\n        if (o instanceof IntegerVersionSignature) {\n            IntegerVersionSignature other = (IntegerVersionSignature) o;\n            return currentVersion = other.currentVersion;\n        } \n        return false; \n    } \n \n    @Override \n    public int hashCode() { \n        return currentVersion;\n    } \n \n    @Override \n    public void updateDiskCacheKey(MessageDigest md) {\n        messageDigest.update(ByteBuffer.allocate(Integer.SIZE).putInt(signature).array());\n    } \n} \n```\n请牢记：为了避免性能下降，请在后台线程中批量加载版本元数据(metaData，注：一般查询数据库获得)，只有这样，才能确保当你想加载图片的时候，这些值是可用的。\n\n如果这些方法都失败了，比如，你不能改变标识符，也不能跟踪一个合理的版本号。你还可以使用`diskCacheStrategy()`和`DiskCacheStrategy.NONE.`来完全关闭磁盘缓存。\n\n---------\n\n## 配置\n\n### 懒加载配置\n从Glide3.5开始，你可以使用`GlideModule`接口来懒加载配置Glide以及注册组件（如`ModelLoaders`)，这些配置将会在第一个Glide请求发起的时候被调用。\n\n### 创建一个GlideModule\n为了使用和注册GlideModule，首先需要实现该接口，加入你的配置和组件。\n\n```java\npackage com.mypackage; \n \npublic class MyGlideModule implements GlideModule { \n    @Override public void applyOptions(Context context, GlideBuilder builder) {\n        // Apply options to the builder here. \n    } \n \n    @Override public void registerComponents(Context context, Glide glide) {\n        // register ModelLoaders here. \n    } \n} \n```\n\n然后，添加你的实现类到`proguard.cfg`文件中，让你的module可以被反射调用到。这个性能开支很少，因为每个module只会在Glide第一次请求的时候实例化一次。\n\n```xml\n-keepnames class com.mypackage.MyGlideModule\n# or more generally:\n#-keep public class * implements com.bumptech.glide.module.GlideModule\n```\n\n最后，添加meta-data标记到`AndroidManifest.xml`，那样Glide才能找到它。\n\n```xml\n<manifest ...>\n    <!-- ... permissions -->\n    <application ...>\n        <meta-data\n            android:name=\"com.mypackage.MyGlideModule\"\n            android:value=\"GlideModule\" />\n        <!-- ... activities and other components -->\n    </application>\n</manifest>\n```\n\n你可以实现任意个`GlideModule`，但是每一个都要添加到`proguard.cfg`，而且每一个GlideModule都要在manifest有自己的meta-data标记。\n\n### Library工程\nLibrary工程可能含有一个或多个`GlideModule`。当我们使用Gradle（或者任何支持manifest合并的构建工具）构建app时，如果我们所依赖的Library工程的manifest中含有module，那么这些module会自动并入到app中。如果构建工具不支持manifest合并，那么这些library工程中的module必须手动添加到你app的manifest中。\n\n### GlideModule冲突\n虽然Glide允许每个app注册多个`Glidemodule`，但是不会以某种特定的顺序调用这些module。所以，如果你的app中多个`GlideModules`或者依赖的library工程中有多个`GlideModules`，你必须负责避免他们之间的冲突。\n如果冲突不可避免，app应该定义自己的默认module，这个module需要手动解决这些冲突，提供所有Library工程所需要的依赖。使用Gradle的开发者，或者使用manifest合并的开发者，可以通过下面的标签来排除冲突的module。\n\n```xml\n<meta-data android:name=”com.mypackage.MyGlideModule” tools:node=”remove” />\n```\n\n### 全局配置\n你可以配置一些作用于所有请求的全局性配置项。请使用`GlideModule#applyOptions`方法中（注：作为参数）提供给你的`GlideBuilder`来配置。本节代码示例中的`builder`就是一个GlideModule对象。\n\n### 磁盘缓存\n你可以使用`GlideBuilder`的`setDiskCache()`方法设置磁盘缓存的位置、大小（最大值）。你也可以使用`DiskCacheAdapter`彻底关闭缓存，或者自己实现`DiskCache`接口来换掉默认实现。磁盘缓存由`DiskCache.Factory`接口的实例在后台线程中创建，使用后台线程可以避免在严格模式中出现问题。\nGlide默认使用`InternalCacheDiskCacheFactory`类建立磁盘缓存。这个内部缓存工厂（internal cache factory）会把磁盘缓存放到应用程序的内部缓存目录中，并且设置最大空间是250MB，使用内部缓存的目录而不是SD卡的外部目录意味着其他应用程序无法访问到你下载的图片。具体请查看Android的[存储选项相关文档](http://developer.android.com/intl/zh-cn/guide/topics/data/data-storage.html#filesInternal)。\n\n#### 大小\n使用`InternalCacheDiskCacheFactory`设置磁盘缓存大小\n\n```java\nbuilder.setDiskCache(\n  new InternalCacheDiskCacheFactory(context, yourSizeInBytes));\n```\n\n#### 位置\n也可以设置磁盘缓存位置\n你可以使用`InternalCacheDiskCacheFactory `来把你的磁盘缓存放到应用程序私有的内部存储目录中：\n\n```java\nbuilder.setDiskCache(\n  new InternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));\n```\n还可以用`ExternalCacheDiskCacheFactory `来把你的磁盘缓存放到sd卡的公共缓存目录上。\n\n```java\nbuilder.setDiskCache(\n  new ExternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));\n```\n如果你想用其他自定义的路径，可以用`DiskLruCacheFactory`类的构造函数来实现。\n\n```java\n// If you can figure out the folder without I/O: \n// Calling Context and Environment class methods usually do I/O. \nbuilder.setDiskCache( \n  new DiskLruCacheFactory(getMyCacheLocationWithoutIO(), yourSizeInBytes)); \n \n// In case you want to specify a cache folder (\"glide\"): \nbuilder.setDiskCache( \n  new DiskLruCacheFactory(getMyCacheLocationWithoutIO(), \"glide\", yourSizeInBytes)); \n \n// In case you need to query the file system while determining the folder: \nbuilder.setDiskCache(new DiskLruCacheFactory(new CacheDirectoryGetter() { \n    @Override public File getCacheDirectory() {\n        return getMyCacheLocationBlockingIO(); \n    } \n}), yourSizeInBytes); \n```\n注意：请牢记，写死任何值都不是个好主意，尤其是目录的路径，因为自Android4.2开始，支持单设备多用户。\n\n如果你想完全控制缓存的创建，可以自己实现`DiskCache.Factory `接口，使用`DiskLruCacheWrapper`可以在你想要的位置创建一个新的缓存。\n\n```java\nbuilder.setDiskCache(new DiskCache.Factory() { \n    @Override public DiskCache build() { \n        File cacheLocation = getMyCacheLocationBlockingIO();\n        cacheLocation.mkdirs();\n        return DiskLruCacheWrapper.get(cacheLocation, yourSizeInBytes);\n    } \n}); \n```\n\n### 内存缓存和缓存池\n`GlideBuilder`类允许你设置内存缓存大小，而且可以实现自定义的`MemoryCache`和`BitmapPool`。\n\n#### 大小\n默认大小是由`MemorySizeCalculator`类决定的。MemorySizeCalculator类会考虑该设备的屏幕大小、可用内存来计算出一个合理的默认值。如果你想调整这个默认值，请构建自己的实例。\n\n```java\nMemorySizeCalculator calculator = new MemorySizeCalculator(context);\nint defaultMemoryCacheSize = calculator.getMemoryCacheSize();\nint defaultBitmapPoolSize = calculator.getBitmapPoolSize();\n```\n如果你想在应用的某个阶段动态调整Glide的内存占用，你可以选择一个`MemoryCategory`并使用`setMemoryCategory()`方法传入Glide中：\n\n```java\nGlide.get(context).setMemoryCategory(MemoryCategory.HIGH);\n```\n\n#### 内存缓存\nGlide的内存缓存会在内存中持有资源，它的作用是，我们可以不进行IO操作而快速获得可用资源。\n你可以使用`GlideBuilder`的`setMemoryCache()`方法设置大小，或者设置你关于内存缓存的自定义实现（自定义类）。`LruResourceCache`类是Glide的默认实现。你可以通过`LruResourceCache`的构造函数来配置内存占用的bytes的最大值。\n\n```java\nbuilder.setMemoryCache(new LruResourceCache(yourSizeInBytes));\n```\n\n#### Bitmap池\nGlide的Bitmap池主要作用是，可以让各种尺寸的Bitmap被复用，可以可观地减少由垃圾回收引起的内存抖动。在解码图片时，需要给像素数组分配空间，这会触发垃圾回收。\n你可以使用`GlideBuilder`的`setBitmapPool()`方法设置大小，或者设置你关于Bitmap池的自定义实现，`LruBitmapPool`类是Glide的默认实现。LruBitmapPool类使用了LRU算法维护最近最常使用的Bitmap的尺寸。你可以通过`LruBitmapPool`的构造函数配置内存占用的bytes的最大值。\n\n```java\nbuilder.setBitmapPool(new LruBitmapPool(sizeInBytes));\n```\n\n### Bitmap格式\n`GlideBuilder` 类也允许你配置一个App全局使用的Bitmap的Config属性。\nGlide默认使用RGB_565，因为它每个像素只需要2bytes（16bit）的空间，它仅需要高质量图片（既系统默认的`ARGB_8888 `）一半的内存空间。但是，这对于某些图片这可能会出现『条带』的问题，而且它也不支持透明度。\n如果在你的应用中『条带』是一个重要的问题，或者你需要尽可能好的图片质量，你可以使用`GlideBuilder`的`setDecodeFormat`方法设置DecodeFormat.ALWAYS_ARGB_8888作为首选配置。\n\n```java\nbuilder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);\n```\n\n---------\n\n## 自定义目标（Targets）\n除了可以加载图像，视频剧照，gif动画到View中，你还可以加载他们到实现了Target接口的自定义目标中。\n\n### SimpleTarget\n如果你只是想加载一个Bitmap，并不想直接展示给用户而是有一些特殊用途，比如在通知栏中显示或者作为头像上传。\nGlide也可以做到。\nSimpleTarget为Target接口提供了大部分的默认实现。你可以专注于处理加载的结果。\n为了使用SimpleTarget，你需要在它的构造函数中提供你要加载的资源的宽和高（单位像素），你还需要实现` onResourceReady(T resource, GlideAnimation animation)`方法。\n一个典型的使用SimpleTarget的例子如下：\n\n```java\nint myWidth = 512;\nint myHeight = 384;\n \nGlide.with(yourApplicationContext)) \n    .load(youUrl) \n    .asBitmap() \n    .into(new SimpleTarget<Bitmap>(myWidth, myHeight) {\n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            // Do something with bitmap here. \n        } \n    }; \n```\n\n#### 一些警告\n正常情况下，你加载一个资源会把他们放到view中。当你的Activity或者Fragment被pause或者destroy时，Glide会暂停或取消加载，确保你不会加载那些根本不会显示的资源。\n可是当我们使用SimpleTarget的时候，这可能并不是我们希望的行为。所以，当你调用`Glide.with(context)`的时候，你可以传入Application的context，而不是传入Activity或者Fragment。\n此外，考虑到长时间的加载操作可能导致内存泄漏，请考虑使用静态内部类，而不是匿名内部类。\n\n### ViewTarget\n如果你想加载一个图片到View中，但是你想观察或者覆盖Glide的默认行为。你可以覆盖ViewTarget或者它的子类。\n当你想让Glide来获取view的的大小，但是由自己来启动动画和设置资源到view中，ViewTarget是个不错的选择。如果你要加载一个图片到ImageView之外的自定义view中，那么ImageViewTarget或者它的子类就不能满足你的要求，此时继承ViewTarget就特别合适。\n你可以静态的定义一个ViewTarget的子类，或者传递一个匿名内部类到你的加载调用里：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .into(new ViewTarget<YourViewClass, GlideDrawable>(yourViewObject) {\n        @Override\n        public void onResourceReady(GlideDrawable resource, GlideAnimation anim) {\n            YourViewClass myView = this.view;\n            // Set your resource on myView and/or start your animation here.\n        }\n    });\n```\n注意，如果你想指定加载Bitmap还是GifDrawable，请在`.load(yourUrl)`调用后面直接添加`.asBitmap()`或者`.asGif()`，同时将ViewTarget的类型参数`GlideDrawable`换成对应加载的类型。\n为了更多控制，你也可以在Target实现`LifecycleListener`回调，`onStart()`、`onStop()`或者`onDestroy()`会和你view所在的fragment的生命周期保持同步。\n\n### 覆盖默认行为\n如果你只想观察不想修改Glide的默认行为，你可以继承任何一个Glide对ImageViewTargets的默认实现。\n\n* GlideDrawableImageViewTarget - 默认的Target，用于正常的加载和`asGif()`。\n* BitmapImageViewTarget - 当使用`asBitmap()`加载时，使用的默认Target。\n\n只有你在每个方法里面调用`super()`，将会保留默认的行为，同时还可以添加一些你希望的功能。\n\n例如，想要生成一个[调色板](http://chris.banes.me/2014/07/04/palette-preview/)，你可以这样做。\n\n```java\nGlide.with(yourFragment) \n    .load(yourUrl) \n    .asBitmap() \n    .into(new BitmapImageViewTarget(yourImageView)) { \n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            super.onResourceReady(bitmap, anim);\n            Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() {  \n                @Override \n                public void onGenerated(Palette palette) {\n                    // Here's your generated palette \n                } \n            }); \n        } \n    }); \n```\n虽然这个例子还不错，但是，通常情况下，我不推荐用这个方式生成调色板。请查看Glide的 `ResourceTranscoder` 接口和`.transcode()`方法，考虑返回一个包含Bitmap和调色板的自定义资源。调色板可在在后台线程生成。？？？？？更多内容会在以后推出。。。\n\n---------\n\n## 调试和错误处理\nGlide在加载过程中出现异常默认情况下不会打日志。Glide为你提供了两种方式查看和处理这些异常。\n\n### 调试\n仅仅为了查看异常的话，你可以为`GenericRequest`类打开Debug日志。这个类处理所有媒体资源的加载响应（response）。你可以在命令行里运行：\n\n```xml\nadb shell setprop log.tag.GenericRequest DEBUG\n```\n想要包括详细的请求时序信息，你可以把`DEBUG`缓存`VERBOSE`。\n\n关闭日志使用：\n\n```xml\nadb shell setprop log.tag.GenericRequest ERROR\n```\n\n### 调试[工作流](https://docs.google.com/drawings/d/1KyOJkNd5Dlm8_awZpftzW7KtqgNR6GURvuF6RfB210g/edit)\n为了查看内部引擎（engine）如何以及何时查找到资源，你可以打开日志：\n\n```xml\nadb shell setprop log.tag.Engine VERBOSE\nadb shell setprop log.tag.EngineJob VERBOSE\nadb shell setprop log.tag.DecodeJob VERBOSE\n```\n打开这个有助于你找出为什么某个资源没有从内存缓存中加载，为什么请求再次从外部的url下载数据。这也可以帮助你了解：如果想命中磁盘缓存，什么样的参数需要匹配。启用`DecodeJob`日志也可以帮助你去定位自定义transformation/decoder/encoder相关的问题。\n\n### 监听请求-RequestListener\n虽然启用debug日志很简单，但是只有在你可以连接到设备时才能这样干。为了把Glide集成到已有的更专业的错误日志系统。你可以使用`RequestListener`类的`onException()`。当请求失败时，该方法会告知你导致失败的`异常`(Exception)，如果解码器（Decoder）不能从数据中解析出任何有用的信息，Exception也可能传`null`。你可以使用`listener()`API传一个你的监听器（listener）到每一个请求中。\n请确保`onException()`返回`false`，以免覆盖了Glide的默认错误处理行为（例如，它默认会通知`Target`这个error）。\n这是一个快速调试的例子：\n\n```java\n// example usage: .listener(new LoggingListener<String, GlideDrawable>()) \npublic class LoggingListener<T, R> implements RequestListener<T, R> {\n    @Override public boolean onException(Exception e, Object model, Target target, boolean isFirstResource) {\n        android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT,\n                \"onException(%s, %s, %s, %s)\", e, model, target, isFirstResource), e);\n        return false; \n    } \n    @Override public boolean onResourceReady(Object resource, Object model, Target target, boolean isFromMemoryCache, boolean isFirstResource) {\n        android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT,\n                \"onResourceReady(%s, %s, %s, %s, %s)\", resource, model, target, isFromMemoryCache, isFirstResource));\n        return false; \n    } \n} \n```\n**确保发版前移除相关代码**\n\n### 更多日志\n这个列表是给3.6.0版本用的，可能不完整。\n\n```xml\ncd .../android-sdk/platform-tools\nadb shell setprop log.tag.AnimatedGifEncoder VERBOSE\nadb shell setprop log.tag.AssetUriFetcher VERBOSE\nadb shell setprop log.tag.BitmapEncoder VERBOSE\nadb shell setprop log.tag.BufferedIs VERBOSE\nadb shell setprop log.tag.ByteArrayPool VERBOSE\nadb shell setprop log.tag.CacheLoader VERBOSE\nadb shell setprop log.tag.ContentLengthStream VERBOSE\nadb shell setprop log.tag.DecodeJob VERBOSE\nadb shell setprop log.tag.DiskLruCacheWrapper VERBOSE\nadb shell setprop log.tag.Downsampler VERBOSE\nadb shell setprop log.tag.Engine VERBOSE\nadb shell setprop log.tag.EngineRunnable VERBOSE\nadb shell setprop log.tag.GenericRequest VERBOSE\nadb shell setprop log.tag.GifDecoder VERBOSE\nadb shell setprop log.tag.GifEncoder VERBOSE\nadb shell setprop log.tag.GifHeaderParser VERBOSE\nadb shell setprop log.tag.GifResourceDecoder VERBOSE\nadb shell setprop log.tag.Glide VERBOSE\nadb shell setprop log.tag.ImageHeaderParser VERBOSE\nadb shell setprop log.tag.ImageVideoDecoder VERBOSE\nadb shell setprop log.tag.IVML VERBOSE\nadb shell setprop log.tag.LocalUriFetcher VERBOSE\nadb shell setprop log.tag.LruBitmapPool VERBOSE\nadb shell setprop log.tag.MediaStoreThumbFetcher VERBOSE\nadb shell setprop log.tag.MemorySizeCalculator VERBOSE\nadb shell setprop log.tag.PreFillRunner VERBOSE\nadb shell setprop log.tag.ResourceLoader VERBOSE\nadb shell setprop log.tag.RMRetriever VERBOSE\nadb shell setprop log.tag.StreamEncoder VERBOSE\nadb shell setprop log.tag.TransformationUtils VERBOSE\n```\n\n---------\n\n## 使用Glide下载自定义大小的图片\n开发者可以通过Glide的ModelLoader接口获得图片大小，并根据这个大小来加载一个合适尺寸的图片url。\n使用合适尺寸的图片可以节约带宽，设备的存储空间，还可以提升app性能。\n2014年的Google I/O app团队写了一篇关于如何使用ModelLoader接口调整加载的图片大小的文章。请在GitHub上查看 [I/O app的源码](https://github.com/google/iosched/blob/master/doc/IMAGES.md)。\n为了实现自定义的ModelLoader来通过http/https下载图片，可以继承BaseGlideUrlLoader这个类\n\n```java\npublic interface MyDataModel { \n    public String buildUrl(int width, int height);\n}  \n \npublic class MyUrlLoader extends BaseGlideUrlLoader<MyDataModel> { \n    @Override \n    protected String getUrl(MyDataModel model, int width, int height) {\n        // Construct the url for the correct size here. \n        return model.buildUrl(width, height);\n    } \n} \n```\n\n然后，你就可以使用自定义的ModelLoader来加载图片了，其他的事情会自动完成：\n\n```java\nGlide.with(yourFragment)\n    .using(new MyUrlLoader())\n    .load(yourModel)\n    .into(yourView);\n```\n\n如果你想避免调用`.using(new  MyUrlLoader())`，你可以实现一个自定义的`ModelLoaderFactory`，并在`GlideModule`中注册它。\n\n```java\npublic class MyGlideModule implements GlideModule { \n    ... \n    @Override \n    public void registerComponents(Context context, Glide glide) {\n        glide.register(MyDataModel.class, InputStream.class, \n            new MyUrlLoader.Factory()); \n    } \n} \n```\n\n注册ModelLoaderFactory之后，你就不用调用`.using()`了：\n\n```java\nGlide.with(yourFragment)\n    .load(yourModel)\n    .into(yourView);\n```\n\n其他的例子，关于如何使用自定义ModelLoader加载各种尺寸的图片，请查看[Flicker示例应用](https://github.com/bumptech/glide/blob/master/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java)，和[Giphy示例应用](https://github.com/bumptech/glide/blob/master/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java)。\n\n---------\n\n## 集成（Integration）库-Glide与其他库整合\n\n### 介绍\n\n####什么是集成库（Integration Library）\nGlide包括一系列小巧可配置的集成库，这些库可以让Glide与外部的库相结合。现在集成库可以使Glide支持Volley和OkHttp的http/https请求。\n\n我们坚信，您所选择的客户端媒体库既不应该决定你在你的应用程序中使用的网络库，也不需要你仅仅为了加载图像额外添加网络库。集成库和Glide的ModelLoader系统，允许开发人员对所有网络请求使用统一的网络库。\n\n#### 为什么没有XXX库的实现\n因为我们还没有为这个库写集成库。OkHttp和Volley是十分流行的库，许多开发者都使用，但是，我们不是排斥其他库，如果你写了其他库的`ModelLoader`并且打算开源，我们很乐意看到这样的提交请求（pull request）。\n\n#### 我如何依赖一个集成库呢？\n依赖任何的集成库需要两g个步骤。\n\n1. 添加相应的继承库的Maven/Gradle/jar依赖，因为作为可选项的集成库并不包含在glide的jar依赖中。\n2. 确保app包含了集成库的GlideModule，具体内容看[配置wiki](https://github.com/bumptech/glide/wiki/Configuration)部分。对于Glide集成库的具体说明见下面。\n\n#### 我应当选择哪个版本？\n集成库的版本跟随着Glide的release版本。但是多了一个不同的数字。确保选择与所依赖的Glide对应的集成库。在[release页](https://github.com/bumptech/glide/releases)查看.\n网络库有自己的版本号。继承库会依赖的库就是你在Maven/Gradle中指定的库。你可以通过版本号来指定具体依赖的网络库。？？\n\n### Volley\nVolley是一个Http库，可以使Android上的网络请求更简单，更快速。\n\n#### Gradle中使用Volley\n\n```java\ndependencies {\n    compile 'com.github.bumptech.glide:volley-integration:1.3.1@aar'\n    //compile 'com.mcxiaoke.volley:library:1.0.8'\n}\n```\n集成库的`GlideModule`会自动合并到你app的manifest中。\n\n#### Maven中是Volley\n\n```xml\n<dependency>\n    <groupId>com.github.bumptech.glide</groupId>\n    <artifactId>volley-integration</artifactId>\n    <version>1.3.1</version>\n    <type>aar</type>\n</dependency>\n<dependency>\n    <groupId>com.mcxiaoke.volley</groupId>\n    <artifactId>library</artifactId>\n    <version>1.0.8</version>\n    <type>aar</type>\n</dependency>\n\n```\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### 手动添加Volley\n从[release页](https://github.com/bumptech/glide/releases)下载[glide-volley-integration-<version>.jar ](https://github.com/bumptech/glide/releases/download/v3.6.1/glide-volley-integration-1.3.1.jar)。并添加到你app的编译路径中(compile classpath)。\n\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### Volley的Manifest\n如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加`GlideModule`的metadata标签到`AndroidManifest.xml`中。\n\n```xml\n<meta-data\n    android:name=\"com.bumptech.glide.integration.volley.VolleyGlideModule\"\n    android:value=\"GlideModule\" />\n```\n\n#### Volley的混淆设置\n无论使用什么编译系统，不要混淆`VolleyGlideModule`类，它需要被反射来实例化。添加下面的代码到`proguard.cfg`文件（或者查看“通用部分”）。\n\n```java\n-keep class com.bumptech.glide.integration.volley.VolleyGlideModule\n```\n\n### OkHttp\nOKHttp是一个高效且易于使用的Http客户端。\n\n#### Gradle中使用OkHttp\n\n```java\ndependencies {\n    compile 'com.github.bumptech.glide:okhttp-integration:1.3.1@aar'\n    //compile 'com.squareup.okhttp:okhttp:2.2.0'\n}\n```\n集成库的`GlideModule`会自动合并到你app的manifest中。\n\n#### Maven中是OkHttp\n\n```xml\n<dependency>\n    <groupId>com.github.bumptech.glide</groupId>\n    <artifactId>okhttp-integration</artifactId>\n    <version>1.3.1</version>\n    <type>aar</type>\n</dependency>\n<!--\n<dependency>\n    <groupId>com.squareup.okhttp</groupId>\n    <artifactId>okhttp</artifactId>\n    <version>2.2.0</version>\n    <type>jar</type>\n</dependency>\n-->\n\n```\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### 手动添加OkHttp\n从[release页](https://github.com/bumptech/glide/releases)下载[glide-okhttp-integration-<version>.jar ](https://github.com/bumptech/glide/releases/download/v3.6.1/glide-okhttp-integration-1.3.1.jar)。并添加到你app的编译路径中(compile classpath)。\n\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### OkHttp的Manifest\n如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加`GlideModule`的metadata标签到`AndroidManifest.xml`中。\n\n```xml\n<meta-data\n    android:name=\"com.bumptech.glide.integration.okhttp.OkHttpGlideModule\"\n    android:value=\"GlideModule\" />\n```\n\n#### OkHttp的混淆设置\n无论使用什么编译系统，不要混淆`OkHttpGlideModule`类，它需要被反射来实例化。添加下面的代码到`proguard.cfg`文件（或者查看“通用部分”）。\n\n```java\n-keep class com.bumptech.glide.integration.okhttp.OkHttpGlideModule\n```\n\n### 更多选项\n\n#### 通用的混淆配置\n你也可以使用下面的配置来避免混淆所有的`GlideModule`。\n\n```java\n-keep public class * implements com.bumptech.glide.module.GlideModule\n```\n这种方式有其他的好处，当修改集成库或者自定义集成库的行为时，不需要修改。当你添加或者移动其他module的时候，也不需要修改什么。\n\n#### 覆盖默认的行为\n如果默认配置无法满足你，所有的集成库还有一些额外的选项。比如添加重试行为，请查看集成库的`GlideModule`的源码（位于[/integration/<lib>/src/main/java/<package>](https://github.com/bumptech/glide/tree/3.0/integration)）了解默认的注册做了些什么。你可以通过在自定义的`GlideModule`中修改参数为`UrlLoader.Factory`类来改变默认行为。\n当你要覆盖默认行为时，请确保自定义的`GlideModule`被注册，且默认的GlideModule被排除在外。排除GlideModule可能是从manifest中移除相应的的metadata，或者使用jar包依赖代替aar依赖。关于`GlideModule`的更多信息请查看[配置的wiki页](https://github.com/bumptech/glide/wiki/Configuration)\\\n\n---------\n\n## 在后台线程中加载和缓存\n为了使后台加载资源和与媒体交互更加容易，除了`Glide.with(fragment).load(url).into(view)`这个API外，Glide还提供了额外两个API。\n\n* `downloadOnly(int, int)`\n* `into(int, int)`\n\n### downloadOnly方法\nGlide的`downloadOnly(int, int)`方法允许你把图片bytes下载到磁盘缓存中，以便以后获取使用。你可以在UI线程异步地调用`downloadOnly()`，也可以在后台线程同步的使用。但是，注意他们的参数有些不同，异步API的参数是`Target`，同步api的参数是宽和高的整数值。\t\n为了在后台线程下载图片，你必须使用同步方法\n\n```java\nFutureTarget<File> future = Glide.with(applicationContext)\n    .load(yourUrl)\n    .downloadOnly(500, 500);\nFile cacheFile = future.get();\n```\n当future返回时，图片的bytes数据就在缓存中可用了。一种典型的情况是，你使用`downloadOnly()`API只是为了确保数据下载到了磁盘上。一般情况下，虽然你有权访问底层的缓存文件，但是你不需要直接和它交互。\n而是，当你想要获取这个图片时，你只要像平常加载图片时那样调用就行，**只有一点不同**：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .diskCacheStrategy(DiskCacheStrategy.ALL)\n    .into(yourView);\n```\n通过传入 `DiskCacheStrategy.ALL`或者`DiskCacheStrategy.SOURCE`，确保Glide可以使用你通过`downloadOnly()`下载的数据。\n\n### into方法\n如果你想在一个**后台线程**与一张已经解码的图片交互。你可以使用这个版本的`into()`方法来返回一个`FutureTarget`。例如，获取一张中心剪裁后的500*500像素的图片：\n\n```java\nBitmap myBitmap = Glide.with(applicationContext)\n    .load(yourUrl)\n    .asBitmap()\n    .centerCrop()\n    .into(500, 500)\n    .get()\n```\n虽然`into(int, int)`方法在后台线程中很有效，但是，你不能把它用在主线程中。即使这个同步方法在你的主线程中不会抛出异常，调用get()也会阻塞主线程。会使你的APP性能变差，反应迟钝。\n\n---------\n\n## Glide中的资源复用\n\n### 为什么 - 资源复用的作用\nGlide通过复用资源避免不必要的内存分配。Dalvik虚拟机（在Lollipop之前）有两种基本的垃圾回收方式，`GC_CONCURRENT` 和`GC_FOR_ALLOC`。每次`GC_CONCURRENT`会阻塞主线程5ms。由于每次操作的时间少于16ms（1帧的时间），`GC_CONCURRENT`并不会引起掉帧。相反的是`GC_FOR_ALLOC`，他会停止所有操作，阻塞主线程125+ms，事实上，GC_FOR_ALLOC总是会让你的app掉很多帧。尤其是在滑动时，导致明显的卡顿。\n很不幸，即使只是分配适当的空间（比如16kb的buffer）Dalvik表现的也很糟糕。不断的小内存分配，或者一次大的内存分配（比如说bitmap），将会引起GC_FOR_ALLOC。因此，你分配内存的越多，你会遇到垃圾回收器阻塞应用的情况就越多，应用掉帧就越严重。\n通过适度复用大块资源，Glide可以避免内存抖动，减少垃圾回收器阻塞app的次数。\n\n### 怎么做 - Glide是如何复用资源\nGlide的资源复用策略比较宽松。这意味着，当Glide认为该资源可以被安全的复用时，才有几率去复用它，并不需要开发者在每个request后面去手动释放资源。\n\n#### 标志-哪些资源可复用\nGlide有两个简单的标志来识别可复用的资源。\n\n1. `Glide.clear()` \n\n\t在`View`或者`Target`上调用`clear()`方法都表示，Glide要取消加载，可以安全地把Target占用的所有资源（Bitmap，bytes数组等）放入资源池中（pool）。用户可以在任何时候安全地手动调用`clear()`方法，但是典型情况下，我们不需要这样做，看第二条。\n\n2. View或者Target的复用 \n\n\t当用户把图片加载到一个已经存在的View或者Target上时（注：确切的说是调用`into(xxx)`方法之后），Glide会先调用`clear()`清空该View/Target上的加载请求并复用已经显示过的资源。因此，如果你的ListView或者RecyclerView中的view使用了复用机制（注：如ViewHolder），那么Glide会自动为他们缓存资源和管理加载请求。\n \n#### 引用计数\n如果两个请求指向同一个资源，为了避免额外的工作，Glide会把单个资源分配给他们。这就导致一个问题，当Glide得知某个资源不被某个调用者使用，这并不表示它不会被其他调用者使用。为了避免回收调依旧被使用的资源，Glide使用引用计数来跟踪资源。\n当把资源提供给View/Target时，该资源的引用计数加1，当清空View/Target时，引用计数减1。当引用计数为0时，Glide会回收资源，并把它的内容放回可用内存池中。\n\n#### 放入缓存池\nGlide的Resource API有一个`recycle()`方法，当Glide认为资源不再被引用时，会调用该方法，资源会放入缓存池中。\n\nGlide提供的BitmapPool接口可以让Resource获取`Bitmap`和复用Bitmap对象。Glide的BitmapPool可以通过Glide单例获得：\n\n```java\nGlide.get(context).getBitmapPool();\n```\nResourceDecoder可以返回Resource的任何实现。所有，开发者可以实现他们自己的Resource和ResourceDecoder来自定义地缓存一些特有类型的数据。\n同样地，开发者如果想更多地控制Bitmap缓存，可以实现自己的BitmapPool，然后通过GlideModule配置到Glide中。\n\n### 常见的错误\n不幸的是，缓存池设计使我们很难判断开发者是否误用了资源或者bitmap。但是，在Glide中有两个主要的现象会暗示你某些地方可能出了问题。\n\n#### 现象\n\n1. `Cannot draw a recycled Bitmap`\n\n\tGlide有个固定大小的Bitmap池。当Bitmap不再被复用（注：不是使用，区分使用和复用），会从池中移走。Glide会调用[`recycle()`](http://developer.android.com/reference/android/graphics/Bitmap.html#recycle())（注：指的是Bitmap真正的recycle，不是Resource类的recycle）。你告诉Glide放心地回收某个Bitmap，但是，你的应用不小心还持有这个Bitmap的引用，应用程序可能会绘制这个Bitmap，导致崩溃。\n\n2. View在多张图片之间闪烁，或者同样的图片出现在多个View中\n\n\t如果一张图片被放入BitmapPool中多次。或者虽然一张图片被放入了pool中，但是某个View依然持有这个图的引用，与此同时，另一张图片被解析成了Bitmap（注：此Bitmap正好用了刚才那张图片的控件来存放解析后的数据）。如果发生这种事情，Bitmap的内容就会被换成了新的图片内容。此时，View依然尝试着绘制Bitmap，导致原来的View中显示了一张新的图片！\n\n#### 原因\n这些问题主要有两个原因：\n\n1. 尝试加载两个不同的资源到同一Target中\n\n\t在Glide中，没有安全的方法来加载多个资源到单一的Target中。开发者可以使用`thumbnail()`来加载一系列资源到到某个Target中，但是对于每一个加载的资源来说，只有在下一个`onResourceReady()`被调用前，它的引用才是安全的。\n开发者如果想加载多个资源到同一个View中，可以使用两个独立的Target。为了确保加载过程不相互取消，开发者要么不使用ViewTarget的子类，要么在继承ViewTarget时，复写`setRequest()` 和 `getRequest()`，不要使用tag来存储Request。（注：需要一个demo)\n\n\t**译者注：对于同一个view，调用两次Glide.xxx.into(view)，第二次调用会先清空第一个加载的图片（出现空白），再去下载新的图片，如果想要在第二张图片下载下来之前依旧显示之前的，需要一些技巧**\n2. 加载一个资源放入到Target，然后清空或者复用了Target，但是依然引用这这个资源。\n\n\t最简单的避免这个错误的方法是在`onLoadCleared()`方法中把所有对资源对象的引用置null。一般情况下，加载一个Bitmap，然后引用它的Target是安全的。不安全的是，你清空了这个Target，却依然引用着这个Bitmap。\n\t\n---------\n\t\n## 使用快照\n\n### 关于快照\n对于那些不想等待Glide下个正式版本而愿意尝鲜的用户，我们在[Sonatype](https://travis-ci.org/bumptech/glide)上部署了这个库的快照。\n每一次我们push代码待GitHub的master分支，[travis-ci](https://oss.sonatype.org/content/repositories/snapshots/)会构建Glide.如果构建成功，会自动部署最新版本的库到Sonatype上。\n和Glide主库一样，每个Intergration库也有自己的快照，如果你使用快照版本的Glide库，请使用快照版本的Intergration库，反之依然。\n\n### 获取快照\nSonatype的快照库和其他的maven库一样，提供jar，maven，gradle等版本。\n\n#### Jar\nJar包可以直接从Sonatype上下载，再次检查一下日期，确保使用最新版本\n\n#### Gradle\n在仓库列表中添加快照仓库\n\n```xml\nrepositories {\n  jcenter()\n  maven {\n    url 'http://oss.sonatype.org/content/repositories/snapshots'\n  }\n}\n```\n然后修改依赖为快照版本\n\n```xml\ndependencies {\n  compile \"com.github.bumptech.glide:glide:3.6.0-SNAPSHOT\"\n  compile \"com.github.bumptech.glide:okhttp-integration:1.3.0-SNAPSHOT\"\n}\n```\n\n#### Maven\n这种方式没有测试，直接从[StackOverflow](http://stackoverflow.com/questions/7715321/how-to-download-snapshot-version-from-maven-snapshot-repository)拷过来的。欢迎改进下面的内容。\n添加下面的代码到`~/.m2/settings.xml`中：\n\n```xml\n<profiles>\n  <profile>\n     <id>allow-snapshots</id>\n     <activation><activeByDefault>true</activeByDefault></activation>\n     <repositories>\n       <repository>\n         <id>snapshots-repo</id>\n         <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n         <releases><enabled>false</enabled></releases>\n         <snapshots><enabled>true</enabled></snapshots>\n       </repository>\n     </repositories>\n   </profile>\n</profiles>\n```\n修改依赖为快照版本\n\n```xml\n<dependency>\n  <groupId>com.github.bumptech.glide</groupId>\n  <artifactId>glide</artifactId>\n  <version>3.6.0-SNAPSHOT</version>\n</dependency>\n<dependency>\n  <groupId>com.github.bumptech.glide</groupId>\n  <artifactId>okhttp-integration</artifactId>\n  <version>1.3.0-SNAPSHOT</version>\n</dependency>\n```\n\n---------\n\n## 图形变换\n\n### 默认的变换\nGlide包含两种默认的图像变换方式，fitCenter和centerCrop。如果开发者需要其他类型的变换，可以考虑使用这个独立的[变换库](https://github.com/wasabeef/glide-transformations)。\n\n#### Fit center\nFitCenter会按原始比例缩小图像，使图像可以在放在给定的区域内。FitCenter会尽可能少地缩小图片，使宽或者高的一边等于给定的值。另外一边会等于或者小于给定值。\nFitCenter和Android中的ScaleType.FIT_CENTER效果相同。\n#### CenterCrop\nCenterCrop会按原始比例缩小图像，使宽或者高的一边等于给定的值，另外一边会等于或者大于给定值。CenterCrop会裁剪掉多余部分。\nCenterCrop和Android中的ScaleType.CENTER_CROP效果相同。\n\n### 使用\nfit center效果使用`.fitCenter()`：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .fitCenter()\n    .into(yourView);\n```\ncenter crop效果使用`.centerCrop()`：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    . centerCrop()\n    .into(yourView);\n```\n如果你只加载Bitmap或者Gif，也可以使用这个变换：\n\n```java\n// For Bitmaps:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .centerCrop()\n    .into(yourView);\n\n// For gifs:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asGif()\n    .fitCenter()\n    .into(yourView);\n```\n当在类型间转码时，也可以使用这些变换。例如，获取一个变形后的jpeg图片的bytes数据：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .toBytes()\n    .centerCrop()\n    .into(new SimpleTarget<byte[]>(...) { ... });\n\n```\n自定义变换\n除了两个内置的变换，你还可以自定义变换。\n最简单的方式是继承BitmapTransformation。\n\n```java\nprivate static class MyTransformation extends BitmapTransformation { \n \n    public MyTransformation(Context context) {\n       super(context);\n    } \n \n    @Override \n    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, \n            int outWidth, int outHeight) {\n       Bitmap myTransformedBitmap = ... // apply some transformation here. \n       return myTransformedBitmap; \n    } \n \n    @Override \n    public String getId() {\n        // Return some id that uniquely identifies your transformation. \n        return \"com.example.myapp.MyTransformation\"; \n    } \n} \n```\n\n之后一就可以用同样的方式使用它。使用`.transform(...)`代替`.fitCenter()`/`.centerCrop()`。\n\n```java\n// For the default drawable type:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .transform(new MyTransformation(context))\n    .into(yourView);\n\n// For Bitmaps:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .transform(new MyTransformation(context))\n    .into(yourView);\n\n// For Gifs:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asGif()\n    .transform(new MyTransformation(context))\n    .into(yourView);\n```\n\n#### 调整大小\n你可能注意到上面的例子没有传入具体的尺寸，那么，Transformation中的尺寸是如何获得的呢？\nTransformation中的尺寸就是View或者Target的大小。Glide会根据布局文件中的weight，match_parent或者具体值算出View的大小。，当你拥有View/Target的具体大小，又拥有原始图片的大小时，就可以通过图像变换生成一个正确大小的图片。\n如果你想指定View/Target的自定义大小，可以使用`.override(int, int)`方法，如果你想加载一个图片有其他用途，而不是显示在View中，请查看『自定义Target』章节。\n\n#### Bitmap 复用\n为了减少垃圾回收，你可以说使用`BitmapPool`接口来释放不想要的Bitmap或者复用存在的Bitmap。一个在Transformation中复用Bitmap典型的例子：从pool中获取Bitmap，使用该Bitmap创建一个`Canvas`，然后使用Matrix/Paint/Shader来变换图像并绘制到Canvas上。为了正确有效地在Transformation中复用Bitmap中，遵守下面的规则：\n\n1. 在`transform()`不要回收资源或者把Bitmap放入Bitmap池中，这些步骤会自动完成。\n2. 如果你从Bitmap池中获取了多个Bitmap，或者没有使用从pool中获取到的Bitmap，确保把多余的Bitmap放回pool中。\n3. 如果你的Trasformation并没有替换调原始图片（比如，图片已经满足你要求的大小，直接返回了），请在`transform()`方法中返回原始的资源或者Bitmap。\n\n一个典型的用法如下：\n\n```java\nprotected Bitmap transform(BitmapPool bitmapPool, Bitmap original, int width, int height) {\n    Bitmap result = bitmapPool.get(width, height, Bitmap.Config.ARGB_8888);\n    // If no matching Bitmap is in the pool, get will return null, so we should allocate. \n    if (result == null) {\n        // Use ARGB_8888 since we're going to add alpha to the image. \n        result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n    } \n    // Create a Canvas backed by the result Bitmap. \n    Canvas canvas = new Canvas(result);\n    Paint paint = new Paint();\n    paint.setAlpha(128);\n    // Draw the original Bitmap onto the result Bitmap with a transformation. \n    canvas.drawBitmap(original, 0, 0, paint);\n    // Since we've replaced our original Bitmap, we return our new Bitmap here. Glide will \n    // will take care of returning our original Bitmap to the BitmapPool for us.  \n    return result;\n} \n```","slug":"Android图片库-Glide","published":1,"updated":"2016-02-01T02:21:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilg4yv6w000w0uc9it1lxwkf","sticky":0}],"PostAsset":[],"PostCategory":[{"post_id":"cilg4yv6300060uc9kcrde9w6","category_id":"cilg4yv6800070uc9bhips80e","_id":"cilg4yv6b00080uc9py5u5690"},{"post_id":"cilg4yv6d00090uc98nobv7vb","category_id":"cilg4yv6e000a0uc96jflhsfh","_id":"cilg4yv6g000d0uc9t8409hsl"},{"post_id":"cilg4yv6j000g0uc9dmwulntc","category_id":"cilg4yv6e000a0uc96jflhsfh","_id":"cilg4yv6k000h0uc9r2r7wn0m"},{"post_id":"cilg4yv6n000n0uc9ljtc70xb","category_id":"cilg4yv6e000a0uc96jflhsfh","_id":"cilg4yv6p000o0uc9mf56wts3"},{"post_id":"cilg4yv6t000s0uc95qwtnlls","category_id":"cilg4yv6e000a0uc96jflhsfh","_id":"cilg4yv6u000t0uc9kqm7wphv"},{"post_id":"cilg4yv6w000w0uc9it1lxwkf","category_id":"cilg4yv6e000a0uc96jflhsfh","_id":"cilg4yv6y000x0uc9kqw7u79j"}],"PostTag":[{"post_id":"cilg4yv6d00090uc98nobv7vb","tag_id":"cilg4yv6e000b0uc9oi0skzt3","_id":"cilg4yv6g000e0uc91w6beawc"},{"post_id":"cilg4yv6d00090uc98nobv7vb","tag_id":"cilg4yv6f000c0uc9ueaxz6xo","_id":"cilg4yv6g000f0uc97iqeg366"},{"post_id":"cilg4yv6j000g0uc9dmwulntc","tag_id":"cilg4yv6e000b0uc9oi0skzt3","_id":"cilg4yv6l000k0uc9a17a5kd7"},{"post_id":"cilg4yv6j000g0uc9dmwulntc","tag_id":"cilg4yv6k000i0uc91pgnb5l7","_id":"cilg4yv6l000l0uc9juyib5v8"},{"post_id":"cilg4yv6j000g0uc9dmwulntc","tag_id":"cilg4yv6l000j0uc9sjpul4nl","_id":"cilg4yv6m000m0uc9s772fsee"},{"post_id":"cilg4yv6n000n0uc9ljtc70xb","tag_id":"cilg4yv6e000b0uc9oi0skzt3","_id":"cilg4yv6r000q0uc9r2xib0cg"},{"post_id":"cilg4yv6n000n0uc9ljtc70xb","tag_id":"cilg4yv6p000p0uc93nk5blou","_id":"cilg4yv6r000r0uc92x75fc23"},{"post_id":"cilg4yv6t000s0uc95qwtnlls","tag_id":"cilg4yv6e000b0uc9oi0skzt3","_id":"cilg4yv6u000u0uc9dzhvpaey"},{"post_id":"cilg4yv6t000s0uc95qwtnlls","tag_id":"cilg4yv6p000p0uc93nk5blou","_id":"cilg4yv6u000v0uc9mccm9d2t"},{"post_id":"cilg4yv6w000w0uc9it1lxwkf","tag_id":"cilg4yv6e000b0uc9oi0skzt3","_id":"cilg4yv6y000y0uc918kqcbi1"},{"post_id":"cilg4yv6w000w0uc9it1lxwkf","tag_id":"cilg4yv6p000p0uc93nk5blou","_id":"cilg4yv6z000z0uc9rd4v9re2"}],"Tag":[{"name":"Android","_id":"cilg4yv6e000b0uc9oi0skzt3"},{"name":"其他","_id":"cilg4yv6f000c0uc9ueaxz6xo"},{"name":"Guide","_id":"cilg4yv6k000i0uc91pgnb5l7"},{"name":"最佳实践","_id":"cilg4yv6l000j0uc9sjpul4nl"},{"name":"主框架","_id":"cilg4yv6p000p0uc93nk5blou"}]}}
{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/codes/定投分析.py","path":"codes/定投分析.py","modified":0,"renderable":0},{"_id":"source/images/arch_MVP_and_MVC.jpg","path":"images/arch_MVP_and_MVC.jpg","modified":0,"renderable":0},{"_id":"source/images/arch_mvp_supervising_presenter.png","path":"images/arch_mvp_supervising_presenter.png","modified":0,"renderable":0},{"_id":"source/images/arch_mvp_clean.png","path":"images/arch_mvp_clean.png","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/git_fast_forward_merge.png","path":"images/git_fast_forward_merge.png","modified":0,"renderable":0},{"_id":"source/images/android_helloworld_project_gradle_files.png","path":"images/android_helloworld_project_gradle_files.png","modified":0,"renderable":0},{"_id":"source/images/git_branch_all.png","path":"images/git_branch_all.png","modified":0,"renderable":0},{"_id":"source/images/git_status_capture.png","path":"images/git_status_capture.png","modified":0,"renderable":0},{"_id":"source/source/codes/定投分析.py","path":"source/codes/定投分析.py","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/financial_quant_analyse.jpg","path":"images/financial_quant_analyse.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"source/images/arch_clean.png","path":"images/arch_clean.png","modified":0,"renderable":0},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"632ce2b6cc3af95a091bf1e632484c0728ccf846","modified":1468552880000},{"_id":"source/404.html","hash":"75f79c7a9f1072300986dc8b56e6cca36b2b7646","modified":1468552880000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1468554820000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1468554820000},{"_id":"themes/next/.DS_Store","hash":"7e389cc7ddbfe9fd38fa551c8183b29d9b87eca7","modified":1468558264000},{"_id":"themes/next/.gitignore","hash":"c8d6a73b9e17f0f8a3716e4ada6960d3180425a6","modified":1468554820000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1468554820000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1468554820000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1468554820000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1468554820000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1468554820000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1468554820000},{"_id":"themes/next/_config.yml","hash":"dd80cc773bc8d6ed0def6cd013921fc7f21f127e","modified":1468558179000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1468554820000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1468554820000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1468552880000},{"_id":"source/_posts/Android图片库-Glide.md","hash":"c1c26a0916c56fb6ebd5aea04dd30b7fe910aa91","modified":1468552880000},{"_id":"source/_posts/Android构架系列之一-工程结构与Gradle配置.md","hash":"b9afc7dfba237850f6a247a37f9c6358ff344bf0","modified":1468552880000},{"_id":"source/_posts/Android构架系列之二-MVP&&Clean理解与实践之Clean.md","hash":"953e49501412707eb179e9320119cbe2a4f3db94","modified":1468552880000},{"_id":"source/_posts/Android构架系列之三-数据库ORM框架.md","hash":"0c3afd62efd9d4b28aaaade1633970cfc20098c6","modified":1468552880000},{"_id":"source/_posts/Android构架系列之二-MVP&&Clean理解与实践之MVP.md","hash":"7346776d883ac9172aec37da5925d523e4867d6a","modified":1468552880000},{"_id":"source/_posts/Android构架系列之二-MVP&&Clean理解与实践之问题解答与总结.md","hash":"3153c99cea0c920ad99718a2d919c25afb5ed62f","modified":1468552880000},{"_id":"source/_posts/Android构架系列之二-MVP&&Clean理解与实践之实例分析.md","hash":"075c69cd7c304f6d3dcc3c5ea3154333146f1688","modified":1468552880000},{"_id":"source/_posts/Android构架系列之二-MVP&&Clean理解与实践之疑问.md","hash":"9155c7e063973e5e94644c6809b8c31791ab4a7f","modified":1468552880000},{"_id":"source/_posts/Google推荐的Android应用框架之demo.md","hash":"c2c5e5fc0204d2904166e3badf40e86ef5cb5658","modified":1468552880000},{"_id":"source/_posts/一些感想-什么是重要的.md","hash":"673cd215d92e76fd26fc1975596a1bb59b11a1ba","modified":1468552880000},{"_id":"source/_posts/全沾Growth工程师学习计划.md","hash":"25b674a0ca3b9e1fb4ed3c16b0fe39e8abcc55f8","modified":1468552880000},{"_id":"source/_posts/始发站，将通往何处.md","hash":"1aa5072a47f34779aad892df701ac5a56b693460","modified":1468552880000},{"_id":"source/_posts/Android注入框架Dagger2学习笔记.md","hash":"b1cfc192f21ffad1e456c02301d739738fdb7c3b","modified":1468552880000},{"_id":"source/_posts/抢红包插件分析以及应用.md","hash":"2c060be2b341b3330864742815a0709ffcca43cb","modified":1468552880000},{"_id":"source/_posts/是时候开始写博客了.md","hash":"9f22e296976c2ee3cfd63f6205609dd5ecbd3486","modified":1468552880000},{"_id":"source/_posts/版本控制工具git入门实践.md","hash":"c70765d625e6bdad4bf0c87956a4f1e84a54384f","modified":1468552880000},{"_id":"source/categories/index.md","hash":"bf42a9ac12d34c166f93214af0b26fafc0ebd2a0","modified":1468552880000},{"_id":"source/codes/定投分析.py","hash":"4d751ca542e4d7b2dcd6179590fed9c2b41c311a","modified":1468552880000},{"_id":"source/_posts/理财：量化分析平台，一个定投策略的实现.md","hash":"85ed4196fd747cb129a0bdca587522d6e7367dd6","modified":1468552880000},{"_id":"source/about/index.md","hash":"9a5dd3ddba5289a4e4d759d771f2053cc2b2a672","modified":1468552880000},{"_id":"source/_posts/Android构架系列之二-常见框架分析.md","hash":"55e8ad0c6c3a1da9bef2e6eda6abaa0a78bdcda9","modified":1468552880000},{"_id":"source/images/arch_MVP_and_MVC.jpg","hash":"d2cbcd9978f3fbcab7190663ce146f436258626f","modified":1462149845000},{"_id":"source/images/.DS_Store","hash":"227b9aaf9205a07c96b30a165afd9cc7ea6b4515","modified":1462701456000},{"_id":"source/images/arch_mvp_supervising_presenter.png","hash":"f7ba53a069bdf630d8c0828858b5ed4fba4c83f2","modified":1462693002000},{"_id":"source/images/arch_mvp_clean.png","hash":"8fee72417312e4a5f767b75a87a1229c7b88c2f5","modified":1462149848000},{"_id":"source/images/avatar.jpg","hash":"6cd06578fa0ccaa6fd0c819e30f23b796b083c20","modified":1451905716000},{"_id":"source/images/git_fast_forward_merge.png","hash":"02dc444dba4c501b3b146dd54bf694186df3042f","modified":1466852005000},{"_id":"source/source/.DS_Store","hash":"632ce2b6cc3af95a091bf1e632484c0728ccf846","modified":1468552804000},{"_id":"source/read/index.md","hash":"8d892e35818d348fe94ec1db8d24f7f4fccdfb61","modified":1468552880000},{"_id":"source/source/404.html","hash":"75f79c7a9f1072300986dc8b56e6cca36b2b7646","modified":1468552804000},{"_id":"source/tags/index.md","hash":"a37dfc7257f428ee34d31cb7d43c4568fa5c092c","modified":1468552880000},{"_id":"source/tools/index.md","hash":"399b77c4ba3310def845421c9a726b185e7e0512","modified":1468552880000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1468554820000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1468554820000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1468554802000},{"_id":"themes/next/.git/index","hash":"6acd63c76f67b93ba126007ca3d6f8d4ddb8b3af","modified":1468556104000},{"_id":"themes/next/.git/packed-refs","hash":"6111aa948e4d9e08e4a4fc84faa6bcde689e194b","modified":1468554820000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1468554820000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1468554820000},{"_id":"themes/next/languages/.zh-Hans.yml.swp","hash":"5eca3ef5c1225c98c3ff9afb1be040b9aa45a6fb","modified":1468556647000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1468554820000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1468554820000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1468554820000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1468554820000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1468554820000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1468554820000},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1468554820000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1468554820000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1468554820000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1468554820000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1468554820000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"fe2fc6420ddcb71f85d44c87aabd99e657b34a25","modified":1468556633000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1468554820000},{"_id":"themes/next/layout/.DS_Store","hash":"f9c56c541fcb7ae7ecabb26b94d925ad13692e8d","modified":1468557571000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1468554820000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1468554820000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1468554820000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1468554820000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1468554820000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1468554820000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1468554820000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1468554820000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1468554820000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1468554820000},{"_id":"source/images/android_helloworld_project_gradle_files.png","hash":"f360e7d7375b3e99398f5ecb0e4715659ffc49d6","modified":1459070927000},{"_id":"source/images/git_branch_all.png","hash":"d4c59570c8aaa0f5bebf08ad41120fcd59426a4d","modified":1466854370000},{"_id":"source/images/git_status_capture.png","hash":"97c40b7599136fb4710fd4e92a55c613c7e0e12e","modified":1466854164000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468554820000},{"_id":"source/source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1468552804000},{"_id":"source/source/_posts/Android构架系列之一-工程结构与Gradle配置.md","hash":"b9afc7dfba237850f6a247a37f9c6358ff344bf0","modified":1468552804000},{"_id":"source/source/_posts/Android构架系列之三-数据库ORM框架.md","hash":"0c3afd62efd9d4b28aaaade1633970cfc20098c6","modified":1468552804000},{"_id":"source/source/_posts/Android构架系列之二-MVP&&Clean理解与实践之Clean.md","hash":"953e49501412707eb179e9320119cbe2a4f3db94","modified":1468552804000},{"_id":"source/source/_posts/Android图片库-Glide.md","hash":"c1c26a0916c56fb6ebd5aea04dd30b7fe910aa91","modified":1468552804000},{"_id":"source/source/_posts/Android构架系列之二-MVP&&Clean理解与实践之MVP.md","hash":"7346776d883ac9172aec37da5925d523e4867d6a","modified":1468552804000},{"_id":"source/source/_posts/Android构架系列之二-MVP&&Clean理解与实践之疑问.md","hash":"9155c7e063973e5e94644c6809b8c31791ab4a7f","modified":1468552804000},{"_id":"source/source/_posts/Android构架系列之二-MVP&&Clean理解与实践之问题解答与总结.md","hash":"3153c99cea0c920ad99718a2d919c25afb5ed62f","modified":1468552804000},{"_id":"source/source/_posts/Android构架系列之二-MVP&&Clean理解与实践之实例分析.md","hash":"075c69cd7c304f6d3dcc3c5ea3154333146f1688","modified":1468552804000},{"_id":"source/source/_posts/Android构架系列之二-常见框架分析.md","hash":"55e8ad0c6c3a1da9bef2e6eda6abaa0a78bdcda9","modified":1468552804000},{"_id":"source/source/_posts/全沾Growth工程师学习计划.md","hash":"25b674a0ca3b9e1fb4ed3c16b0fe39e8abcc55f8","modified":1468552805000},{"_id":"source/source/_posts/Android注入框架Dagger2学习笔记.md","hash":"b1cfc192f21ffad1e456c02301d739738fdb7c3b","modified":1468552804000},{"_id":"source/source/_posts/一些感想-什么是重要的.md","hash":"673cd215d92e76fd26fc1975596a1bb59b11a1ba","modified":1468552804000},{"_id":"source/source/_posts/Google推荐的Android应用框架之demo.md","hash":"c2c5e5fc0204d2904166e3badf40e86ef5cb5658","modified":1468552804000},{"_id":"source/source/_posts/始发站，将通往何处.md","hash":"1aa5072a47f34779aad892df701ac5a56b693460","modified":1468552805000},{"_id":"source/source/_posts/抢红包插件分析以及应用.md","hash":"2c060be2b341b3330864742815a0709ffcca43cb","modified":1468552805000},{"_id":"source/source/about/index.md","hash":"9a5dd3ddba5289a4e4d759d771f2053cc2b2a672","modified":1468552805000},{"_id":"source/source/_posts/理财：量化分析平台，一个定投策略的实现.md","hash":"85ed4196fd747cb129a0bdca587522d6e7367dd6","modified":1468552805000},{"_id":"source/source/_posts/版本控制工具git入门实践.md","hash":"c70765d625e6bdad4bf0c87956a4f1e84a54384f","modified":1468552805000},{"_id":"source/source/categories/index.md","hash":"bf42a9ac12d34c166f93214af0b26fafc0ebd2a0","modified":1468552805000},{"_id":"source/source/codes/定投分析.py","hash":"4d751ca542e4d7b2dcd6179590fed9c2b41c311a","modified":1468552805000},{"_id":"source/source/_posts/是时候开始写博客了.md","hash":"9f22e296976c2ee3cfd63f6205609dd5ecbd3486","modified":1468552805000},{"_id":"source/source/tags/index.md","hash":"a37dfc7257f428ee34d31cb7d43c4568fa5c092c","modified":1468552805000},{"_id":"source/source/read/index.md","hash":"8d892e35818d348fe94ec1db8d24f7f4fccdfb61","modified":1468552805000},{"_id":"source/source/tools/index.md","hash":"399b77c4ba3310def845421c9a726b185e7e0512","modified":1468552805000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1468554802000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1468554802000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1468554802000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1468554802000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1468554802000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1468554802000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1468554802000},{"_id":"themes/next/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1468554802000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1468554802000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1468554802000},{"_id":"themes/next/.git/logs/HEAD","hash":"2d8cf63a4565ef8d997809c12b6cd771ce63f2e1","modified":1468554820000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1468554820000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1468554820000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1468554820000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1468554820000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1468554820000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1468554820000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1468554820000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1468554820000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1468554820000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1468554820000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1468554820000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1468556757000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1468554820000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1468554820000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1468554820000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1468554820000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1468554820000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1468554820000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1468554820000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1468554820000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1468554820000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1468554820000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1468554820000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1468554820000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1468554820000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1468554820000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1468554820000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1468554820000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1468554820000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1468554820000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1468554820000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1468554820000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1468554820000},{"_id":"source/images/financial_quant_analyse.jpg","hash":"388396ba9afe94109f97b6f0cd7732f176d120a3","modified":1458462139000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468554820000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468554820000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468554820000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468554820000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468554820000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468554820000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468554820000},{"_id":"themes/next/.git/refs/heads/master","hash":"9285ce3fc15a941a32475a0fc4c1404f614b8105","modified":1468554820000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1468554820000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1468554820000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1468554820000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1468554820000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1468554820000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1468554820000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1468554820000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1468554820000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1468554820000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1468554820000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1468554820000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1468554820000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1468554820000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1468554820000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1468554820000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1468554820000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1468554820000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1468554820000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1468554820000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1468554820000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1468554820000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1468554820000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1468554820000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1468554820000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1468554820000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1468554820000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1468554820000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1468554820000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1468554820000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1468554820000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1468554820000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1468554820000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1468554820000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1468554820000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1468554820000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1468554820000},{"_id":"source/images/arch_clean.png","hash":"879c1e85b92106fdd01dcaf2b7f91c993ca18863","modified":1462695455000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1468554820000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1468554820000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1468554820000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1468554820000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"2d8cf63a4565ef8d997809c12b6cd771ce63f2e1","modified":1468554820000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1468554820000},{"_id":"themes/next/.git/objects/pack/pack-f953df4feff31e8efa9e0e06d699c6874617714d.idx","hash":"07e3e6ee14c75f57812aa3c09f49181b8ee8b009","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1468554820000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1468554820000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1468554820000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1468554820000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1468554820000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1468554820000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1468554820000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1468554820000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1468554820000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1468554820000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1468554820000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1468554820000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1468554820000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1468554820000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"2d8cf63a4565ef8d997809c12b6cd771ce63f2e1","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1468554820000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1468554820000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1468554820000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1468554820000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1468554820000},{"_id":"themes/next/.git/objects/pack/pack-f953df4feff31e8efa9e0e06d699c6874617714d.pack","hash":"ea88d4dfc3dbae4f5aa693d457382352ee5f229b","modified":1468554820000}],"Category":[{"name":"技术","_id":"ciqn9tbbx0006nac9ycascj3x"},{"name":"杂谈","_id":"ciqn9tbcs0010nac93dboesri"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","date":"2016-07-15T03:21:20.000Z","updated":"2016-07-15T03:21:20.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ciqn9tba20000nac92pr9bijy","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"></script>\n\n</body>\n</html>\n","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n"},{"title":"categories","date":"2015-12-11T03:02:26.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-12-11 11:02:26\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-07-15T03:21:20.000Z","path":"categories/index.html","layout":"page","_id":"ciqn9tbbr0002nac9iwltaw4s","content":"","excerpt":"","more":""},{"title":"about","date":"2016-01-04T03:17:02.000Z","_content":"# About Me\n\n\n# 感兴趣的技术\n* RxJava：流行的开发框架，适应高性能app的开发趋势\n* ReactNative：一种有前途的app跨平台方案\n* Flux：Fb提出的单向数据流开发思想\n* MVP MVVM：Android开发常用的设计模式","source":"about/index.md","raw":"title: about\ndate: 2016-01-04 11:17:02\n---\n# About Me\n\n\n# 感兴趣的技术\n* RxJava：流行的开发框架，适应高性能app的开发趋势\n* ReactNative：一种有前途的app跨平台方案\n* Flux：Fb提出的单向数据流开发思想\n* MVP MVVM：Android开发常用的设计模式","updated":"2016-07-15T03:21:20.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciqn9tbbu0004nac98hludy4i","content":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><h1 id=\"感兴趣的技术\"><a href=\"#感兴趣的技术\" class=\"headerlink\" title=\"感兴趣的技术\"></a>感兴趣的技术</h1><ul>\n<li>RxJava：流行的开发框架，适应高性能app的开发趋势</li>\n<li>ReactNative：一种有前途的app跨平台方案</li>\n<li>Flux：Fb提出的单向数据流开发思想</li>\n<li>MVP MVVM：Android开发常用的设计模式</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><h1 id=\"感兴趣的技术\"><a href=\"#感兴趣的技术\" class=\"headerlink\" title=\"感兴趣的技术\"></a>感兴趣的技术</h1><ul>\n<li>RxJava：流行的开发框架，适应高性能app的开发趋势</li>\n<li>ReactNative：一种有前途的app跨平台方案</li>\n<li>Flux：Fb提出的单向数据流开发思想</li>\n<li>MVP MVVM：Android开发常用的设计模式</li>\n</ul>\n"},{"title":"阅读","date":"2016-01-04T03:17:02.000Z","_content":"# About Read\n分享一些书籍和阅读资源\n\n\n# 博客\n* [Android开发技术周报](http://www.androidweekly.cn)\n\n# 微信公众号\n* 学习学习再学习\n\n# 网站\n\n* 【】","source":"read/index.md","raw":"title: 阅读\ndate: 2016-01-04 11:17:02\n---\n# About Read\n分享一些书籍和阅读资源\n\n\n# 博客\n* [Android开发技术周报](http://www.androidweekly.cn)\n\n# 微信公众号\n* 学习学习再学习\n\n# 网站\n\n* 【】","updated":"2016-07-15T03:21:20.000Z","path":"read/index.html","comments":1,"layout":"page","_id":"ciqn9tbbz0008nac9uyf2ffbk","content":"<h1 id=\"About-Read\"><a href=\"#About-Read\" class=\"headerlink\" title=\"About Read\"></a>About Read</h1><p>分享一些书籍和阅读资源</p>\n<h1 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h1><ul>\n<li><a href=\"http://www.androidweekly.cn\" target=\"_blank\" rel=\"external\">Android开发技术周报</a></li>\n</ul>\n<h1 id=\"微信公众号\"><a href=\"#微信公众号\" class=\"headerlink\" title=\"微信公众号\"></a>微信公众号</h1><ul>\n<li>学习学习再学习</li>\n</ul>\n<h1 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h1><ul>\n<li>【】</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"About-Read\"><a href=\"#About-Read\" class=\"headerlink\" title=\"About Read\"></a>About Read</h1><p>分享一些书籍和阅读资源</p>\n<h1 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h1><ul>\n<li><a href=\"http://www.androidweekly.cn\">Android开发技术周报</a></li>\n</ul>\n<h1 id=\"微信公众号\"><a href=\"#微信公众号\" class=\"headerlink\" title=\"微信公众号\"></a>微信公众号</h1><ul>\n<li>学习学习再学习</li>\n</ul>\n<h1 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h1><ul>\n<li>【】</li>\n</ul>\n"},{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","source":"source/404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","date":"2016-07-15T03:20:04.000Z","updated":"2016-07-15T03:20:04.000Z","path":"source/404.html","title":"","comments":1,"layout":"page","_id":"ciqn9tbc4000anac9jpter6a5","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"></script>\n\n</body>\n</html>\n","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n"},{"title":"tags","date":"2015-12-11T02:59:14.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-12-11 10:59:14\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-07-15T03:21:20.000Z","path":"tags/index.html","layout":"page","_id":"ciqn9tbc7000enac9dah8e78u","content":"","excerpt":"","more":""},{"title":"利器","date":"2015-12-11T03:02:26.000Z","type":"tools","_content":"# 工欲善其事，必先利其器\n介绍一些神器\n\n## App\n* 即刻 \n\n\n\n## Mac\n* alfred\n* dash\n* iterm+zsh\n\n## [Alfred插件](https://www.zhihu.com/question/20656680)\n* [workflow list](http://alfredworkflow.com/) - 搜索常用的alfred workflow插件，wf+空格+关键字\n* 有道词典翻译 - yd+空格+关键字 \n* [tinyPNG](http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng) - 选中文件，然后打开alfred，输入tiny,需要先配置。\n* [terminalfinder](http://www.packal.org/workflow/terminalfinder) - 快速终端/iterm，finder切换，注意对应版本。\n* [其他推荐](http://sspai.com/32680)\n\n## 命令行\n* cheat","source":"tools/index.md","raw":"title: 利器\ndate: 2015-12-11 11:02:26\ntype: \"tools\"\n---\n# 工欲善其事，必先利其器\n介绍一些神器\n\n## App\n* 即刻 \n\n\n\n## Mac\n* alfred\n* dash\n* iterm+zsh\n\n## [Alfred插件](https://www.zhihu.com/question/20656680)\n* [workflow list](http://alfredworkflow.com/) - 搜索常用的alfred workflow插件，wf+空格+关键字\n* 有道词典翻译 - yd+空格+关键字 \n* [tinyPNG](http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng) - 选中文件，然后打开alfred，输入tiny,需要先配置。\n* [terminalfinder](http://www.packal.org/workflow/terminalfinder) - 快速终端/iterm，finder切换，注意对应版本。\n* [其他推荐](http://sspai.com/32680)\n\n## 命令行\n* cheat","updated":"2016-07-15T03:21:20.000Z","path":"tools/index.html","comments":1,"layout":"page","_id":"ciqn9tbca000gnac9q1hebl52","content":"<h1 id=\"工欲善其事，必先利其器\"><a href=\"#工欲善其事，必先利其器\" class=\"headerlink\" title=\"工欲善其事，必先利其器\"></a>工欲善其事，必先利其器</h1><p>介绍一些神器</p>\n<h2 id=\"App\"><a href=\"#App\" class=\"headerlink\" title=\"App\"></a>App</h2><ul>\n<li>即刻 </li>\n</ul>\n<h2 id=\"Mac\"><a href=\"#Mac\" class=\"headerlink\" title=\"Mac\"></a>Mac</h2><ul>\n<li>alfred</li>\n<li>dash</li>\n<li>iterm+zsh</li>\n</ul>\n<h2 id=\"Alfred插件\"><a href=\"#Alfred插件\" class=\"headerlink\" title=\"Alfred插件\"></a><a href=\"https://www.zhihu.com/question/20656680\" target=\"_blank\" rel=\"external\">Alfred插件</a></h2><ul>\n<li><a href=\"http://alfredworkflow.com/\" target=\"_blank\" rel=\"external\">workflow list</a> - 搜索常用的alfred workflow插件，wf+空格+关键字</li>\n<li>有道词典翻译 - yd+空格+关键字 </li>\n<li><a href=\"http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng\" target=\"_blank\" rel=\"external\">tinyPNG</a> - 选中文件，然后打开alfred，输入tiny,需要先配置。</li>\n<li><a href=\"http://www.packal.org/workflow/terminalfinder\" target=\"_blank\" rel=\"external\">terminalfinder</a> - 快速终端/iterm，finder切换，注意对应版本。</li>\n<li><a href=\"http://sspai.com/32680\" target=\"_blank\" rel=\"external\">其他推荐</a></li>\n</ul>\n<h2 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h2><ul>\n<li>cheat</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"工欲善其事，必先利其器\"><a href=\"#工欲善其事，必先利其器\" class=\"headerlink\" title=\"工欲善其事，必先利其器\"></a>工欲善其事，必先利其器</h1><p>介绍一些神器</p>\n<h2 id=\"App\"><a href=\"#App\" class=\"headerlink\" title=\"App\"></a>App</h2><ul>\n<li>即刻 </li>\n</ul>\n<h2 id=\"Mac\"><a href=\"#Mac\" class=\"headerlink\" title=\"Mac\"></a>Mac</h2><ul>\n<li>alfred</li>\n<li>dash</li>\n<li>iterm+zsh</li>\n</ul>\n<h2 id=\"Alfred插件\"><a href=\"#Alfred插件\" class=\"headerlink\" title=\"Alfred插件\"></a><a href=\"https://www.zhihu.com/question/20656680\">Alfred插件</a></h2><ul>\n<li><a href=\"http://alfredworkflow.com/\">workflow list</a> - 搜索常用的alfred workflow插件，wf+空格+关键字</li>\n<li>有道词典翻译 - yd+空格+关键字 </li>\n<li><a href=\"http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng\">tinyPNG</a> - 选中文件，然后打开alfred，输入tiny,需要先配置。</li>\n<li><a href=\"http://www.packal.org/workflow/terminalfinder\">terminalfinder</a> - 快速终端/iterm，finder切换，注意对应版本。</li>\n<li><a href=\"http://sspai.com/32680\">其他推荐</a></li>\n</ul>\n<h2 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h2><ul>\n<li>cheat</li>\n</ul>\n"},{"title":"categories","date":"2015-12-11T03:02:26.000Z","type":"categories","comments":0,"_content":"","source":"source/categories/index.md","raw":"title: categories\ndate: 2015-12-11 11:02:26\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-07-15T03:20:05.000Z","path":"source/categories/index.html","layout":"page","_id":"ciqn9tbid002lnac91q84bg9w","content":"","excerpt":"","more":""},{"title":"about","date":"2016-01-04T03:17:02.000Z","_content":"# About Me\n\n\n# 感兴趣的技术\n* RxJava：流行的开发框架，适应高性能app的开发趋势\n* ReactNative：一种有前途的app跨平台方案\n* Flux：Fb提出的单向数据流开发思想\n* MVP MVVM：Android开发常用的设计模式","source":"source/about/index.md","raw":"title: about\ndate: 2016-01-04 11:17:02\n---\n# About Me\n\n\n# 感兴趣的技术\n* RxJava：流行的开发框架，适应高性能app的开发趋势\n* ReactNative：一种有前途的app跨平台方案\n* Flux：Fb提出的单向数据流开发思想\n* MVP MVVM：Android开发常用的设计模式","updated":"2016-07-15T03:20:05.000Z","path":"source/about/index.html","comments":1,"layout":"page","_id":"ciqn9tbie002mnac9jg99a0ui","content":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><h1 id=\"感兴趣的技术\"><a href=\"#感兴趣的技术\" class=\"headerlink\" title=\"感兴趣的技术\"></a>感兴趣的技术</h1><ul>\n<li>RxJava：流行的开发框架，适应高性能app的开发趋势</li>\n<li>ReactNative：一种有前途的app跨平台方案</li>\n<li>Flux：Fb提出的单向数据流开发思想</li>\n<li>MVP MVVM：Android开发常用的设计模式</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><h1 id=\"感兴趣的技术\"><a href=\"#感兴趣的技术\" class=\"headerlink\" title=\"感兴趣的技术\"></a>感兴趣的技术</h1><ul>\n<li>RxJava：流行的开发框架，适应高性能app的开发趋势</li>\n<li>ReactNative：一种有前途的app跨平台方案</li>\n<li>Flux：Fb提出的单向数据流开发思想</li>\n<li>MVP MVVM：Android开发常用的设计模式</li>\n</ul>\n"},{"title":"tags","date":"2015-12-11T02:59:14.000Z","type":"tags","comments":0,"_content":"","source":"source/tags/index.md","raw":"title: tags\ndate: 2015-12-11 10:59:14\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-07-15T03:20:05.000Z","path":"source/tags/index.html","layout":"page","_id":"ciqn9tbif002nnac9yl9vvdm7","content":"","excerpt":"","more":""},{"title":"利器","date":"2015-12-11T03:02:26.000Z","type":"tools","_content":"# 工欲善其事，必先利其器\n介绍一些神器\n\n## App\n* 即刻 \n\n\n\n## Mac\n* alfred\n* dash\n* iterm+zsh\n\n## [Alfred插件](https://www.zhihu.com/question/20656680)\n* [workflow list](http://alfredworkflow.com/) - 搜索常用的alfred workflow插件，wf+空格+关键字\n* 有道词典翻译 - yd+空格+关键字 \n* [tinyPNG](http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng) - 选中文件，然后打开alfred，输入tiny,需要先配置。\n* [terminalfinder](http://www.packal.org/workflow/terminalfinder) - 快速终端/iterm，finder切换，注意对应版本。\n* [其他推荐](http://sspai.com/32680)\n\n## 命令行\n* cheat","source":"source/tools/index.md","raw":"title: 利器\ndate: 2015-12-11 11:02:26\ntype: \"tools\"\n---\n# 工欲善其事，必先利其器\n介绍一些神器\n\n## App\n* 即刻 \n\n\n\n## Mac\n* alfred\n* dash\n* iterm+zsh\n\n## [Alfred插件](https://www.zhihu.com/question/20656680)\n* [workflow list](http://alfredworkflow.com/) - 搜索常用的alfred workflow插件，wf+空格+关键字\n* 有道词典翻译 - yd+空格+关键字 \n* [tinyPNG](http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng) - 选中文件，然后打开alfred，输入tiny,需要先配置。\n* [terminalfinder](http://www.packal.org/workflow/terminalfinder) - 快速终端/iterm，finder切换，注意对应版本。\n* [其他推荐](http://sspai.com/32680)\n\n## 命令行\n* cheat","updated":"2016-07-15T03:20:05.000Z","path":"source/tools/index.html","comments":1,"layout":"page","_id":"ciqn9tbii002onac9d0rikhaw","content":"<h1 id=\"工欲善其事，必先利其器\"><a href=\"#工欲善其事，必先利其器\" class=\"headerlink\" title=\"工欲善其事，必先利其器\"></a>工欲善其事，必先利其器</h1><p>介绍一些神器</p>\n<h2 id=\"App\"><a href=\"#App\" class=\"headerlink\" title=\"App\"></a>App</h2><ul>\n<li>即刻 </li>\n</ul>\n<h2 id=\"Mac\"><a href=\"#Mac\" class=\"headerlink\" title=\"Mac\"></a>Mac</h2><ul>\n<li>alfred</li>\n<li>dash</li>\n<li>iterm+zsh</li>\n</ul>\n<h2 id=\"Alfred插件\"><a href=\"#Alfred插件\" class=\"headerlink\" title=\"Alfred插件\"></a><a href=\"https://www.zhihu.com/question/20656680\" target=\"_blank\" rel=\"external\">Alfred插件</a></h2><ul>\n<li><a href=\"http://alfredworkflow.com/\" target=\"_blank\" rel=\"external\">workflow list</a> - 搜索常用的alfred workflow插件，wf+空格+关键字</li>\n<li>有道词典翻译 - yd+空格+关键字 </li>\n<li><a href=\"http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng\" target=\"_blank\" rel=\"external\">tinyPNG</a> - 选中文件，然后打开alfred，输入tiny,需要先配置。</li>\n<li><a href=\"http://www.packal.org/workflow/terminalfinder\" target=\"_blank\" rel=\"external\">terminalfinder</a> - 快速终端/iterm，finder切换，注意对应版本。</li>\n<li><a href=\"http://sspai.com/32680\" target=\"_blank\" rel=\"external\">其他推荐</a></li>\n</ul>\n<h2 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h2><ul>\n<li>cheat</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"工欲善其事，必先利其器\"><a href=\"#工欲善其事，必先利其器\" class=\"headerlink\" title=\"工欲善其事，必先利其器\"></a>工欲善其事，必先利其器</h1><p>介绍一些神器</p>\n<h2 id=\"App\"><a href=\"#App\" class=\"headerlink\" title=\"App\"></a>App</h2><ul>\n<li>即刻 </li>\n</ul>\n<h2 id=\"Mac\"><a href=\"#Mac\" class=\"headerlink\" title=\"Mac\"></a>Mac</h2><ul>\n<li>alfred</li>\n<li>dash</li>\n<li>iterm+zsh</li>\n</ul>\n<h2 id=\"Alfred插件\"><a href=\"#Alfred插件\" class=\"headerlink\" title=\"Alfred插件\"></a><a href=\"https://www.zhihu.com/question/20656680\">Alfred插件</a></h2><ul>\n<li><a href=\"http://alfredworkflow.com/\">workflow list</a> - 搜索常用的alfred workflow插件，wf+空格+关键字</li>\n<li>有道词典翻译 - yd+空格+关键字 </li>\n<li><a href=\"http://www.waerfa.com/alfred-workflow-collection-compress-pictures-with-tinypng\">tinyPNG</a> - 选中文件，然后打开alfred，输入tiny,需要先配置。</li>\n<li><a href=\"http://www.packal.org/workflow/terminalfinder\">terminalfinder</a> - 快速终端/iterm，finder切换，注意对应版本。</li>\n<li><a href=\"http://sspai.com/32680\">其他推荐</a></li>\n</ul>\n<h2 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h2><ul>\n<li>cheat</li>\n</ul>\n"},{"title":"阅读","date":"2016-01-04T03:17:02.000Z","_content":"# About Read\n分享一些书籍和阅读资源\n\n\n# 博客\n* [Android开发技术周报](http://www.androidweekly.cn)\n\n# 微信公众号\n* 学习学习再学习\n\n# 网站\n\n* 【】","source":"source/read/index.md","raw":"title: 阅读\ndate: 2016-01-04 11:17:02\n---\n# About Read\n分享一些书籍和阅读资源\n\n\n# 博客\n* [Android开发技术周报](http://www.androidweekly.cn)\n\n# 微信公众号\n* 学习学习再学习\n\n# 网站\n\n* 【】","updated":"2016-07-15T03:20:05.000Z","path":"source/read/index.html","comments":1,"layout":"page","_id":"ciqn9tbik002pnac949lz1imh","content":"<h1 id=\"About-Read\"><a href=\"#About-Read\" class=\"headerlink\" title=\"About Read\"></a>About Read</h1><p>分享一些书籍和阅读资源</p>\n<h1 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h1><ul>\n<li><a href=\"http://www.androidweekly.cn\" target=\"_blank\" rel=\"external\">Android开发技术周报</a></li>\n</ul>\n<h1 id=\"微信公众号\"><a href=\"#微信公众号\" class=\"headerlink\" title=\"微信公众号\"></a>微信公众号</h1><ul>\n<li>学习学习再学习</li>\n</ul>\n<h1 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h1><ul>\n<li>【】</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"About-Read\"><a href=\"#About-Read\" class=\"headerlink\" title=\"About Read\"></a>About Read</h1><p>分享一些书籍和阅读资源</p>\n<h1 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h1><ul>\n<li><a href=\"http://www.androidweekly.cn\">Android开发技术周报</a></li>\n</ul>\n<h1 id=\"微信公众号\"><a href=\"#微信公众号\" class=\"headerlink\" title=\"微信公众号\"></a>微信公众号</h1><ul>\n<li>学习学习再学习</li>\n</ul>\n<h1 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h1><ul>\n<li>【】</li>\n</ul>\n"}],"Post":[{"title":"Android图片库--Glide Wiki中文翻译","date":"2016-01-24T02:32:54.000Z","description":"Glide Wiki中文翻译。Glide是一个Android图片库，确切地说应当叫『媒体框架』。支持图片、Gif、原生视频的加载。使用简单，性能优异，Google推荐。","_content":"## 序\n最近，一直在捣鼓Glide这个图片库，确切地说应当叫『媒体框架』。为了支持Gif播放，项目中使用Glide代替了Universal Image Loader。起初我们打算使用的是Fresco方案，最终因为Lib体积的问题放弃。万万没想到apk的size这么敏感，国外很多推广服务是根据apk体积收费的，3M一个门槛，5M一个门槛。fresco引入之后即使proguard、7zip，apk的大小也增加了1M+，多平台的os库是个大头，第三世界的应用市场还不支持按平台分发😓。。\nGlide的使用还不深入，仅仅停留在Api的范畴，为了解决bug，跟踪了代码，也是云里雾里。不得不说，Glide源码的设计十分NB，面向接口的理念贯彻的很彻底，是一个学习设计的好demo。\nGitHub的README作为最简单的入门足够了，但是遇到具体问题还是要理解一些设计思想的，GitHub上的Wiki有一份不错的文档，可惜木有中文，正好学习的过程中翻译一下。\n在看wiki之前，可以先看这两篇中文入门，了解基本的用法。\n\n* [Google推荐的图片加载库Glide介绍](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html)\n* [Glide 一个专注于平滑滚动的图片加载和缓存库](http://www.jianshu.com/p/4a3177b57949)\n\n本文是基于**Glide 3.x**正式版的[Wiki文档](https://github.com/bumptech/glide/wiki)的翻译（原文编辑日期：2015-2-9,18 revision，当时Glide release的版本号3.6.1）。\n\n翻译Version：1.1 简单校对\n\n### 名词解释\nGlide中有一部分单词，我不知道用什么中文可以确切的表达出含义，用英文单词可能在行文中更加合适，还有一些词在Glide中有特别的含义，我理解的可能也不深入，这里先记录一下。\n\n* View： 一般情况下，指Android中的View及其子类控件（包括自定义的），尤其指ImageView。这些控件可在上面绘制Drawable\n* Target： Glide中重要的概念，目标。它即可以指封装了一个View的Target（ViewTarget），也可以不包含View（SimpleTarget）。\n* Drawable： 指Android中的Drawable类或者它的子类，如BitmapDrawable等。或者Glide中基础Drawable实现的自定义Drawable（如GifDrawable等）\n* Request - 加载请求，可以是网络请求或者其他任何下载图片的请求，也是Glide中的一个类。\n* Model：数据源的提供者，如Url，文件路径等，可以从model中获取InputStream。\n* Signature：签名，可以唯一地标识一个对象。\n* recycle()：Glide中Resource类有此方法，表示该资源不被引用，可以放入池中（此时并没有释放空间）。Android中Bitmap也有此方法，表示释放Bitmap占用的内存。\n\n## 目录\n* 主目录\n* 缓存机制与缓存失效\n* Glide配置\n* 自定义Target\n* 调试与错误处理\n* 使用Glide下载自定义大小图片\n* 集成库-与其他库相整合\n* 在后台线程中加载与缓存数据\n* Glide中的资源复用\n* 快照（Snapshots）\n* 图形变换（Transformations）\n\n---------\n\n## 主目录\n\n### 报告问题\n如果你有任何问题，可以在[Github上提出](https://github.com/bumptech/glide/issues/)或者发送e-mail到我们的[邮件列表](https://groups.google.com/forum/#!forum/glidelibrary)，也可以在IRC(Internet Relay Chat 网络中继聊天？)频道上联系我们：[irc.freenode.net#glide-library](http://webchat.freenode.net/?channels=glide-library)。\n\n### 3.0版本的新特性\n* 支持Gif动画的解码 - 与加载图片相同，只要调用Glide.with(...).load(...)，如果你加载的图片是一个可以播放的Gif，Glide会自动加载它并显示在一个自定义的Drawable上（注：GifDrawable）。此外，你还可以控制的更多，比如\n\n\t```java\n// 你想加载Gif为一张静态图片\nGlide.with(context).load(...).asBitmap()。\n// 或者你想只有加载对象是Gif时才能加载成功\nGlide.with(context).load(...).asGif()。\n```\n\n* 本地视频播放技术 - 除了解码Gif，Glide也能解码你设备上的视频（video）。使用方法和加载gif相同，Glide支持所有Android可以直接解码的视频。\n* 支持缩略图加载 - 有时我们希望减少用户等待的时间又不想牺牲图片的质量，我们可以同时加载多张图片到一个View中，先加载缩略图（只有view的1/10大小），然后再加载一个完整的图像覆盖在上面。使用下面的代码\n\n\t```java\nGlide.with(yourFragment).load(yourUrl).thumbnail(0.1f).into(yourView)\n```\n\n当然，你也可以传入一个Request到`.thumbnail()`函数中作为参数。\n\n* 与生命周期集成 - 加载请求现在会自动在onStop中暂停在，onStart中重新开始。为了节约电量，Gif动画也会在onStop中自动暂停。此外，当设备的连接状态改变时，所有失败的请求会自动重试，确保Glide不会因为临时性的连接问题，导致请求永远失败。\n* 转码 - 除了解码资源，Glide的`.toBytes()`和`.transcode()`方法允许你在后台正常地获取、解码、变换一张图片。你还可以在这些调用中把图片转码成更有用的格式，比如，上传一张大小为250*250像素的用户头像的图片bytes数据，代码如下\n\n\t```java\nGlide.with(context)\n    .load(“/user/profile/photo/path”)\n    .asBitmap()\n    .toBytes()\n    .centerCrop()\n    .into(new SimpleTarget<byte[]>(250, 250) {\n        @Override\n        public void onResourceReady(byte[] data, GlideAnimation anim) {\n            // 在此处，将bytes数据传入后台线程，再上传他们\n        }\n    });\n```\n\n* 动画 - Glide3.X支持『淡入淡出』动画（`.crossFade()`）和view的属性动画(`.animate(ViewPropertyAnimation.Animator)`)。此外，还有Glide2.0就支持的android view动画。\n* 支持 OkHttp 和 Volley - 现在你可以选择用OkHttp、Volley或者默认的HttpUrlConnection作为网络栈。OkHttp和Volley可以通过添加对应的集成库(integration library)和注册相应的`ModelLoaderFactory`来引入。具体查看ReadMe文件。\n* 其他 - 可以使用Drawable对象作为加载中的占位图、请求优先级、覆盖自定义宽和高、可以缓存变换后的缩略图或者缓存原始文件\n\n### 从2.0迁移到3.0\n* 将所有的`Glide.load()`替换为`Glide.with([fragment/activity/context]).load()`。\n* 将所有的自定义的加载调用`Glide.load(url).into(new SimpleTarget(){ ... }).with(context)`替换成`Glide.with(context).load(url).into(new SimpleTarget(width, height) { ... })`。\n\n### 特性\n除了3.0引入的新功能，Glide继承了2.0的所有功能：\n\n* 后台图片加载\n* 如果你使用了listview的复用机制，那么Glide会自动取消作业（job）\n* 内存和磁盘缓存\n* Bitmap和资源池来减少内存抖动\n* 支持任意的图像变换\n\n---------\n\n## 缓存机制与缓存失效\n缓存失效是一个比较复杂的话题，理想情况下，你尽可能不要考虑这个问题。这一节主要是让你粗略的了解一下Glide中cache的key是如何生成，以及提供一些关于如何合理利用缓存的提示。\n### 缓存的key\n`DiskCacheStrategy.RESULT`磁盘缓存策略（注：我们配置的一种磁盘缓存策略）使用的key由以下四个主要部分组成：\n\n* DataFetcher的方法`getId()`返回的字符。典型地，DataFetcher仅仅返回由数据Model的`toString()`方法得到的值。所以，如果Model是一个**URL**，那么会返回URL的字符串，如果Model是是一个文件，那么会返回文件的**路径**。。。\n* 宽和高。如果你调用过override(width,height)方法，那么就是是它传入的值。没有调用过，默认是通过**Target**的`getSize()`方法获得这个值。\n* 各种编码器、解码器的`getId()`方法返回的字符串。这些编码器、解码器用于加载和缓存你的图片。仅有哪些堆bytes数据有影响的编码器、解码器才会有这些`id`值。比如，你只有一个将bytes数据写入磁盘的编码器，那么它就没有id值，因为不管怎样它都不会修改数据。\n* 可选地，你可以为图片加载提供签名(Signature)，请看下面的缓存失效部分。\n\n所有的这些key，以特定的顺序计算出hash值，并将这个值作为保存图片到磁盘上的唯一且安全的文件名。\n\n### 缓存失效\n由于文件名是hash值，没有简便的方式删除磁盘上某个特定url或者文件路径的所有缓存文件。如果仅仅缓存原文件，问题可能还比较简单，但是Glide会缓存缩略图，各种变换后的图片，所有这些缓存都会产生新文件。跟踪和删除所有文件是十分困难的。\n\n### 自定义缓存失效\n通常情况下改变缓存的标志（key）是困难的。Glide提供了`signature()`API来混入其他数据，帮助你控制缓存的key。签名（Signature）对于多媒体或者有版本信息的内容来说都很有用。\n\n* 媒体库内容 - 对于媒体库内容，你可以使用Glide的`MediaStoreSignature`类作为签名， MediaStoreSignature类允许你混入文件修改时间、mime类型、媒体库的方向(orientation?)这些值作为缓存的key，这三个值足以让你可靠的捕捉到任何修改和更新，使你可以缓存媒体库的缩略图.?\n* 文件 - 你可以使用`StringSignature`混入文件修改时间\n* url - 虽然使url失效最好的方式是当内容变化时，服务器修改url并更新客户端，但是你也可以用`StringSignature`混入任意的元数据（如版本号）来使缓存失效。\n\n使用String Signature加载数据很简单：\n\n```java\nGlide.with(yourFragment)\n    .load(yourFileDataModel)\n    .signature(new StringSignature(yourVersionMetadata))\n    .into(yourImageView);\n```\n\n媒体库Signature可以直接使用从MeidaStore(注：一个android api）获得的数据\n\n```java\nGlide.with(fragment)\n    .load(mediaStoreUri)\n    .signature(new MediaStoreSignature(mimeType, dateModified, orientation))\n    .into(view);\n```\n\n你还可以通过实现`key`接口来自定义签名，确保实现了`equals()`, `hashCode()`和`updateDiskCacheKey()`这几个方法\n\n```java\npublic class IntegerVersionSignature implements Key {\n    private int currentVersion;\n \n    public IntegerVersionSignature(int currentVersion) {\n         this.currentVersion = currentVersion;\n    } \n \n    @Override \n    public boolean equals(Object o) {\n        if (o instanceof IntegerVersionSignature) {\n            IntegerVersionSignature other = (IntegerVersionSignature) o;\n            return currentVersion = other.currentVersion;\n        } \n        return false; \n    } \n \n    @Override \n    public int hashCode() { \n        return currentVersion;\n    } \n \n    @Override \n    public void updateDiskCacheKey(MessageDigest md) {\n        messageDigest.update(ByteBuffer.allocate(Integer.SIZE).putInt(signature).array());\n    } \n} \n```\n请牢记：为了避免性能下降，请在后台线程中批量加载版本元数据(metaData，注：一般查询数据库获得)，只有这样，才能确保当你想加载图片的时候，这些值是可用的。\n\n如果这些方法都失败了，比如，你不能改变标识符，也不能跟踪一个合理的版本号。你还可以使用`diskCacheStrategy()`和`DiskCacheStrategy.NONE.`来完全关闭磁盘缓存。\n\n---------\n\n## 配置\n\n### 懒加载配置\n从Glide3.5开始，你可以使用`GlideModule`接口来懒加载配置Glide以及注册组件（如`ModelLoaders`)，这些配置将会在第一个Glide请求发起的时候被调用。\n\n### 创建一个GlideModule\n为了使用和注册GlideModule，首先需要实现该接口，加入你的配置和组件。\n\n```java\npackage com.mypackage; \n \npublic class MyGlideModule implements GlideModule { \n    @Override public void applyOptions(Context context, GlideBuilder builder) {\n        // Apply options to the builder here. \n    } \n \n    @Override public void registerComponents(Context context, Glide glide) {\n        // register ModelLoaders here. \n    } \n} \n```\n\n然后，添加你的实现类到`proguard.cfg`文件中，让你的module可以被反射调用到。这个性能开支很少，因为每个module只会在Glide第一次请求的时候实例化一次。\n\n```xml\n-keepnames class com.mypackage.MyGlideModule\n# or more generally:\n#-keep public class * implements com.bumptech.glide.module.GlideModule\n```\n\n最后，添加meta-data标记到`AndroidManifest.xml`，那样Glide才能找到它。\n\n```xml\n<manifest ...>\n    <!-- ... permissions -->\n    <application ...>\n        <meta-data\n            android:name=\"com.mypackage.MyGlideModule\"\n            android:value=\"GlideModule\" />\n        <!-- ... activities and other components -->\n    </application>\n</manifest>\n```\n\n你可以实现任意个`GlideModule`，但是每一个都要添加到`proguard.cfg`，而且每一个GlideModule都要在manifest有自己的meta-data标记。\n\n### Library工程\nLibrary工程可能含有一个或多个`GlideModule`。当我们使用Gradle（或者任何支持manifest合并的构建工具）构建app时，如果我们所依赖的Library工程的manifest中含有module，那么这些module会自动并入到app中。如果构建工具不支持manifest合并，那么这些library工程中的module必须手动添加到你app的manifest中。\n\n### GlideModule冲突\n虽然Glide允许每个app注册多个`Glidemodule`，但是不会以某种特定的顺序调用这些module。所以，如果你的app中多个`GlideModules`或者依赖的library工程中有多个`GlideModules`，你必须负责避免他们之间的冲突。\n如果冲突不可避免，app应该定义自己的默认module，这个module需要手动解决这些冲突，提供所有Library工程所需要的依赖。使用Gradle的开发者，或者使用manifest合并的开发者，可以通过下面的标签来排除冲突的module。\n\n```xml\n<meta-data android:name=”com.mypackage.MyGlideModule” tools:node=”remove” />\n```\n\n### 全局配置\n你可以配置一些作用于所有请求的全局性配置项。请使用`GlideModule#applyOptions`方法中（注：作为参数）提供给你的`GlideBuilder`来配置。本节代码示例中的`builder`就是一个GlideModule对象。\n\n### 磁盘缓存\n你可以使用`GlideBuilder`的`setDiskCache()`方法设置磁盘缓存的位置、大小（最大值）。你也可以使用`DiskCacheAdapter`彻底关闭缓存，或者自己实现`DiskCache`接口来换掉默认实现。磁盘缓存由`DiskCache.Factory`接口的实例在后台线程中创建，使用后台线程可以避免在严格模式中出现问题。\nGlide默认使用`InternalCacheDiskCacheFactory`类建立磁盘缓存。这个内部缓存工厂（internal cache factory）会把磁盘缓存放到应用程序的内部缓存目录中，并且设置最大空间是250MB，使用内部缓存的目录而不是SD卡的外部目录意味着其他应用程序无法访问到你下载的图片。具体请查看Android的[存储选项相关文档](http://developer.android.com/intl/zh-cn/guide/topics/data/data-storage.html#filesInternal)。\n\n#### 大小\n使用`InternalCacheDiskCacheFactory`设置磁盘缓存大小\n\n```java\nbuilder.setDiskCache(\n  new InternalCacheDiskCacheFactory(context, yourSizeInBytes));\n```\n\n#### 位置\n也可以设置磁盘缓存位置\n你可以使用`InternalCacheDiskCacheFactory `来把你的磁盘缓存放到应用程序私有的内部存储目录中：\n\n```java\nbuilder.setDiskCache(\n  new InternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));\n```\n还可以用`ExternalCacheDiskCacheFactory `来把你的磁盘缓存放到sd卡的公共缓存目录上。\n\n```java\nbuilder.setDiskCache(\n  new ExternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));\n```\n如果你想用其他自定义的路径，可以用`DiskLruCacheFactory`类的构造函数来实现。\n\n```java\n// If you can figure out the folder without I/O: \n// Calling Context and Environment class methods usually do I/O. \nbuilder.setDiskCache( \n  new DiskLruCacheFactory(getMyCacheLocationWithoutIO(), yourSizeInBytes)); \n \n// In case you want to specify a cache folder (\"glide\"): \nbuilder.setDiskCache( \n  new DiskLruCacheFactory(getMyCacheLocationWithoutIO(), \"glide\", yourSizeInBytes)); \n \n// In case you need to query the file system while determining the folder: \nbuilder.setDiskCache(new DiskLruCacheFactory(new CacheDirectoryGetter() { \n    @Override public File getCacheDirectory() {\n        return getMyCacheLocationBlockingIO(); \n    } \n}), yourSizeInBytes); \n```\n注意：请牢记，写死任何值都不是个好主意，尤其是目录的路径，因为自Android4.2开始，支持单设备多用户。\n\n如果你想完全控制缓存的创建，可以自己实现`DiskCache.Factory `接口，使用`DiskLruCacheWrapper`可以在你想要的位置创建一个新的缓存。\n\n```java\nbuilder.setDiskCache(new DiskCache.Factory() { \n    @Override public DiskCache build() { \n        File cacheLocation = getMyCacheLocationBlockingIO();\n        cacheLocation.mkdirs();\n        return DiskLruCacheWrapper.get(cacheLocation, yourSizeInBytes);\n    } \n}); \n```\n\n### 内存缓存和缓存池\n`GlideBuilder`类允许你设置内存缓存大小，而且可以实现自定义的`MemoryCache`和`BitmapPool`。\n\n#### 大小\n默认大小是由`MemorySizeCalculator`类决定的。MemorySizeCalculator类会考虑该设备的屏幕大小、可用内存来计算出一个合理的默认值。如果你想调整这个默认值，请构建自己的实例。\n\n```java\nMemorySizeCalculator calculator = new MemorySizeCalculator(context);\nint defaultMemoryCacheSize = calculator.getMemoryCacheSize();\nint defaultBitmapPoolSize = calculator.getBitmapPoolSize();\n```\n如果你想在应用的某个阶段动态调整Glide的内存占用，你可以选择一个`MemoryCategory`并使用`setMemoryCategory()`方法传入Glide中：\n\n```java\nGlide.get(context).setMemoryCategory(MemoryCategory.HIGH);\n```\n\n#### 内存缓存\nGlide的内存缓存会在内存中持有资源，它的作用是，我们可以不进行IO操作而快速获得可用资源。\n你可以使用`GlideBuilder`的`setMemoryCache()`方法设置大小，或者设置你关于内存缓存的自定义实现（自定义类）。`LruResourceCache`类是Glide的默认实现。你可以通过`LruResourceCache`的构造函数来配置内存占用的bytes的最大值。\n\n```java\nbuilder.setMemoryCache(new LruResourceCache(yourSizeInBytes));\n```\n\n#### Bitmap池\nGlide的Bitmap池主要作用是，可以让各种尺寸的Bitmap被复用，可以可观地减少由垃圾回收引起的内存抖动。在解码图片时，需要给像素数组分配空间，这会触发垃圾回收。\n你可以使用`GlideBuilder`的`setBitmapPool()`方法设置大小，或者设置你关于Bitmap池的自定义实现，`LruBitmapPool`类是Glide的默认实现。LruBitmapPool类使用了LRU算法维护最近最常使用的Bitmap的尺寸。你可以通过`LruBitmapPool`的构造函数配置内存占用的bytes的最大值。\n\n```java\nbuilder.setBitmapPool(new LruBitmapPool(sizeInBytes));\n```\n\n### Bitmap格式\n`GlideBuilder` 类也允许你配置一个App全局使用的Bitmap的Config属性。\nGlide默认使用RGB_565，因为它每个像素只需要2bytes（16bit）的空间，它仅需要高质量图片（既系统默认的`ARGB_8888 `）一半的内存空间。但是，这对于某些图片这可能会出现『条带』的问题，而且它也不支持透明度。\n如果在你的应用中『条带』是一个重要的问题，或者你需要尽可能好的图片质量，你可以使用`GlideBuilder`的`setDecodeFormat`方法设置DecodeFormat.ALWAYS_ARGB_8888作为首选配置。\n\n```java\nbuilder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);\n```\n\n---------\n\n## 自定义目标（Targets）\n除了可以加载图像，视频剧照，gif动画到View中，你还可以加载他们到实现了Target接口的自定义目标中。\n\n### SimpleTarget\n如果你只是想加载一个Bitmap，并不想直接展示给用户而是有一些特殊用途，比如在通知栏中显示或者作为头像上传。\nGlide也可以做到。\nSimpleTarget为Target接口提供了大部分的默认实现。你可以专注于处理加载的结果。\n为了使用SimpleTarget，你需要在它的构造函数中提供你要加载的资源的宽和高（单位像素），你还需要实现` onResourceReady(T resource, GlideAnimation animation)`方法。\n一个典型的使用SimpleTarget的例子如下：\n\n```java\nint myWidth = 512;\nint myHeight = 384;\n \nGlide.with(yourApplicationContext)) \n    .load(youUrl) \n    .asBitmap() \n    .into(new SimpleTarget<Bitmap>(myWidth, myHeight) {\n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            // Do something with bitmap here. \n        } \n    }; \n```\n\n#### 一些警告\n正常情况下，你加载一个资源会把他们放到view中。当你的Activity或者Fragment被pause或者destroy时，Glide会暂停或取消加载，确保你不会加载那些根本不会显示的资源。\n可是当我们使用SimpleTarget的时候，这可能并不是我们希望的行为。所以，当你调用`Glide.with(context)`的时候，你可以传入Application的context，而不是传入Activity或者Fragment。\n此外，考虑到长时间的加载操作可能导致内存泄漏，请考虑使用静态内部类，而不是匿名内部类。\n\n### ViewTarget\n如果你想加载一个图片到View中，但是你想观察或者覆盖Glide的默认行为。你可以覆盖ViewTarget或者它的子类。\n当你想让Glide来获取view的的大小，但是由自己来启动动画和设置资源到view中，ViewTarget是个不错的选择。如果你要加载一个图片到ImageView之外的自定义view中，那么ImageViewTarget或者它的子类就不能满足你的要求，此时继承ViewTarget就特别合适。\n你可以静态的定义一个ViewTarget的子类，或者传递一个匿名内部类到你的加载调用里：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .into(new ViewTarget<YourViewClass, GlideDrawable>(yourViewObject) {\n        @Override\n        public void onResourceReady(GlideDrawable resource, GlideAnimation anim) {\n            YourViewClass myView = this.view;\n            // Set your resource on myView and/or start your animation here.\n        }\n    });\n```\n注意，如果你想指定加载Bitmap还是GifDrawable，请在`.load(yourUrl)`调用后面直接添加`.asBitmap()`或者`.asGif()`，同时将ViewTarget的类型参数`GlideDrawable`换成对应加载的类型。\n为了更多控制，你也可以在Target实现`LifecycleListener`回调，`onStart()`、`onStop()`或者`onDestroy()`会和你view所在的fragment的生命周期保持同步。\n\n### 覆盖默认行为\n如果你只想观察不想修改Glide的默认行为，你可以继承任何一个Glide对ImageViewTargets的默认实现。\n\n* GlideDrawableImageViewTarget - 默认的Target，用于正常的加载和`asGif()`。\n* BitmapImageViewTarget - 当使用`asBitmap()`加载时，使用的默认Target。\n\n只有你在每个方法里面调用`super()`，将会保留默认的行为，同时还可以添加一些你希望的功能。\n\n例如，想要生成一个[调色板](http://chris.banes.me/2014/07/04/palette-preview/)，你可以这样做。\n\n```java\nGlide.with(yourFragment) \n    .load(yourUrl) \n    .asBitmap() \n    .into(new BitmapImageViewTarget(yourImageView)) { \n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            super.onResourceReady(bitmap, anim);\n            Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() {  \n                @Override \n                public void onGenerated(Palette palette) {\n                    // Here's your generated palette \n                } \n            }); \n        } \n    }); \n```\n虽然这个例子还不错，但是，通常情况下，我不推荐用这个方式生成调色板。请查看Glide的 `ResourceTranscoder` 接口和`.transcode()`方法，考虑返回一个包含Bitmap和调色板的自定义资源。调色板可在在后台线程生成。？？？？？更多内容会在以后推出。。。\n\n---------\n\n## 调试和错误处理\nGlide在加载过程中出现异常默认情况下不会打日志。Glide为你提供了两种方式查看和处理这些异常。\n\n### 调试\n仅仅为了查看异常的话，你可以为`GenericRequest`类打开Debug日志。这个类处理所有媒体资源的加载响应（response）。你可以在命令行里运行：\n\n```xml\nadb shell setprop log.tag.GenericRequest DEBUG\n```\n想要包括详细的请求时序信息，你可以把`DEBUG`缓存`VERBOSE`。\n\n关闭日志使用：\n\n```xml\nadb shell setprop log.tag.GenericRequest ERROR\n```\n\n### 调试[工作流](https://docs.google.com/drawings/d/1KyOJkNd5Dlm8_awZpftzW7KtqgNR6GURvuF6RfB210g/edit)\n为了查看内部引擎（engine）如何以及何时查找到资源，你可以打开日志：\n\n```xml\nadb shell setprop log.tag.Engine VERBOSE\nadb shell setprop log.tag.EngineJob VERBOSE\nadb shell setprop log.tag.DecodeJob VERBOSE\n```\n打开这个有助于你找出为什么某个资源没有从内存缓存中加载，为什么请求再次从外部的url下载数据。这也可以帮助你了解：如果想命中磁盘缓存，什么样的参数需要匹配。启用`DecodeJob`日志也可以帮助你去定位自定义transformation/decoder/encoder相关的问题。\n\n### 监听请求-RequestListener\n虽然启用debug日志很简单，但是只有在你可以连接到设备时才能这样干。为了把Glide集成到已有的更专业的错误日志系统。你可以使用`RequestListener`类的`onException()`。当请求失败时，该方法会告知你导致失败的`异常`(Exception)，如果解码器（Decoder）不能从数据中解析出任何有用的信息，Exception也可能传`null`。你可以使用`listener()`API传一个你的监听器（listener）到每一个请求中。\n请确保`onException()`返回`false`，以免覆盖了Glide的默认错误处理行为（例如，它默认会通知`Target`这个error）。\n这是一个快速调试的例子：\n\n```java\n// example usage: .listener(new LoggingListener<String, GlideDrawable>()) \npublic class LoggingListener<T, R> implements RequestListener<T, R> {\n    @Override public boolean onException(Exception e, Object model, Target target, boolean isFirstResource) {\n        android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT,\n                \"onException(%s, %s, %s, %s)\", e, model, target, isFirstResource), e);\n        return false; \n    } \n    @Override public boolean onResourceReady(Object resource, Object model, Target target, boolean isFromMemoryCache, boolean isFirstResource) {\n        android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT,\n                \"onResourceReady(%s, %s, %s, %s, %s)\", resource, model, target, isFromMemoryCache, isFirstResource));\n        return false; \n    } \n} \n```\n**确保发版前移除相关代码**\n\n### 更多日志\n这个列表是给3.6.0版本用的，可能不完整。\n\n```xml\ncd .../android-sdk/platform-tools\nadb shell setprop log.tag.AnimatedGifEncoder VERBOSE\nadb shell setprop log.tag.AssetUriFetcher VERBOSE\nadb shell setprop log.tag.BitmapEncoder VERBOSE\nadb shell setprop log.tag.BufferedIs VERBOSE\nadb shell setprop log.tag.ByteArrayPool VERBOSE\nadb shell setprop log.tag.CacheLoader VERBOSE\nadb shell setprop log.tag.ContentLengthStream VERBOSE\nadb shell setprop log.tag.DecodeJob VERBOSE\nadb shell setprop log.tag.DiskLruCacheWrapper VERBOSE\nadb shell setprop log.tag.Downsampler VERBOSE\nadb shell setprop log.tag.Engine VERBOSE\nadb shell setprop log.tag.EngineRunnable VERBOSE\nadb shell setprop log.tag.GenericRequest VERBOSE\nadb shell setprop log.tag.GifDecoder VERBOSE\nadb shell setprop log.tag.GifEncoder VERBOSE\nadb shell setprop log.tag.GifHeaderParser VERBOSE\nadb shell setprop log.tag.GifResourceDecoder VERBOSE\nadb shell setprop log.tag.Glide VERBOSE\nadb shell setprop log.tag.ImageHeaderParser VERBOSE\nadb shell setprop log.tag.ImageVideoDecoder VERBOSE\nadb shell setprop log.tag.IVML VERBOSE\nadb shell setprop log.tag.LocalUriFetcher VERBOSE\nadb shell setprop log.tag.LruBitmapPool VERBOSE\nadb shell setprop log.tag.MediaStoreThumbFetcher VERBOSE\nadb shell setprop log.tag.MemorySizeCalculator VERBOSE\nadb shell setprop log.tag.PreFillRunner VERBOSE\nadb shell setprop log.tag.ResourceLoader VERBOSE\nadb shell setprop log.tag.RMRetriever VERBOSE\nadb shell setprop log.tag.StreamEncoder VERBOSE\nadb shell setprop log.tag.TransformationUtils VERBOSE\n```\n\n---------\n\n## 使用Glide下载自定义大小的图片\n开发者可以通过Glide的ModelLoader接口获得图片大小，并根据这个大小来加载一个合适尺寸的图片url。\n使用合适尺寸的图片可以节约带宽，设备的存储空间，还可以提升app性能。\n2014年的Google I/O app团队写了一篇关于如何使用ModelLoader接口调整加载的图片大小的文章。请在GitHub上查看 [I/O app的源码](https://github.com/google/iosched/blob/master/doc/IMAGES.md)。\n为了实现自定义的ModelLoader来通过http/https下载图片，可以继承BaseGlideUrlLoader这个类\n\n```java\npublic interface MyDataModel { \n    public String buildUrl(int width, int height);\n}  \n \npublic class MyUrlLoader extends BaseGlideUrlLoader<MyDataModel> { \n    @Override \n    protected String getUrl(MyDataModel model, int width, int height) {\n        // Construct the url for the correct size here. \n        return model.buildUrl(width, height);\n    } \n} \n```\n\n然后，你就可以使用自定义的ModelLoader来加载图片了，其他的事情会自动完成：\n\n```java\nGlide.with(yourFragment)\n    .using(new MyUrlLoader())\n    .load(yourModel)\n    .into(yourView);\n```\n\n如果你想避免调用`.using(new  MyUrlLoader())`，你可以实现一个自定义的`ModelLoaderFactory`，并在`GlideModule`中注册它。\n\n```java\npublic class MyGlideModule implements GlideModule { \n    ... \n    @Override \n    public void registerComponents(Context context, Glide glide) {\n        glide.register(MyDataModel.class, InputStream.class, \n            new MyUrlLoader.Factory()); \n    } \n} \n```\n\n注册ModelLoaderFactory之后，你就不用调用`.using()`了：\n\n```java\nGlide.with(yourFragment)\n    .load(yourModel)\n    .into(yourView);\n```\n\n其他的例子，关于如何使用自定义ModelLoader加载各种尺寸的图片，请查看[Flicker示例应用](https://github.com/bumptech/glide/blob/master/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java)，和[Giphy示例应用](https://github.com/bumptech/glide/blob/master/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java)。\n\n---------\n\n## 集成（Integration）库-Glide与其他库整合\n\n### 介绍\n\n####什么是集成库（Integration Library）\nGlide包括一系列小巧可配置的集成库，这些库可以让Glide与外部的库相结合。现在集成库可以使Glide支持Volley和OkHttp的http/https请求。\n\n我们坚信，您所选择的客户端媒体库既不应该决定你在你的应用程序中使用的网络库，也不需要你仅仅为了加载图像额外添加网络库。集成库和Glide的ModelLoader系统，允许开发人员对所有网络请求使用统一的网络库。\n\n#### 为什么没有XXX库的实现\n因为我们还没有为这个库写集成库。OkHttp和Volley是十分流行的库，许多开发者都使用，但是，我们不是排斥其他库，如果你写了其他库的`ModelLoader`并且打算开源，我们很乐意看到这样的提交请求（pull request）。\n\n#### 我如何依赖一个集成库呢？\n依赖任何的集成库需要两g个步骤。\n\n1. 添加相应的继承库的Maven/Gradle/jar依赖，因为作为可选项的集成库并不包含在glide的jar依赖中。\n2. 确保app包含了集成库的GlideModule，具体内容看[配置wiki](https://github.com/bumptech/glide/wiki/Configuration)部分。对于Glide集成库的具体说明见下面。\n\n#### 我应当选择哪个版本？\n集成库的版本跟随着Glide的release版本。但是多了一个不同的数字。确保选择与所依赖的Glide对应的集成库。在[release页](https://github.com/bumptech/glide/releases)查看.\n网络库有自己的版本号。继承库会依赖的库就是你在Maven/Gradle中指定的库。你可以通过版本号来指定具体依赖的网络库。？？\n\n### Volley\nVolley是一个Http库，可以使Android上的网络请求更简单，更快速。\n\n#### Gradle中使用Volley\n\n```java\ndependencies {\n    compile 'com.github.bumptech.glide:volley-integration:1.3.1@aar'\n    //compile 'com.mcxiaoke.volley:library:1.0.8'\n}\n```\n集成库的`GlideModule`会自动合并到你app的manifest中。\n\n#### Maven中是Volley\n\n```xml\n<dependency>\n    <groupId>com.github.bumptech.glide</groupId>\n    <artifactId>volley-integration</artifactId>\n    <version>1.3.1</version>\n    <type>aar</type>\n</dependency>\n<dependency>\n    <groupId>com.mcxiaoke.volley</groupId>\n    <artifactId>library</artifactId>\n    <version>1.0.8</version>\n    <type>aar</type>\n</dependency>\n\n```\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### 手动添加Volley\n从[release页](https://github.com/bumptech/glide/releases)下载[glide-volley-integration-<version>.jar ](https://github.com/bumptech/glide/releases/download/v3.6.1/glide-volley-integration-1.3.1.jar)。并添加到你app的编译路径中(compile classpath)。\n\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### Volley的Manifest\n如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加`GlideModule`的metadata标签到`AndroidManifest.xml`中。\n\n```xml\n<meta-data\n    android:name=\"com.bumptech.glide.integration.volley.VolleyGlideModule\"\n    android:value=\"GlideModule\" />\n```\n\n#### Volley的混淆设置\n无论使用什么编译系统，不要混淆`VolleyGlideModule`类，它需要被反射来实例化。添加下面的代码到`proguard.cfg`文件（或者查看“通用部分”）。\n\n```java\n-keep class com.bumptech.glide.integration.volley.VolleyGlideModule\n```\n\n### OkHttp\nOKHttp是一个高效且易于使用的Http客户端。\n\n#### Gradle中使用OkHttp\n\n```java\ndependencies {\n    compile 'com.github.bumptech.glide:okhttp-integration:1.3.1@aar'\n    //compile 'com.squareup.okhttp:okhttp:2.2.0'\n}\n```\n集成库的`GlideModule`会自动合并到你app的manifest中。\n\n#### Maven中是OkHttp\n\n```xml\n<dependency>\n    <groupId>com.github.bumptech.glide</groupId>\n    <artifactId>okhttp-integration</artifactId>\n    <version>1.3.1</version>\n    <type>aar</type>\n</dependency>\n<!--\n<dependency>\n    <groupId>com.squareup.okhttp</groupId>\n    <artifactId>okhttp</artifactId>\n    <version>2.2.0</version>\n    <type>jar</type>\n</dependency>\n-->\n\n```\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### 手动添加OkHttp\n从[release页](https://github.com/bumptech/glide/releases)下载[glide-okhttp-integration-<version>.jar ](https://github.com/bumptech/glide/releases/download/v3.6.1/glide-okhttp-integration-1.3.1.jar)。并添加到你app的编译路径中(compile classpath)。\n\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### OkHttp的Manifest\n如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加`GlideModule`的metadata标签到`AndroidManifest.xml`中。\n\n```xml\n<meta-data\n    android:name=\"com.bumptech.glide.integration.okhttp.OkHttpGlideModule\"\n    android:value=\"GlideModule\" />\n```\n\n#### OkHttp的混淆设置\n无论使用什么编译系统，不要混淆`OkHttpGlideModule`类，它需要被反射来实例化。添加下面的代码到`proguard.cfg`文件（或者查看“通用部分”）。\n\n```java\n-keep class com.bumptech.glide.integration.okhttp.OkHttpGlideModule\n```\n\n### 更多选项\n\n#### 通用的混淆配置\n你也可以使用下面的配置来避免混淆所有的`GlideModule`。\n\n```java\n-keep public class * implements com.bumptech.glide.module.GlideModule\n```\n这种方式有其他的好处，当修改集成库或者自定义集成库的行为时，不需要修改。当你添加或者移动其他module的时候，也不需要修改什么。\n\n#### 覆盖默认的行为\n如果默认配置无法满足你，所有的集成库还有一些额外的选项。比如添加重试行为，请查看集成库的`GlideModule`的源码（位于[/integration/<lib>/src/main/java/<package>](https://github.com/bumptech/glide/tree/3.0/integration)）了解默认的注册做了些什么。你可以通过在自定义的`GlideModule`中修改参数为`UrlLoader.Factory`类来改变默认行为。\n当你要覆盖默认行为时，请确保自定义的`GlideModule`被注册，且默认的GlideModule被排除在外。排除GlideModule可能是从manifest中移除相应的的metadata，或者使用jar包依赖代替aar依赖。关于`GlideModule`的更多信息请查看[配置的wiki页](https://github.com/bumptech/glide/wiki/Configuration)\\\n\n---------\n\n## 在后台线程中加载和缓存\n为了使后台加载资源和与媒体交互更加容易，除了`Glide.with(fragment).load(url).into(view)`这个API外，Glide还提供了额外两个API。\n\n* `downloadOnly(int, int)`\n* `into(int, int)`\n\n### downloadOnly方法\nGlide的`downloadOnly(int, int)`方法允许你把图片bytes下载到磁盘缓存中，以便以后获取使用。你可以在UI线程异步地调用`downloadOnly()`，也可以在后台线程同步的使用。但是，注意他们的参数有些不同，异步API的参数是`Target`，同步api的参数是宽和高的整数值。\t\n为了在后台线程下载图片，你必须使用同步方法\n\n```java\nFutureTarget<File> future = Glide.with(applicationContext)\n    .load(yourUrl)\n    .downloadOnly(500, 500);\nFile cacheFile = future.get();\n```\n当future返回时，图片的bytes数据就在缓存中可用了。一种典型的情况是，你使用`downloadOnly()`API只是为了确保数据下载到了磁盘上。一般情况下，虽然你有权访问底层的缓存文件，但是你不需要直接和它交互。\n而是，当你想要获取这个图片时，你只要像平常加载图片时那样调用就行，**只有一点不同**：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .diskCacheStrategy(DiskCacheStrategy.ALL)\n    .into(yourView);\n```\n通过传入 `DiskCacheStrategy.ALL`或者`DiskCacheStrategy.SOURCE`，确保Glide可以使用你通过`downloadOnly()`下载的数据。\n\n### into方法\n如果你想在一个**后台线程**与一张已经解码的图片交互。你可以使用这个版本的`into()`方法来返回一个`FutureTarget`。例如，获取一张中心剪裁后的500*500像素的图片：\n\n```java\nBitmap myBitmap = Glide.with(applicationContext)\n    .load(yourUrl)\n    .asBitmap()\n    .centerCrop()\n    .into(500, 500)\n    .get()\n```\n虽然`into(int, int)`方法在后台线程中很有效，但是，你不能把它用在主线程中。即使这个同步方法在你的主线程中不会抛出异常，调用get()也会阻塞主线程。会使你的APP性能变差，反应迟钝。\n\n---------\n\n## Glide中的资源复用\n\n### 为什么 - 资源复用的作用\nGlide通过复用资源避免不必要的内存分配。Dalvik虚拟机（在Lollipop之前）有两种基本的垃圾回收方式，`GC_CONCURRENT` 和`GC_FOR_ALLOC`。每次`GC_CONCURRENT`会阻塞主线程5ms。由于每次操作的时间少于16ms（1帧的时间），`GC_CONCURRENT`并不会引起掉帧。相反的是`GC_FOR_ALLOC`，他会停止所有操作，阻塞主线程125+ms，事实上，GC_FOR_ALLOC总是会让你的app掉很多帧。尤其是在滑动时，导致明显的卡顿。\n很不幸，即使只是分配适当的空间（比如16kb的buffer）Dalvik表现的也很糟糕。不断的小内存分配，或者一次大的内存分配（比如说bitmap），将会引起GC_FOR_ALLOC。因此，你分配内存的越多，你会遇到垃圾回收器阻塞应用的情况就越多，应用掉帧就越严重。\n通过适度复用大块资源，Glide可以避免内存抖动，减少垃圾回收器阻塞app的次数。\n\n### 怎么做 - Glide是如何复用资源\nGlide的资源复用策略比较宽松。这意味着，当Glide认为该资源可以被安全的复用时，才有几率去复用它，并不需要开发者在每个request后面去手动释放资源。\n\n#### 标志-哪些资源可复用\nGlide有两个简单的标志来识别可复用的资源。\n\n1. `Glide.clear()` \n\n\t在`View`或者`Target`上调用`clear()`方法都表示，Glide要取消加载，可以安全地把Target占用的所有资源（Bitmap，bytes数组等）放入资源池中（pool）。用户可以在任何时候安全地手动调用`clear()`方法，但是典型情况下，我们不需要这样做，看第二条。\n\n2. View或者Target的复用 \n\n\t当用户把图片加载到一个已经存在的View或者Target上时（注：确切的说是调用`into(xxx)`方法之后），Glide会先调用`clear()`清空该View/Target上的加载请求并复用已经显示过的资源。因此，如果你的ListView或者RecyclerView中的view使用了复用机制（注：如ViewHolder），那么Glide会自动为他们缓存资源和管理加载请求。\n \n#### 引用计数\n如果两个请求指向同一个资源，为了避免额外的工作，Glide会把单个资源分配给他们。这就导致一个问题，当Glide得知某个资源不被某个调用者使用，这并不表示它不会被其他调用者使用。为了避免回收调依旧被使用的资源，Glide使用引用计数来跟踪资源。\n当把资源提供给View/Target时，该资源的引用计数加1，当清空View/Target时，引用计数减1。当引用计数为0时，Glide会回收资源，并把它的内容放回可用内存池中。\n\n#### 放入缓存池\nGlide的Resource API有一个`recycle()`方法，当Glide认为资源不再被引用时，会调用该方法，资源会放入缓存池中。\n\nGlide提供的BitmapPool接口可以让Resource获取`Bitmap`和复用Bitmap对象。Glide的BitmapPool可以通过Glide单例获得：\n\n```java\nGlide.get(context).getBitmapPool();\n```\nResourceDecoder可以返回Resource的任何实现。所有，开发者可以实现他们自己的Resource和ResourceDecoder来自定义地缓存一些特有类型的数据。\n同样地，开发者如果想更多地控制Bitmap缓存，可以实现自己的BitmapPool，然后通过GlideModule配置到Glide中。\n\n### 常见的错误\n不幸的是，缓存池设计使我们很难判断开发者是否误用了资源或者bitmap。但是，在Glide中有两个主要的现象会暗示你某些地方可能出了问题。\n\n#### 现象\n\n1. `Cannot draw a recycled Bitmap`\n\n\tGlide有个固定大小的Bitmap池。当Bitmap不再被复用（注：不是使用，区分使用和复用），会从池中移走。Glide会调用[`recycle()`](http://developer.android.com/reference/android/graphics/Bitmap.html#recycle())（注：指的是Bitmap真正的recycle，不是Resource类的recycle）。你告诉Glide放心地回收某个Bitmap，但是，你的应用不小心还持有这个Bitmap的引用，应用程序可能会绘制这个Bitmap，导致崩溃。\n\n2. View在多张图片之间闪烁，或者同样的图片出现在多个View中\n\n\t如果一张图片被放入BitmapPool中多次。或者虽然一张图片被放入了pool中，但是某个View依然持有这个图的引用，与此同时，另一张图片被解析成了Bitmap（注：此Bitmap正好用了刚才那张图片的控件来存放解析后的数据）。如果发生这种事情，Bitmap的内容就会被换成了新的图片内容。此时，View依然尝试着绘制Bitmap，导致原来的View中显示了一张新的图片！\n\n#### 原因\n这些问题主要有两个原因：\n\n1. 尝试加载两个不同的资源到同一Target中\n\n\t在Glide中，没有安全的方法来加载多个资源到单一的Target中。开发者可以使用`thumbnail()`来加载一系列资源到到某个Target中，但是对于每一个加载的资源来说，只有在下一个`onResourceReady()`被调用前，它的引用才是安全的。\n开发者如果想加载多个资源到同一个View中，可以使用两个独立的Target。为了确保加载过程不相互取消，开发者要么不使用ViewTarget的子类，要么在继承ViewTarget时，复写`setRequest()` 和 `getRequest()`，不要使用tag来存储Request。（注：需要一个demo)\n\n\t**译者注：对于同一个view，调用两次Glide.xxx.into(view)，第二次调用会先清空第一个加载的图片（出现空白），再去下载新的图片，如果想要在第二张图片下载下来之前依旧显示之前的，需要一些技巧**\n2. 加载一个资源放入到Target，然后清空或者复用了Target，但是依然引用这这个资源。\n\n\t最简单的避免这个错误的方法是在`onLoadCleared()`方法中把所有对资源对象的引用置null。一般情况下，加载一个Bitmap，然后引用它的Target是安全的。不安全的是，你清空了这个Target，却依然引用着这个Bitmap。\n\t\n---------\n\t\n## 使用快照\n\n### 关于快照\n对于那些不想等待Glide下个正式版本而愿意尝鲜的用户，我们在[Sonatype](https://travis-ci.org/bumptech/glide)上部署了这个库的快照。\n每一次我们push代码待GitHub的master分支，[travis-ci](https://oss.sonatype.org/content/repositories/snapshots/)会构建Glide.如果构建成功，会自动部署最新版本的库到Sonatype上。\n和Glide主库一样，每个Intergration库也有自己的快照，如果你使用快照版本的Glide库，请使用快照版本的Intergration库，反之依然。\n\n### 获取快照\nSonatype的快照库和其他的maven库一样，提供jar，maven，gradle等版本。\n\n#### Jar\nJar包可以直接从Sonatype上下载，再次检查一下日期，确保使用最新版本\n\n#### Gradle\n在仓库列表中添加快照仓库\n\n```xml\nrepositories {\n  jcenter()\n  maven {\n    url 'http://oss.sonatype.org/content/repositories/snapshots'\n  }\n}\n```\n然后修改依赖为快照版本\n\n```xml\ndependencies {\n  compile \"com.github.bumptech.glide:glide:3.6.0-SNAPSHOT\"\n  compile \"com.github.bumptech.glide:okhttp-integration:1.3.0-SNAPSHOT\"\n}\n```\n\n#### Maven\n这种方式没有测试，直接从[StackOverflow](http://stackoverflow.com/questions/7715321/how-to-download-snapshot-version-from-maven-snapshot-repository)拷过来的。欢迎改进下面的内容。\n添加下面的代码到`~/.m2/settings.xml`中：\n\n```xml\n<profiles>\n  <profile>\n     <id>allow-snapshots</id>\n     <activation><activeByDefault>true</activeByDefault></activation>\n     <repositories>\n       <repository>\n         <id>snapshots-repo</id>\n         <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n         <releases><enabled>false</enabled></releases>\n         <snapshots><enabled>true</enabled></snapshots>\n       </repository>\n     </repositories>\n   </profile>\n</profiles>\n```\n修改依赖为快照版本\n\n```xml\n<dependency>\n  <groupId>com.github.bumptech.glide</groupId>\n  <artifactId>glide</artifactId>\n  <version>3.6.0-SNAPSHOT</version>\n</dependency>\n<dependency>\n  <groupId>com.github.bumptech.glide</groupId>\n  <artifactId>okhttp-integration</artifactId>\n  <version>1.3.0-SNAPSHOT</version>\n</dependency>\n```\n\n---------\n\n## 图形变换\n\n### 默认的变换\nGlide包含两种默认的图像变换方式，fitCenter和centerCrop。如果开发者需要其他类型的变换，可以考虑使用这个独立的[变换库](https://github.com/wasabeef/glide-transformations)。\n\n#### Fit center\nFitCenter会按原始比例缩小图像，使图像可以在放在给定的区域内。FitCenter会尽可能少地缩小图片，使宽或者高的一边等于给定的值。另外一边会等于或者小于给定值。\nFitCenter和Android中的ScaleType.FIT_CENTER效果相同。\n#### CenterCrop\nCenterCrop会按原始比例缩小图像，使宽或者高的一边等于给定的值，另外一边会等于或者大于给定值。CenterCrop会裁剪掉多余部分。\nCenterCrop和Android中的ScaleType.CENTER_CROP效果相同。\n\n### 使用\nfit center效果使用`.fitCenter()`：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .fitCenter()\n    .into(yourView);\n```\ncenter crop效果使用`.centerCrop()`：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    . centerCrop()\n    .into(yourView);\n```\n如果你只加载Bitmap或者Gif，也可以使用这个变换：\n\n```java\n// For Bitmaps:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .centerCrop()\n    .into(yourView);\n\n// For gifs:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asGif()\n    .fitCenter()\n    .into(yourView);\n```\n当在类型间转码时，也可以使用这些变换。例如，获取一个变形后的jpeg图片的bytes数据：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .toBytes()\n    .centerCrop()\n    .into(new SimpleTarget<byte[]>(...) { ... });\n\n```\n自定义变换\n除了两个内置的变换，你还可以自定义变换。\n最简单的方式是继承BitmapTransformation。\n\n```java\nprivate static class MyTransformation extends BitmapTransformation { \n \n    public MyTransformation(Context context) {\n       super(context);\n    } \n \n    @Override \n    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, \n            int outWidth, int outHeight) {\n       Bitmap myTransformedBitmap = ... // apply some transformation here. \n       return myTransformedBitmap; \n    } \n \n    @Override \n    public String getId() {\n        // Return some id that uniquely identifies your transformation. \n        return \"com.example.myapp.MyTransformation\"; \n    } \n} \n```\n\n之后一就可以用同样的方式使用它。使用`.transform(...)`代替`.fitCenter()`/`.centerCrop()`。\n\n```java\n// For the default drawable type:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .transform(new MyTransformation(context))\n    .into(yourView);\n\n// For Bitmaps:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .transform(new MyTransformation(context))\n    .into(yourView);\n\n// For Gifs:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asGif()\n    .transform(new MyTransformation(context))\n    .into(yourView);\n```\n\n#### 调整大小\n你可能注意到上面的例子没有传入具体的尺寸，那么，Transformation中的尺寸是如何获得的呢？\nTransformation中的尺寸就是View或者Target的大小。Glide会根据布局文件中的weight，match_parent或者具体值算出View的大小。，当你拥有View/Target的具体大小，又拥有原始图片的大小时，就可以通过图像变换生成一个正确大小的图片。\n如果你想指定View/Target的自定义大小，可以使用`.override(int, int)`方法，如果你想加载一个图片有其他用途，而不是显示在View中，请查看『自定义Target』章节。\n\n#### Bitmap 复用\n为了减少垃圾回收，你可以说使用`BitmapPool`接口来释放不想要的Bitmap或者复用存在的Bitmap。一个在Transformation中复用Bitmap典型的例子：从pool中获取Bitmap，使用该Bitmap创建一个`Canvas`，然后使用Matrix/Paint/Shader来变换图像并绘制到Canvas上。为了正确有效地在Transformation中复用Bitmap中，遵守下面的规则：\n\n1. 在`transform()`不要回收资源或者把Bitmap放入Bitmap池中，这些步骤会自动完成。\n2. 如果你从Bitmap池中获取了多个Bitmap，或者没有使用从pool中获取到的Bitmap，确保把多余的Bitmap放回pool中。\n3. 如果你的Trasformation并没有替换调原始图片（比如，图片已经满足你要求的大小，直接返回了），请在`transform()`方法中返回原始的资源或者Bitmap。\n\n一个典型的用法如下：\n\n```java\nprotected Bitmap transform(BitmapPool bitmapPool, Bitmap original, int width, int height) {\n    Bitmap result = bitmapPool.get(width, height, Bitmap.Config.ARGB_8888);\n    // If no matching Bitmap is in the pool, get will return null, so we should allocate. \n    if (result == null) {\n        // Use ARGB_8888 since we're going to add alpha to the image. \n        result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n    } \n    // Create a Canvas backed by the result Bitmap. \n    Canvas canvas = new Canvas(result);\n    Paint paint = new Paint();\n    paint.setAlpha(128);\n    // Draw the original Bitmap onto the result Bitmap with a transformation. \n    canvas.drawBitmap(original, 0, 0, paint);\n    // Since we've replaced our original Bitmap, we return our new Bitmap here. Glide will \n    // will take care of returning our original Bitmap to the BitmapPool for us.  \n    return result;\n} \n```","source":"_posts/Android图片库-Glide.md","raw":"title: Android图片库--Glide Wiki中文翻译\ndate: 2016-01-24 10:32:54\ndescription: Glide Wiki中文翻译。Glide是一个Android图片库，确切地说应当叫『媒体框架』。支持图片、Gif、原生视频的加载。使用简单，性能优异，Google推荐。\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n## 序\n最近，一直在捣鼓Glide这个图片库，确切地说应当叫『媒体框架』。为了支持Gif播放，项目中使用Glide代替了Universal Image Loader。起初我们打算使用的是Fresco方案，最终因为Lib体积的问题放弃。万万没想到apk的size这么敏感，国外很多推广服务是根据apk体积收费的，3M一个门槛，5M一个门槛。fresco引入之后即使proguard、7zip，apk的大小也增加了1M+，多平台的os库是个大头，第三世界的应用市场还不支持按平台分发😓。。\nGlide的使用还不深入，仅仅停留在Api的范畴，为了解决bug，跟踪了代码，也是云里雾里。不得不说，Glide源码的设计十分NB，面向接口的理念贯彻的很彻底，是一个学习设计的好demo。\nGitHub的README作为最简单的入门足够了，但是遇到具体问题还是要理解一些设计思想的，GitHub上的Wiki有一份不错的文档，可惜木有中文，正好学习的过程中翻译一下。\n在看wiki之前，可以先看这两篇中文入门，了解基本的用法。\n\n* [Google推荐的图片加载库Glide介绍](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html)\n* [Glide 一个专注于平滑滚动的图片加载和缓存库](http://www.jianshu.com/p/4a3177b57949)\n\n本文是基于**Glide 3.x**正式版的[Wiki文档](https://github.com/bumptech/glide/wiki)的翻译（原文编辑日期：2015-2-9,18 revision，当时Glide release的版本号3.6.1）。\n\n翻译Version：1.1 简单校对\n\n### 名词解释\nGlide中有一部分单词，我不知道用什么中文可以确切的表达出含义，用英文单词可能在行文中更加合适，还有一些词在Glide中有特别的含义，我理解的可能也不深入，这里先记录一下。\n\n* View： 一般情况下，指Android中的View及其子类控件（包括自定义的），尤其指ImageView。这些控件可在上面绘制Drawable\n* Target： Glide中重要的概念，目标。它即可以指封装了一个View的Target（ViewTarget），也可以不包含View（SimpleTarget）。\n* Drawable： 指Android中的Drawable类或者它的子类，如BitmapDrawable等。或者Glide中基础Drawable实现的自定义Drawable（如GifDrawable等）\n* Request - 加载请求，可以是网络请求或者其他任何下载图片的请求，也是Glide中的一个类。\n* Model：数据源的提供者，如Url，文件路径等，可以从model中获取InputStream。\n* Signature：签名，可以唯一地标识一个对象。\n* recycle()：Glide中Resource类有此方法，表示该资源不被引用，可以放入池中（此时并没有释放空间）。Android中Bitmap也有此方法，表示释放Bitmap占用的内存。\n\n## 目录\n* 主目录\n* 缓存机制与缓存失效\n* Glide配置\n* 自定义Target\n* 调试与错误处理\n* 使用Glide下载自定义大小图片\n* 集成库-与其他库相整合\n* 在后台线程中加载与缓存数据\n* Glide中的资源复用\n* 快照（Snapshots）\n* 图形变换（Transformations）\n\n---------\n\n## 主目录\n\n### 报告问题\n如果你有任何问题，可以在[Github上提出](https://github.com/bumptech/glide/issues/)或者发送e-mail到我们的[邮件列表](https://groups.google.com/forum/#!forum/glidelibrary)，也可以在IRC(Internet Relay Chat 网络中继聊天？)频道上联系我们：[irc.freenode.net#glide-library](http://webchat.freenode.net/?channels=glide-library)。\n\n### 3.0版本的新特性\n* 支持Gif动画的解码 - 与加载图片相同，只要调用Glide.with(...).load(...)，如果你加载的图片是一个可以播放的Gif，Glide会自动加载它并显示在一个自定义的Drawable上（注：GifDrawable）。此外，你还可以控制的更多，比如\n\n\t```java\n// 你想加载Gif为一张静态图片\nGlide.with(context).load(...).asBitmap()。\n// 或者你想只有加载对象是Gif时才能加载成功\nGlide.with(context).load(...).asGif()。\n```\n\n* 本地视频播放技术 - 除了解码Gif，Glide也能解码你设备上的视频（video）。使用方法和加载gif相同，Glide支持所有Android可以直接解码的视频。\n* 支持缩略图加载 - 有时我们希望减少用户等待的时间又不想牺牲图片的质量，我们可以同时加载多张图片到一个View中，先加载缩略图（只有view的1/10大小），然后再加载一个完整的图像覆盖在上面。使用下面的代码\n\n\t```java\nGlide.with(yourFragment).load(yourUrl).thumbnail(0.1f).into(yourView)\n```\n\n当然，你也可以传入一个Request到`.thumbnail()`函数中作为参数。\n\n* 与生命周期集成 - 加载请求现在会自动在onStop中暂停在，onStart中重新开始。为了节约电量，Gif动画也会在onStop中自动暂停。此外，当设备的连接状态改变时，所有失败的请求会自动重试，确保Glide不会因为临时性的连接问题，导致请求永远失败。\n* 转码 - 除了解码资源，Glide的`.toBytes()`和`.transcode()`方法允许你在后台正常地获取、解码、变换一张图片。你还可以在这些调用中把图片转码成更有用的格式，比如，上传一张大小为250*250像素的用户头像的图片bytes数据，代码如下\n\n\t```java\nGlide.with(context)\n    .load(“/user/profile/photo/path”)\n    .asBitmap()\n    .toBytes()\n    .centerCrop()\n    .into(new SimpleTarget<byte[]>(250, 250) {\n        @Override\n        public void onResourceReady(byte[] data, GlideAnimation anim) {\n            // 在此处，将bytes数据传入后台线程，再上传他们\n        }\n    });\n```\n\n* 动画 - Glide3.X支持『淡入淡出』动画（`.crossFade()`）和view的属性动画(`.animate(ViewPropertyAnimation.Animator)`)。此外，还有Glide2.0就支持的android view动画。\n* 支持 OkHttp 和 Volley - 现在你可以选择用OkHttp、Volley或者默认的HttpUrlConnection作为网络栈。OkHttp和Volley可以通过添加对应的集成库(integration library)和注册相应的`ModelLoaderFactory`来引入。具体查看ReadMe文件。\n* 其他 - 可以使用Drawable对象作为加载中的占位图、请求优先级、覆盖自定义宽和高、可以缓存变换后的缩略图或者缓存原始文件\n\n### 从2.0迁移到3.0\n* 将所有的`Glide.load()`替换为`Glide.with([fragment/activity/context]).load()`。\n* 将所有的自定义的加载调用`Glide.load(url).into(new SimpleTarget(){ ... }).with(context)`替换成`Glide.with(context).load(url).into(new SimpleTarget(width, height) { ... })`。\n\n### 特性\n除了3.0引入的新功能，Glide继承了2.0的所有功能：\n\n* 后台图片加载\n* 如果你使用了listview的复用机制，那么Glide会自动取消作业（job）\n* 内存和磁盘缓存\n* Bitmap和资源池来减少内存抖动\n* 支持任意的图像变换\n\n---------\n\n## 缓存机制与缓存失效\n缓存失效是一个比较复杂的话题，理想情况下，你尽可能不要考虑这个问题。这一节主要是让你粗略的了解一下Glide中cache的key是如何生成，以及提供一些关于如何合理利用缓存的提示。\n### 缓存的key\n`DiskCacheStrategy.RESULT`磁盘缓存策略（注：我们配置的一种磁盘缓存策略）使用的key由以下四个主要部分组成：\n\n* DataFetcher的方法`getId()`返回的字符。典型地，DataFetcher仅仅返回由数据Model的`toString()`方法得到的值。所以，如果Model是一个**URL**，那么会返回URL的字符串，如果Model是是一个文件，那么会返回文件的**路径**。。。\n* 宽和高。如果你调用过override(width,height)方法，那么就是是它传入的值。没有调用过，默认是通过**Target**的`getSize()`方法获得这个值。\n* 各种编码器、解码器的`getId()`方法返回的字符串。这些编码器、解码器用于加载和缓存你的图片。仅有哪些堆bytes数据有影响的编码器、解码器才会有这些`id`值。比如，你只有一个将bytes数据写入磁盘的编码器，那么它就没有id值，因为不管怎样它都不会修改数据。\n* 可选地，你可以为图片加载提供签名(Signature)，请看下面的缓存失效部分。\n\n所有的这些key，以特定的顺序计算出hash值，并将这个值作为保存图片到磁盘上的唯一且安全的文件名。\n\n### 缓存失效\n由于文件名是hash值，没有简便的方式删除磁盘上某个特定url或者文件路径的所有缓存文件。如果仅仅缓存原文件，问题可能还比较简单，但是Glide会缓存缩略图，各种变换后的图片，所有这些缓存都会产生新文件。跟踪和删除所有文件是十分困难的。\n\n### 自定义缓存失效\n通常情况下改变缓存的标志（key）是困难的。Glide提供了`signature()`API来混入其他数据，帮助你控制缓存的key。签名（Signature）对于多媒体或者有版本信息的内容来说都很有用。\n\n* 媒体库内容 - 对于媒体库内容，你可以使用Glide的`MediaStoreSignature`类作为签名， MediaStoreSignature类允许你混入文件修改时间、mime类型、媒体库的方向(orientation?)这些值作为缓存的key，这三个值足以让你可靠的捕捉到任何修改和更新，使你可以缓存媒体库的缩略图.?\n* 文件 - 你可以使用`StringSignature`混入文件修改时间\n* url - 虽然使url失效最好的方式是当内容变化时，服务器修改url并更新客户端，但是你也可以用`StringSignature`混入任意的元数据（如版本号）来使缓存失效。\n\n使用String Signature加载数据很简单：\n\n```java\nGlide.with(yourFragment)\n    .load(yourFileDataModel)\n    .signature(new StringSignature(yourVersionMetadata))\n    .into(yourImageView);\n```\n\n媒体库Signature可以直接使用从MeidaStore(注：一个android api）获得的数据\n\n```java\nGlide.with(fragment)\n    .load(mediaStoreUri)\n    .signature(new MediaStoreSignature(mimeType, dateModified, orientation))\n    .into(view);\n```\n\n你还可以通过实现`key`接口来自定义签名，确保实现了`equals()`, `hashCode()`和`updateDiskCacheKey()`这几个方法\n\n```java\npublic class IntegerVersionSignature implements Key {\n    private int currentVersion;\n \n    public IntegerVersionSignature(int currentVersion) {\n         this.currentVersion = currentVersion;\n    } \n \n    @Override \n    public boolean equals(Object o) {\n        if (o instanceof IntegerVersionSignature) {\n            IntegerVersionSignature other = (IntegerVersionSignature) o;\n            return currentVersion = other.currentVersion;\n        } \n        return false; \n    } \n \n    @Override \n    public int hashCode() { \n        return currentVersion;\n    } \n \n    @Override \n    public void updateDiskCacheKey(MessageDigest md) {\n        messageDigest.update(ByteBuffer.allocate(Integer.SIZE).putInt(signature).array());\n    } \n} \n```\n请牢记：为了避免性能下降，请在后台线程中批量加载版本元数据(metaData，注：一般查询数据库获得)，只有这样，才能确保当你想加载图片的时候，这些值是可用的。\n\n如果这些方法都失败了，比如，你不能改变标识符，也不能跟踪一个合理的版本号。你还可以使用`diskCacheStrategy()`和`DiskCacheStrategy.NONE.`来完全关闭磁盘缓存。\n\n---------\n\n## 配置\n\n### 懒加载配置\n从Glide3.5开始，你可以使用`GlideModule`接口来懒加载配置Glide以及注册组件（如`ModelLoaders`)，这些配置将会在第一个Glide请求发起的时候被调用。\n\n### 创建一个GlideModule\n为了使用和注册GlideModule，首先需要实现该接口，加入你的配置和组件。\n\n```java\npackage com.mypackage; \n \npublic class MyGlideModule implements GlideModule { \n    @Override public void applyOptions(Context context, GlideBuilder builder) {\n        // Apply options to the builder here. \n    } \n \n    @Override public void registerComponents(Context context, Glide glide) {\n        // register ModelLoaders here. \n    } \n} \n```\n\n然后，添加你的实现类到`proguard.cfg`文件中，让你的module可以被反射调用到。这个性能开支很少，因为每个module只会在Glide第一次请求的时候实例化一次。\n\n```xml\n-keepnames class com.mypackage.MyGlideModule\n# or more generally:\n#-keep public class * implements com.bumptech.glide.module.GlideModule\n```\n\n最后，添加meta-data标记到`AndroidManifest.xml`，那样Glide才能找到它。\n\n```xml\n<manifest ...>\n    <!-- ... permissions -->\n    <application ...>\n        <meta-data\n            android:name=\"com.mypackage.MyGlideModule\"\n            android:value=\"GlideModule\" />\n        <!-- ... activities and other components -->\n    </application>\n</manifest>\n```\n\n你可以实现任意个`GlideModule`，但是每一个都要添加到`proguard.cfg`，而且每一个GlideModule都要在manifest有自己的meta-data标记。\n\n### Library工程\nLibrary工程可能含有一个或多个`GlideModule`。当我们使用Gradle（或者任何支持manifest合并的构建工具）构建app时，如果我们所依赖的Library工程的manifest中含有module，那么这些module会自动并入到app中。如果构建工具不支持manifest合并，那么这些library工程中的module必须手动添加到你app的manifest中。\n\n### GlideModule冲突\n虽然Glide允许每个app注册多个`Glidemodule`，但是不会以某种特定的顺序调用这些module。所以，如果你的app中多个`GlideModules`或者依赖的library工程中有多个`GlideModules`，你必须负责避免他们之间的冲突。\n如果冲突不可避免，app应该定义自己的默认module，这个module需要手动解决这些冲突，提供所有Library工程所需要的依赖。使用Gradle的开发者，或者使用manifest合并的开发者，可以通过下面的标签来排除冲突的module。\n\n```xml\n<meta-data android:name=”com.mypackage.MyGlideModule” tools:node=”remove” />\n```\n\n### 全局配置\n你可以配置一些作用于所有请求的全局性配置项。请使用`GlideModule#applyOptions`方法中（注：作为参数）提供给你的`GlideBuilder`来配置。本节代码示例中的`builder`就是一个GlideModule对象。\n\n### 磁盘缓存\n你可以使用`GlideBuilder`的`setDiskCache()`方法设置磁盘缓存的位置、大小（最大值）。你也可以使用`DiskCacheAdapter`彻底关闭缓存，或者自己实现`DiskCache`接口来换掉默认实现。磁盘缓存由`DiskCache.Factory`接口的实例在后台线程中创建，使用后台线程可以避免在严格模式中出现问题。\nGlide默认使用`InternalCacheDiskCacheFactory`类建立磁盘缓存。这个内部缓存工厂（internal cache factory）会把磁盘缓存放到应用程序的内部缓存目录中，并且设置最大空间是250MB，使用内部缓存的目录而不是SD卡的外部目录意味着其他应用程序无法访问到你下载的图片。具体请查看Android的[存储选项相关文档](http://developer.android.com/intl/zh-cn/guide/topics/data/data-storage.html#filesInternal)。\n\n#### 大小\n使用`InternalCacheDiskCacheFactory`设置磁盘缓存大小\n\n```java\nbuilder.setDiskCache(\n  new InternalCacheDiskCacheFactory(context, yourSizeInBytes));\n```\n\n#### 位置\n也可以设置磁盘缓存位置\n你可以使用`InternalCacheDiskCacheFactory `来把你的磁盘缓存放到应用程序私有的内部存储目录中：\n\n```java\nbuilder.setDiskCache(\n  new InternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));\n```\n还可以用`ExternalCacheDiskCacheFactory `来把你的磁盘缓存放到sd卡的公共缓存目录上。\n\n```java\nbuilder.setDiskCache(\n  new ExternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));\n```\n如果你想用其他自定义的路径，可以用`DiskLruCacheFactory`类的构造函数来实现。\n\n```java\n// If you can figure out the folder without I/O: \n// Calling Context and Environment class methods usually do I/O. \nbuilder.setDiskCache( \n  new DiskLruCacheFactory(getMyCacheLocationWithoutIO(), yourSizeInBytes)); \n \n// In case you want to specify a cache folder (\"glide\"): \nbuilder.setDiskCache( \n  new DiskLruCacheFactory(getMyCacheLocationWithoutIO(), \"glide\", yourSizeInBytes)); \n \n// In case you need to query the file system while determining the folder: \nbuilder.setDiskCache(new DiskLruCacheFactory(new CacheDirectoryGetter() { \n    @Override public File getCacheDirectory() {\n        return getMyCacheLocationBlockingIO(); \n    } \n}), yourSizeInBytes); \n```\n注意：请牢记，写死任何值都不是个好主意，尤其是目录的路径，因为自Android4.2开始，支持单设备多用户。\n\n如果你想完全控制缓存的创建，可以自己实现`DiskCache.Factory `接口，使用`DiskLruCacheWrapper`可以在你想要的位置创建一个新的缓存。\n\n```java\nbuilder.setDiskCache(new DiskCache.Factory() { \n    @Override public DiskCache build() { \n        File cacheLocation = getMyCacheLocationBlockingIO();\n        cacheLocation.mkdirs();\n        return DiskLruCacheWrapper.get(cacheLocation, yourSizeInBytes);\n    } \n}); \n```\n\n### 内存缓存和缓存池\n`GlideBuilder`类允许你设置内存缓存大小，而且可以实现自定义的`MemoryCache`和`BitmapPool`。\n\n#### 大小\n默认大小是由`MemorySizeCalculator`类决定的。MemorySizeCalculator类会考虑该设备的屏幕大小、可用内存来计算出一个合理的默认值。如果你想调整这个默认值，请构建自己的实例。\n\n```java\nMemorySizeCalculator calculator = new MemorySizeCalculator(context);\nint defaultMemoryCacheSize = calculator.getMemoryCacheSize();\nint defaultBitmapPoolSize = calculator.getBitmapPoolSize();\n```\n如果你想在应用的某个阶段动态调整Glide的内存占用，你可以选择一个`MemoryCategory`并使用`setMemoryCategory()`方法传入Glide中：\n\n```java\nGlide.get(context).setMemoryCategory(MemoryCategory.HIGH);\n```\n\n#### 内存缓存\nGlide的内存缓存会在内存中持有资源，它的作用是，我们可以不进行IO操作而快速获得可用资源。\n你可以使用`GlideBuilder`的`setMemoryCache()`方法设置大小，或者设置你关于内存缓存的自定义实现（自定义类）。`LruResourceCache`类是Glide的默认实现。你可以通过`LruResourceCache`的构造函数来配置内存占用的bytes的最大值。\n\n```java\nbuilder.setMemoryCache(new LruResourceCache(yourSizeInBytes));\n```\n\n#### Bitmap池\nGlide的Bitmap池主要作用是，可以让各种尺寸的Bitmap被复用，可以可观地减少由垃圾回收引起的内存抖动。在解码图片时，需要给像素数组分配空间，这会触发垃圾回收。\n你可以使用`GlideBuilder`的`setBitmapPool()`方法设置大小，或者设置你关于Bitmap池的自定义实现，`LruBitmapPool`类是Glide的默认实现。LruBitmapPool类使用了LRU算法维护最近最常使用的Bitmap的尺寸。你可以通过`LruBitmapPool`的构造函数配置内存占用的bytes的最大值。\n\n```java\nbuilder.setBitmapPool(new LruBitmapPool(sizeInBytes));\n```\n\n### Bitmap格式\n`GlideBuilder` 类也允许你配置一个App全局使用的Bitmap的Config属性。\nGlide默认使用RGB_565，因为它每个像素只需要2bytes（16bit）的空间，它仅需要高质量图片（既系统默认的`ARGB_8888 `）一半的内存空间。但是，这对于某些图片这可能会出现『条带』的问题，而且它也不支持透明度。\n如果在你的应用中『条带』是一个重要的问题，或者你需要尽可能好的图片质量，你可以使用`GlideBuilder`的`setDecodeFormat`方法设置DecodeFormat.ALWAYS_ARGB_8888作为首选配置。\n\n```java\nbuilder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);\n```\n\n---------\n\n## 自定义目标（Targets）\n除了可以加载图像，视频剧照，gif动画到View中，你还可以加载他们到实现了Target接口的自定义目标中。\n\n### SimpleTarget\n如果你只是想加载一个Bitmap，并不想直接展示给用户而是有一些特殊用途，比如在通知栏中显示或者作为头像上传。\nGlide也可以做到。\nSimpleTarget为Target接口提供了大部分的默认实现。你可以专注于处理加载的结果。\n为了使用SimpleTarget，你需要在它的构造函数中提供你要加载的资源的宽和高（单位像素），你还需要实现` onResourceReady(T resource, GlideAnimation animation)`方法。\n一个典型的使用SimpleTarget的例子如下：\n\n```java\nint myWidth = 512;\nint myHeight = 384;\n \nGlide.with(yourApplicationContext)) \n    .load(youUrl) \n    .asBitmap() \n    .into(new SimpleTarget<Bitmap>(myWidth, myHeight) {\n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            // Do something with bitmap here. \n        } \n    }; \n```\n\n#### 一些警告\n正常情况下，你加载一个资源会把他们放到view中。当你的Activity或者Fragment被pause或者destroy时，Glide会暂停或取消加载，确保你不会加载那些根本不会显示的资源。\n可是当我们使用SimpleTarget的时候，这可能并不是我们希望的行为。所以，当你调用`Glide.with(context)`的时候，你可以传入Application的context，而不是传入Activity或者Fragment。\n此外，考虑到长时间的加载操作可能导致内存泄漏，请考虑使用静态内部类，而不是匿名内部类。\n\n### ViewTarget\n如果你想加载一个图片到View中，但是你想观察或者覆盖Glide的默认行为。你可以覆盖ViewTarget或者它的子类。\n当你想让Glide来获取view的的大小，但是由自己来启动动画和设置资源到view中，ViewTarget是个不错的选择。如果你要加载一个图片到ImageView之外的自定义view中，那么ImageViewTarget或者它的子类就不能满足你的要求，此时继承ViewTarget就特别合适。\n你可以静态的定义一个ViewTarget的子类，或者传递一个匿名内部类到你的加载调用里：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .into(new ViewTarget<YourViewClass, GlideDrawable>(yourViewObject) {\n        @Override\n        public void onResourceReady(GlideDrawable resource, GlideAnimation anim) {\n            YourViewClass myView = this.view;\n            // Set your resource on myView and/or start your animation here.\n        }\n    });\n```\n注意，如果你想指定加载Bitmap还是GifDrawable，请在`.load(yourUrl)`调用后面直接添加`.asBitmap()`或者`.asGif()`，同时将ViewTarget的类型参数`GlideDrawable`换成对应加载的类型。\n为了更多控制，你也可以在Target实现`LifecycleListener`回调，`onStart()`、`onStop()`或者`onDestroy()`会和你view所在的fragment的生命周期保持同步。\n\n### 覆盖默认行为\n如果你只想观察不想修改Glide的默认行为，你可以继承任何一个Glide对ImageViewTargets的默认实现。\n\n* GlideDrawableImageViewTarget - 默认的Target，用于正常的加载和`asGif()`。\n* BitmapImageViewTarget - 当使用`asBitmap()`加载时，使用的默认Target。\n\n只有你在每个方法里面调用`super()`，将会保留默认的行为，同时还可以添加一些你希望的功能。\n\n例如，想要生成一个[调色板](http://chris.banes.me/2014/07/04/palette-preview/)，你可以这样做。\n\n```java\nGlide.with(yourFragment) \n    .load(yourUrl) \n    .asBitmap() \n    .into(new BitmapImageViewTarget(yourImageView)) { \n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            super.onResourceReady(bitmap, anim);\n            Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() {  \n                @Override \n                public void onGenerated(Palette palette) {\n                    // Here's your generated palette \n                } \n            }); \n        } \n    }); \n```\n虽然这个例子还不错，但是，通常情况下，我不推荐用这个方式生成调色板。请查看Glide的 `ResourceTranscoder` 接口和`.transcode()`方法，考虑返回一个包含Bitmap和调色板的自定义资源。调色板可在在后台线程生成。？？？？？更多内容会在以后推出。。。\n\n---------\n\n## 调试和错误处理\nGlide在加载过程中出现异常默认情况下不会打日志。Glide为你提供了两种方式查看和处理这些异常。\n\n### 调试\n仅仅为了查看异常的话，你可以为`GenericRequest`类打开Debug日志。这个类处理所有媒体资源的加载响应（response）。你可以在命令行里运行：\n\n```xml\nadb shell setprop log.tag.GenericRequest DEBUG\n```\n想要包括详细的请求时序信息，你可以把`DEBUG`缓存`VERBOSE`。\n\n关闭日志使用：\n\n```xml\nadb shell setprop log.tag.GenericRequest ERROR\n```\n\n### 调试[工作流](https://docs.google.com/drawings/d/1KyOJkNd5Dlm8_awZpftzW7KtqgNR6GURvuF6RfB210g/edit)\n为了查看内部引擎（engine）如何以及何时查找到资源，你可以打开日志：\n\n```xml\nadb shell setprop log.tag.Engine VERBOSE\nadb shell setprop log.tag.EngineJob VERBOSE\nadb shell setprop log.tag.DecodeJob VERBOSE\n```\n打开这个有助于你找出为什么某个资源没有从内存缓存中加载，为什么请求再次从外部的url下载数据。这也可以帮助你了解：如果想命中磁盘缓存，什么样的参数需要匹配。启用`DecodeJob`日志也可以帮助你去定位自定义transformation/decoder/encoder相关的问题。\n\n### 监听请求-RequestListener\n虽然启用debug日志很简单，但是只有在你可以连接到设备时才能这样干。为了把Glide集成到已有的更专业的错误日志系统。你可以使用`RequestListener`类的`onException()`。当请求失败时，该方法会告知你导致失败的`异常`(Exception)，如果解码器（Decoder）不能从数据中解析出任何有用的信息，Exception也可能传`null`。你可以使用`listener()`API传一个你的监听器（listener）到每一个请求中。\n请确保`onException()`返回`false`，以免覆盖了Glide的默认错误处理行为（例如，它默认会通知`Target`这个error）。\n这是一个快速调试的例子：\n\n```java\n// example usage: .listener(new LoggingListener<String, GlideDrawable>()) \npublic class LoggingListener<T, R> implements RequestListener<T, R> {\n    @Override public boolean onException(Exception e, Object model, Target target, boolean isFirstResource) {\n        android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT,\n                \"onException(%s, %s, %s, %s)\", e, model, target, isFirstResource), e);\n        return false; \n    } \n    @Override public boolean onResourceReady(Object resource, Object model, Target target, boolean isFromMemoryCache, boolean isFirstResource) {\n        android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT,\n                \"onResourceReady(%s, %s, %s, %s, %s)\", resource, model, target, isFromMemoryCache, isFirstResource));\n        return false; \n    } \n} \n```\n**确保发版前移除相关代码**\n\n### 更多日志\n这个列表是给3.6.0版本用的，可能不完整。\n\n```xml\ncd .../android-sdk/platform-tools\nadb shell setprop log.tag.AnimatedGifEncoder VERBOSE\nadb shell setprop log.tag.AssetUriFetcher VERBOSE\nadb shell setprop log.tag.BitmapEncoder VERBOSE\nadb shell setprop log.tag.BufferedIs VERBOSE\nadb shell setprop log.tag.ByteArrayPool VERBOSE\nadb shell setprop log.tag.CacheLoader VERBOSE\nadb shell setprop log.tag.ContentLengthStream VERBOSE\nadb shell setprop log.tag.DecodeJob VERBOSE\nadb shell setprop log.tag.DiskLruCacheWrapper VERBOSE\nadb shell setprop log.tag.Downsampler VERBOSE\nadb shell setprop log.tag.Engine VERBOSE\nadb shell setprop log.tag.EngineRunnable VERBOSE\nadb shell setprop log.tag.GenericRequest VERBOSE\nadb shell setprop log.tag.GifDecoder VERBOSE\nadb shell setprop log.tag.GifEncoder VERBOSE\nadb shell setprop log.tag.GifHeaderParser VERBOSE\nadb shell setprop log.tag.GifResourceDecoder VERBOSE\nadb shell setprop log.tag.Glide VERBOSE\nadb shell setprop log.tag.ImageHeaderParser VERBOSE\nadb shell setprop log.tag.ImageVideoDecoder VERBOSE\nadb shell setprop log.tag.IVML VERBOSE\nadb shell setprop log.tag.LocalUriFetcher VERBOSE\nadb shell setprop log.tag.LruBitmapPool VERBOSE\nadb shell setprop log.tag.MediaStoreThumbFetcher VERBOSE\nadb shell setprop log.tag.MemorySizeCalculator VERBOSE\nadb shell setprop log.tag.PreFillRunner VERBOSE\nadb shell setprop log.tag.ResourceLoader VERBOSE\nadb shell setprop log.tag.RMRetriever VERBOSE\nadb shell setprop log.tag.StreamEncoder VERBOSE\nadb shell setprop log.tag.TransformationUtils VERBOSE\n```\n\n---------\n\n## 使用Glide下载自定义大小的图片\n开发者可以通过Glide的ModelLoader接口获得图片大小，并根据这个大小来加载一个合适尺寸的图片url。\n使用合适尺寸的图片可以节约带宽，设备的存储空间，还可以提升app性能。\n2014年的Google I/O app团队写了一篇关于如何使用ModelLoader接口调整加载的图片大小的文章。请在GitHub上查看 [I/O app的源码](https://github.com/google/iosched/blob/master/doc/IMAGES.md)。\n为了实现自定义的ModelLoader来通过http/https下载图片，可以继承BaseGlideUrlLoader这个类\n\n```java\npublic interface MyDataModel { \n    public String buildUrl(int width, int height);\n}  \n \npublic class MyUrlLoader extends BaseGlideUrlLoader<MyDataModel> { \n    @Override \n    protected String getUrl(MyDataModel model, int width, int height) {\n        // Construct the url for the correct size here. \n        return model.buildUrl(width, height);\n    } \n} \n```\n\n然后，你就可以使用自定义的ModelLoader来加载图片了，其他的事情会自动完成：\n\n```java\nGlide.with(yourFragment)\n    .using(new MyUrlLoader())\n    .load(yourModel)\n    .into(yourView);\n```\n\n如果你想避免调用`.using(new  MyUrlLoader())`，你可以实现一个自定义的`ModelLoaderFactory`，并在`GlideModule`中注册它。\n\n```java\npublic class MyGlideModule implements GlideModule { \n    ... \n    @Override \n    public void registerComponents(Context context, Glide glide) {\n        glide.register(MyDataModel.class, InputStream.class, \n            new MyUrlLoader.Factory()); \n    } \n} \n```\n\n注册ModelLoaderFactory之后，你就不用调用`.using()`了：\n\n```java\nGlide.with(yourFragment)\n    .load(yourModel)\n    .into(yourView);\n```\n\n其他的例子，关于如何使用自定义ModelLoader加载各种尺寸的图片，请查看[Flicker示例应用](https://github.com/bumptech/glide/blob/master/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java)，和[Giphy示例应用](https://github.com/bumptech/glide/blob/master/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java)。\n\n---------\n\n## 集成（Integration）库-Glide与其他库整合\n\n### 介绍\n\n####什么是集成库（Integration Library）\nGlide包括一系列小巧可配置的集成库，这些库可以让Glide与外部的库相结合。现在集成库可以使Glide支持Volley和OkHttp的http/https请求。\n\n我们坚信，您所选择的客户端媒体库既不应该决定你在你的应用程序中使用的网络库，也不需要你仅仅为了加载图像额外添加网络库。集成库和Glide的ModelLoader系统，允许开发人员对所有网络请求使用统一的网络库。\n\n#### 为什么没有XXX库的实现\n因为我们还没有为这个库写集成库。OkHttp和Volley是十分流行的库，许多开发者都使用，但是，我们不是排斥其他库，如果你写了其他库的`ModelLoader`并且打算开源，我们很乐意看到这样的提交请求（pull request）。\n\n#### 我如何依赖一个集成库呢？\n依赖任何的集成库需要两g个步骤。\n\n1. 添加相应的继承库的Maven/Gradle/jar依赖，因为作为可选项的集成库并不包含在glide的jar依赖中。\n2. 确保app包含了集成库的GlideModule，具体内容看[配置wiki](https://github.com/bumptech/glide/wiki/Configuration)部分。对于Glide集成库的具体说明见下面。\n\n#### 我应当选择哪个版本？\n集成库的版本跟随着Glide的release版本。但是多了一个不同的数字。确保选择与所依赖的Glide对应的集成库。在[release页](https://github.com/bumptech/glide/releases)查看.\n网络库有自己的版本号。继承库会依赖的库就是你在Maven/Gradle中指定的库。你可以通过版本号来指定具体依赖的网络库。？？\n\n### Volley\nVolley是一个Http库，可以使Android上的网络请求更简单，更快速。\n\n#### Gradle中使用Volley\n\n```java\ndependencies {\n    compile 'com.github.bumptech.glide:volley-integration:1.3.1@aar'\n    //compile 'com.mcxiaoke.volley:library:1.0.8'\n}\n```\n集成库的`GlideModule`会自动合并到你app的manifest中。\n\n#### Maven中是Volley\n\n```xml\n<dependency>\n    <groupId>com.github.bumptech.glide</groupId>\n    <artifactId>volley-integration</artifactId>\n    <version>1.3.1</version>\n    <type>aar</type>\n</dependency>\n<dependency>\n    <groupId>com.mcxiaoke.volley</groupId>\n    <artifactId>library</artifactId>\n    <version>1.0.8</version>\n    <type>aar</type>\n</dependency>\n\n```\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### 手动添加Volley\n从[release页](https://github.com/bumptech/glide/releases)下载[glide-volley-integration-<version>.jar ](https://github.com/bumptech/glide/releases/download/v3.6.1/glide-volley-integration-1.3.1.jar)。并添加到你app的编译路径中(compile classpath)。\n\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### Volley的Manifest\n如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加`GlideModule`的metadata标签到`AndroidManifest.xml`中。\n\n```xml\n<meta-data\n    android:name=\"com.bumptech.glide.integration.volley.VolleyGlideModule\"\n    android:value=\"GlideModule\" />\n```\n\n#### Volley的混淆设置\n无论使用什么编译系统，不要混淆`VolleyGlideModule`类，它需要被反射来实例化。添加下面的代码到`proguard.cfg`文件（或者查看“通用部分”）。\n\n```java\n-keep class com.bumptech.glide.integration.volley.VolleyGlideModule\n```\n\n### OkHttp\nOKHttp是一个高效且易于使用的Http客户端。\n\n#### Gradle中使用OkHttp\n\n```java\ndependencies {\n    compile 'com.github.bumptech.glide:okhttp-integration:1.3.1@aar'\n    //compile 'com.squareup.okhttp:okhttp:2.2.0'\n}\n```\n集成库的`GlideModule`会自动合并到你app的manifest中。\n\n#### Maven中是OkHttp\n\n```xml\n<dependency>\n    <groupId>com.github.bumptech.glide</groupId>\n    <artifactId>okhttp-integration</artifactId>\n    <version>1.3.1</version>\n    <type>aar</type>\n</dependency>\n<!--\n<dependency>\n    <groupId>com.squareup.okhttp</groupId>\n    <artifactId>okhttp</artifactId>\n    <version>2.2.0</version>\n    <type>jar</type>\n</dependency>\n-->\n\n```\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### 手动添加OkHttp\n从[release页](https://github.com/bumptech/glide/releases)下载[glide-okhttp-integration-<version>.jar ](https://github.com/bumptech/glide/releases/download/v3.6.1/glide-okhttp-integration-1.3.1.jar)。并添加到你app的编译路径中(compile classpath)。\n\n请查看对应的manifest章节，了解如何添加对应的GlideModule。\n\n#### OkHttp的Manifest\n如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加`GlideModule`的metadata标签到`AndroidManifest.xml`中。\n\n```xml\n<meta-data\n    android:name=\"com.bumptech.glide.integration.okhttp.OkHttpGlideModule\"\n    android:value=\"GlideModule\" />\n```\n\n#### OkHttp的混淆设置\n无论使用什么编译系统，不要混淆`OkHttpGlideModule`类，它需要被反射来实例化。添加下面的代码到`proguard.cfg`文件（或者查看“通用部分”）。\n\n```java\n-keep class com.bumptech.glide.integration.okhttp.OkHttpGlideModule\n```\n\n### 更多选项\n\n#### 通用的混淆配置\n你也可以使用下面的配置来避免混淆所有的`GlideModule`。\n\n```java\n-keep public class * implements com.bumptech.glide.module.GlideModule\n```\n这种方式有其他的好处，当修改集成库或者自定义集成库的行为时，不需要修改。当你添加或者移动其他module的时候，也不需要修改什么。\n\n#### 覆盖默认的行为\n如果默认配置无法满足你，所有的集成库还有一些额外的选项。比如添加重试行为，请查看集成库的`GlideModule`的源码（位于[/integration/<lib>/src/main/java/<package>](https://github.com/bumptech/glide/tree/3.0/integration)）了解默认的注册做了些什么。你可以通过在自定义的`GlideModule`中修改参数为`UrlLoader.Factory`类来改变默认行为。\n当你要覆盖默认行为时，请确保自定义的`GlideModule`被注册，且默认的GlideModule被排除在外。排除GlideModule可能是从manifest中移除相应的的metadata，或者使用jar包依赖代替aar依赖。关于`GlideModule`的更多信息请查看[配置的wiki页](https://github.com/bumptech/glide/wiki/Configuration)\\\n\n---------\n\n## 在后台线程中加载和缓存\n为了使后台加载资源和与媒体交互更加容易，除了`Glide.with(fragment).load(url).into(view)`这个API外，Glide还提供了额外两个API。\n\n* `downloadOnly(int, int)`\n* `into(int, int)`\n\n### downloadOnly方法\nGlide的`downloadOnly(int, int)`方法允许你把图片bytes下载到磁盘缓存中，以便以后获取使用。你可以在UI线程异步地调用`downloadOnly()`，也可以在后台线程同步的使用。但是，注意他们的参数有些不同，异步API的参数是`Target`，同步api的参数是宽和高的整数值。\t\n为了在后台线程下载图片，你必须使用同步方法\n\n```java\nFutureTarget<File> future = Glide.with(applicationContext)\n    .load(yourUrl)\n    .downloadOnly(500, 500);\nFile cacheFile = future.get();\n```\n当future返回时，图片的bytes数据就在缓存中可用了。一种典型的情况是，你使用`downloadOnly()`API只是为了确保数据下载到了磁盘上。一般情况下，虽然你有权访问底层的缓存文件，但是你不需要直接和它交互。\n而是，当你想要获取这个图片时，你只要像平常加载图片时那样调用就行，**只有一点不同**：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .diskCacheStrategy(DiskCacheStrategy.ALL)\n    .into(yourView);\n```\n通过传入 `DiskCacheStrategy.ALL`或者`DiskCacheStrategy.SOURCE`，确保Glide可以使用你通过`downloadOnly()`下载的数据。\n\n### into方法\n如果你想在一个**后台线程**与一张已经解码的图片交互。你可以使用这个版本的`into()`方法来返回一个`FutureTarget`。例如，获取一张中心剪裁后的500*500像素的图片：\n\n```java\nBitmap myBitmap = Glide.with(applicationContext)\n    .load(yourUrl)\n    .asBitmap()\n    .centerCrop()\n    .into(500, 500)\n    .get()\n```\n虽然`into(int, int)`方法在后台线程中很有效，但是，你不能把它用在主线程中。即使这个同步方法在你的主线程中不会抛出异常，调用get()也会阻塞主线程。会使你的APP性能变差，反应迟钝。\n\n---------\n\n## Glide中的资源复用\n\n### 为什么 - 资源复用的作用\nGlide通过复用资源避免不必要的内存分配。Dalvik虚拟机（在Lollipop之前）有两种基本的垃圾回收方式，`GC_CONCURRENT` 和`GC_FOR_ALLOC`。每次`GC_CONCURRENT`会阻塞主线程5ms。由于每次操作的时间少于16ms（1帧的时间），`GC_CONCURRENT`并不会引起掉帧。相反的是`GC_FOR_ALLOC`，他会停止所有操作，阻塞主线程125+ms，事实上，GC_FOR_ALLOC总是会让你的app掉很多帧。尤其是在滑动时，导致明显的卡顿。\n很不幸，即使只是分配适当的空间（比如16kb的buffer）Dalvik表现的也很糟糕。不断的小内存分配，或者一次大的内存分配（比如说bitmap），将会引起GC_FOR_ALLOC。因此，你分配内存的越多，你会遇到垃圾回收器阻塞应用的情况就越多，应用掉帧就越严重。\n通过适度复用大块资源，Glide可以避免内存抖动，减少垃圾回收器阻塞app的次数。\n\n### 怎么做 - Glide是如何复用资源\nGlide的资源复用策略比较宽松。这意味着，当Glide认为该资源可以被安全的复用时，才有几率去复用它，并不需要开发者在每个request后面去手动释放资源。\n\n#### 标志-哪些资源可复用\nGlide有两个简单的标志来识别可复用的资源。\n\n1. `Glide.clear()` \n\n\t在`View`或者`Target`上调用`clear()`方法都表示，Glide要取消加载，可以安全地把Target占用的所有资源（Bitmap，bytes数组等）放入资源池中（pool）。用户可以在任何时候安全地手动调用`clear()`方法，但是典型情况下，我们不需要这样做，看第二条。\n\n2. View或者Target的复用 \n\n\t当用户把图片加载到一个已经存在的View或者Target上时（注：确切的说是调用`into(xxx)`方法之后），Glide会先调用`clear()`清空该View/Target上的加载请求并复用已经显示过的资源。因此，如果你的ListView或者RecyclerView中的view使用了复用机制（注：如ViewHolder），那么Glide会自动为他们缓存资源和管理加载请求。\n \n#### 引用计数\n如果两个请求指向同一个资源，为了避免额外的工作，Glide会把单个资源分配给他们。这就导致一个问题，当Glide得知某个资源不被某个调用者使用，这并不表示它不会被其他调用者使用。为了避免回收调依旧被使用的资源，Glide使用引用计数来跟踪资源。\n当把资源提供给View/Target时，该资源的引用计数加1，当清空View/Target时，引用计数减1。当引用计数为0时，Glide会回收资源，并把它的内容放回可用内存池中。\n\n#### 放入缓存池\nGlide的Resource API有一个`recycle()`方法，当Glide认为资源不再被引用时，会调用该方法，资源会放入缓存池中。\n\nGlide提供的BitmapPool接口可以让Resource获取`Bitmap`和复用Bitmap对象。Glide的BitmapPool可以通过Glide单例获得：\n\n```java\nGlide.get(context).getBitmapPool();\n```\nResourceDecoder可以返回Resource的任何实现。所有，开发者可以实现他们自己的Resource和ResourceDecoder来自定义地缓存一些特有类型的数据。\n同样地，开发者如果想更多地控制Bitmap缓存，可以实现自己的BitmapPool，然后通过GlideModule配置到Glide中。\n\n### 常见的错误\n不幸的是，缓存池设计使我们很难判断开发者是否误用了资源或者bitmap。但是，在Glide中有两个主要的现象会暗示你某些地方可能出了问题。\n\n#### 现象\n\n1. `Cannot draw a recycled Bitmap`\n\n\tGlide有个固定大小的Bitmap池。当Bitmap不再被复用（注：不是使用，区分使用和复用），会从池中移走。Glide会调用[`recycle()`](http://developer.android.com/reference/android/graphics/Bitmap.html#recycle())（注：指的是Bitmap真正的recycle，不是Resource类的recycle）。你告诉Glide放心地回收某个Bitmap，但是，你的应用不小心还持有这个Bitmap的引用，应用程序可能会绘制这个Bitmap，导致崩溃。\n\n2. View在多张图片之间闪烁，或者同样的图片出现在多个View中\n\n\t如果一张图片被放入BitmapPool中多次。或者虽然一张图片被放入了pool中，但是某个View依然持有这个图的引用，与此同时，另一张图片被解析成了Bitmap（注：此Bitmap正好用了刚才那张图片的控件来存放解析后的数据）。如果发生这种事情，Bitmap的内容就会被换成了新的图片内容。此时，View依然尝试着绘制Bitmap，导致原来的View中显示了一张新的图片！\n\n#### 原因\n这些问题主要有两个原因：\n\n1. 尝试加载两个不同的资源到同一Target中\n\n\t在Glide中，没有安全的方法来加载多个资源到单一的Target中。开发者可以使用`thumbnail()`来加载一系列资源到到某个Target中，但是对于每一个加载的资源来说，只有在下一个`onResourceReady()`被调用前，它的引用才是安全的。\n开发者如果想加载多个资源到同一个View中，可以使用两个独立的Target。为了确保加载过程不相互取消，开发者要么不使用ViewTarget的子类，要么在继承ViewTarget时，复写`setRequest()` 和 `getRequest()`，不要使用tag来存储Request。（注：需要一个demo)\n\n\t**译者注：对于同一个view，调用两次Glide.xxx.into(view)，第二次调用会先清空第一个加载的图片（出现空白），再去下载新的图片，如果想要在第二张图片下载下来之前依旧显示之前的，需要一些技巧**\n2. 加载一个资源放入到Target，然后清空或者复用了Target，但是依然引用这这个资源。\n\n\t最简单的避免这个错误的方法是在`onLoadCleared()`方法中把所有对资源对象的引用置null。一般情况下，加载一个Bitmap，然后引用它的Target是安全的。不安全的是，你清空了这个Target，却依然引用着这个Bitmap。\n\t\n---------\n\t\n## 使用快照\n\n### 关于快照\n对于那些不想等待Glide下个正式版本而愿意尝鲜的用户，我们在[Sonatype](https://travis-ci.org/bumptech/glide)上部署了这个库的快照。\n每一次我们push代码待GitHub的master分支，[travis-ci](https://oss.sonatype.org/content/repositories/snapshots/)会构建Glide.如果构建成功，会自动部署最新版本的库到Sonatype上。\n和Glide主库一样，每个Intergration库也有自己的快照，如果你使用快照版本的Glide库，请使用快照版本的Intergration库，反之依然。\n\n### 获取快照\nSonatype的快照库和其他的maven库一样，提供jar，maven，gradle等版本。\n\n#### Jar\nJar包可以直接从Sonatype上下载，再次检查一下日期，确保使用最新版本\n\n#### Gradle\n在仓库列表中添加快照仓库\n\n```xml\nrepositories {\n  jcenter()\n  maven {\n    url 'http://oss.sonatype.org/content/repositories/snapshots'\n  }\n}\n```\n然后修改依赖为快照版本\n\n```xml\ndependencies {\n  compile \"com.github.bumptech.glide:glide:3.6.0-SNAPSHOT\"\n  compile \"com.github.bumptech.glide:okhttp-integration:1.3.0-SNAPSHOT\"\n}\n```\n\n#### Maven\n这种方式没有测试，直接从[StackOverflow](http://stackoverflow.com/questions/7715321/how-to-download-snapshot-version-from-maven-snapshot-repository)拷过来的。欢迎改进下面的内容。\n添加下面的代码到`~/.m2/settings.xml`中：\n\n```xml\n<profiles>\n  <profile>\n     <id>allow-snapshots</id>\n     <activation><activeByDefault>true</activeByDefault></activation>\n     <repositories>\n       <repository>\n         <id>snapshots-repo</id>\n         <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n         <releases><enabled>false</enabled></releases>\n         <snapshots><enabled>true</enabled></snapshots>\n       </repository>\n     </repositories>\n   </profile>\n</profiles>\n```\n修改依赖为快照版本\n\n```xml\n<dependency>\n  <groupId>com.github.bumptech.glide</groupId>\n  <artifactId>glide</artifactId>\n  <version>3.6.0-SNAPSHOT</version>\n</dependency>\n<dependency>\n  <groupId>com.github.bumptech.glide</groupId>\n  <artifactId>okhttp-integration</artifactId>\n  <version>1.3.0-SNAPSHOT</version>\n</dependency>\n```\n\n---------\n\n## 图形变换\n\n### 默认的变换\nGlide包含两种默认的图像变换方式，fitCenter和centerCrop。如果开发者需要其他类型的变换，可以考虑使用这个独立的[变换库](https://github.com/wasabeef/glide-transformations)。\n\n#### Fit center\nFitCenter会按原始比例缩小图像，使图像可以在放在给定的区域内。FitCenter会尽可能少地缩小图片，使宽或者高的一边等于给定的值。另外一边会等于或者小于给定值。\nFitCenter和Android中的ScaleType.FIT_CENTER效果相同。\n#### CenterCrop\nCenterCrop会按原始比例缩小图像，使宽或者高的一边等于给定的值，另外一边会等于或者大于给定值。CenterCrop会裁剪掉多余部分。\nCenterCrop和Android中的ScaleType.CENTER_CROP效果相同。\n\n### 使用\nfit center效果使用`.fitCenter()`：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .fitCenter()\n    .into(yourView);\n```\ncenter crop效果使用`.centerCrop()`：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    . centerCrop()\n    .into(yourView);\n```\n如果你只加载Bitmap或者Gif，也可以使用这个变换：\n\n```java\n// For Bitmaps:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .centerCrop()\n    .into(yourView);\n\n// For gifs:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asGif()\n    .fitCenter()\n    .into(yourView);\n```\n当在类型间转码时，也可以使用这些变换。例如，获取一个变形后的jpeg图片的bytes数据：\n\n```java\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .toBytes()\n    .centerCrop()\n    .into(new SimpleTarget<byte[]>(...) { ... });\n\n```\n自定义变换\n除了两个内置的变换，你还可以自定义变换。\n最简单的方式是继承BitmapTransformation。\n\n```java\nprivate static class MyTransformation extends BitmapTransformation { \n \n    public MyTransformation(Context context) {\n       super(context);\n    } \n \n    @Override \n    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, \n            int outWidth, int outHeight) {\n       Bitmap myTransformedBitmap = ... // apply some transformation here. \n       return myTransformedBitmap; \n    } \n \n    @Override \n    public String getId() {\n        // Return some id that uniquely identifies your transformation. \n        return \"com.example.myapp.MyTransformation\"; \n    } \n} \n```\n\n之后一就可以用同样的方式使用它。使用`.transform(...)`代替`.fitCenter()`/`.centerCrop()`。\n\n```java\n// For the default drawable type:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .transform(new MyTransformation(context))\n    .into(yourView);\n\n// For Bitmaps:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asBitmap()\n    .transform(new MyTransformation(context))\n    .into(yourView);\n\n// For Gifs:\nGlide.with(yourFragment)\n    .load(yourUrl)\n    .asGif()\n    .transform(new MyTransformation(context))\n    .into(yourView);\n```\n\n#### 调整大小\n你可能注意到上面的例子没有传入具体的尺寸，那么，Transformation中的尺寸是如何获得的呢？\nTransformation中的尺寸就是View或者Target的大小。Glide会根据布局文件中的weight，match_parent或者具体值算出View的大小。，当你拥有View/Target的具体大小，又拥有原始图片的大小时，就可以通过图像变换生成一个正确大小的图片。\n如果你想指定View/Target的自定义大小，可以使用`.override(int, int)`方法，如果你想加载一个图片有其他用途，而不是显示在View中，请查看『自定义Target』章节。\n\n#### Bitmap 复用\n为了减少垃圾回收，你可以说使用`BitmapPool`接口来释放不想要的Bitmap或者复用存在的Bitmap。一个在Transformation中复用Bitmap典型的例子：从pool中获取Bitmap，使用该Bitmap创建一个`Canvas`，然后使用Matrix/Paint/Shader来变换图像并绘制到Canvas上。为了正确有效地在Transformation中复用Bitmap中，遵守下面的规则：\n\n1. 在`transform()`不要回收资源或者把Bitmap放入Bitmap池中，这些步骤会自动完成。\n2. 如果你从Bitmap池中获取了多个Bitmap，或者没有使用从pool中获取到的Bitmap，确保把多余的Bitmap放回pool中。\n3. 如果你的Trasformation并没有替换调原始图片（比如，图片已经满足你要求的大小，直接返回了），请在`transform()`方法中返回原始的资源或者Bitmap。\n\n一个典型的用法如下：\n\n```java\nprotected Bitmap transform(BitmapPool bitmapPool, Bitmap original, int width, int height) {\n    Bitmap result = bitmapPool.get(width, height, Bitmap.Config.ARGB_8888);\n    // If no matching Bitmap is in the pool, get will return null, so we should allocate. \n    if (result == null) {\n        // Use ARGB_8888 since we're going to add alpha to the image. \n        result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n    } \n    // Create a Canvas backed by the result Bitmap. \n    Canvas canvas = new Canvas(result);\n    Paint paint = new Paint();\n    paint.setAlpha(128);\n    // Draw the original Bitmap onto the result Bitmap with a transformation. \n    canvas.drawBitmap(original, 0, 0, paint);\n    // Since we've replaced our original Bitmap, we return our new Bitmap here. Glide will \n    // will take care of returning our original Bitmap to the BitmapPool for us.  \n    return result;\n} \n```","slug":"Android图片库-Glide","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbbn0001nac9ufn5n3n8","content":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>最近，一直在捣鼓Glide这个图片库，确切地说应当叫『媒体框架』。为了支持Gif播放，项目中使用Glide代替了Universal Image Loader。起初我们打算使用的是Fresco方案，最终因为Lib体积的问题放弃。万万没想到apk的size这么敏感，国外很多推广服务是根据apk体积收费的，3M一个门槛，5M一个门槛。fresco引入之后即使proguard、7zip，apk的大小也增加了1M+，多平台的os库是个大头，第三世界的应用市场还不支持按平台分发😓。。<br>Glide的使用还不深入，仅仅停留在Api的范畴，为了解决bug，跟踪了代码，也是云里雾里。不得不说，Glide源码的设计十分NB，面向接口的理念贯彻的很彻底，是一个学习设计的好demo。<br>GitHub的README作为最简单的入门足够了，但是遇到具体问题还是要理解一些设计思想的，GitHub上的Wiki有一份不错的文档，可惜木有中文，正好学习的过程中翻译一下。<br>在看wiki之前，可以先看这两篇中文入门，了解基本的用法。</p>\n<ul>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html\" target=\"_blank\" rel=\"external\">Google推荐的图片加载库Glide介绍</a></li>\n<li><a href=\"http://www.jianshu.com/p/4a3177b57949\" target=\"_blank\" rel=\"external\">Glide 一个专注于平滑滚动的图片加载和缓存库</a></li>\n</ul>\n<p>本文是基于<strong>Glide 3.x</strong>正式版的<a href=\"https://github.com/bumptech/glide/wiki\" target=\"_blank\" rel=\"external\">Wiki文档</a>的翻译（原文编辑日期：2015-2-9,18 revision，当时Glide release的版本号3.6.1）。</p>\n<p>翻译Version：1.1 简单校对</p>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><p>Glide中有一部分单词，我不知道用什么中文可以确切的表达出含义，用英文单词可能在行文中更加合适，还有一些词在Glide中有特别的含义，我理解的可能也不深入，这里先记录一下。</p>\n<ul>\n<li>View： 一般情况下，指Android中的View及其子类控件（包括自定义的），尤其指ImageView。这些控件可在上面绘制Drawable</li>\n<li>Target： Glide中重要的概念，目标。它即可以指封装了一个View的Target（ViewTarget），也可以不包含View（SimpleTarget）。</li>\n<li>Drawable： 指Android中的Drawable类或者它的子类，如BitmapDrawable等。或者Glide中基础Drawable实现的自定义Drawable（如GifDrawable等）</li>\n<li>Request - 加载请求，可以是网络请求或者其他任何下载图片的请求，也是Glide中的一个类。</li>\n<li>Model：数据源的提供者，如Url，文件路径等，可以从model中获取InputStream。</li>\n<li>Signature：签名，可以唯一地标识一个对象。</li>\n<li>recycle()：Glide中Resource类有此方法，表示该资源不被引用，可以放入池中（此时并没有释放空间）。Android中Bitmap也有此方法，表示释放Bitmap占用的内存。</li>\n</ul>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li>主目录</li>\n<li>缓存机制与缓存失效</li>\n<li>Glide配置</li>\n<li>自定义Target</li>\n<li>调试与错误处理</li>\n<li>使用Glide下载自定义大小图片</li>\n<li>集成库-与其他库相整合</li>\n<li>在后台线程中加载与缓存数据</li>\n<li>Glide中的资源复用</li>\n<li>快照（Snapshots）</li>\n<li>图形变换（Transformations）</li>\n</ul>\n<hr>\n<h2 id=\"主目录\"><a href=\"#主目录\" class=\"headerlink\" title=\"主目录\"></a>主目录</h2><h3 id=\"报告问题\"><a href=\"#报告问题\" class=\"headerlink\" title=\"报告问题\"></a>报告问题</h3><p>如果你有任何问题，可以在<a href=\"https://github.com/bumptech/glide/issues/\" target=\"_blank\" rel=\"external\">Github上提出</a>或者发送e-mail到我们的<a href=\"https://groups.google.com/forum/#!forum/glidelibrary\" target=\"_blank\" rel=\"external\">邮件列表</a>，也可以在IRC(Internet Relay Chat 网络中继聊天？)频道上联系我们：<a href=\"http://webchat.freenode.net/?channels=glide-library\" target=\"_blank\" rel=\"external\">irc.freenode.net#glide-library</a>。</p>\n<h3 id=\"3-0版本的新特性\"><a href=\"#3-0版本的新特性\" class=\"headerlink\" title=\"3.0版本的新特性\"></a>3.0版本的新特性</h3><ul>\n<li><p>支持Gif动画的解码 - 与加载图片相同，只要调用Glide.with(…).load(…)，如果你加载的图片是一个可以播放的Gif，Glide会自动加载它并显示在一个自定义的Drawable上（注：GifDrawable）。此外，你还可以控制的更多，比如</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 你想加载Gif为一张静态图片</span></div><div class=\"line\">Glide.with(context).load(...).asBitmap()。</div><div class=\"line\"><span class=\"comment\">// 或者你想只有加载对象是Gif时才能加载成功</span></div><div class=\"line\">Glide.with(context).load(...).asGif()。</div></pre></td></tr></table></figure>\n</li>\n<li><p>本地视频播放技术 - 除了解码Gif，Glide也能解码你设备上的视频（video）。使用方法和加载gif相同，Glide支持所有Android可以直接解码的视频。</p>\n</li>\n<li><p>支持缩略图加载 - 有时我们希望减少用户等待的时间又不想牺牲图片的质量，我们可以同时加载多张图片到一个View中，先加载缩略图（只有view的1/10大小），然后再加载一个完整的图像覆盖在上面。使用下面的代码</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment).load(yourUrl).thumbnail(<span class=\"number\">0.1f</span>).into(yourView)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当然，你也可以传入一个Request到<code>.thumbnail()</code>函数中作为参数。</p>\n<ul>\n<li>与生命周期集成 - 加载请求现在会自动在onStop中暂停在，onStart中重新开始。为了节约电量，Gif动画也会在onStop中自动暂停。此外，当设备的连接状态改变时，所有失败的请求会自动重试，确保Glide不会因为临时性的连接问题，导致请求永远失败。</li>\n<li><p>转码 - 除了解码资源，Glide的<code>.toBytes()</code>和<code>.transcode()</code>方法允许你在后台正常地获取、解码、变换一张图片。你还可以在这些调用中把图片转码成更有用的格式，比如，上传一张大小为250*250像素的用户头像的图片bytes数据，代码如下</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context)</div><div class=\"line\">    .load(“/user/profile/photo/path”)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .toBytes()</div><div class=\"line\">    .centerCrop()</div><div class=\"line\">    .into(<span class=\"keyword\">new</span> SimpleTarget&lt;<span class=\"keyword\">byte</span>[]&gt;(<span class=\"number\">250</span>, <span class=\"number\">250</span>) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data, GlideAnimation anim)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 在此处，将bytes数据传入后台线程，再上传他们</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>动画 - Glide3.X支持『淡入淡出』动画（<code>.crossFade()</code>）和view的属性动画(<code>.animate(ViewPropertyAnimation.Animator)</code>)。此外，还有Glide2.0就支持的android view动画。</p>\n</li>\n<li>支持 OkHttp 和 Volley - 现在你可以选择用OkHttp、Volley或者默认的HttpUrlConnection作为网络栈。OkHttp和Volley可以通过添加对应的集成库(integration library)和注册相应的<code>ModelLoaderFactory</code>来引入。具体查看ReadMe文件。</li>\n<li>其他 - 可以使用Drawable对象作为加载中的占位图、请求优先级、覆盖自定义宽和高、可以缓存变换后的缩略图或者缓存原始文件</li>\n</ul>\n<h3 id=\"从2-0迁移到3-0\"><a href=\"#从2-0迁移到3-0\" class=\"headerlink\" title=\"从2.0迁移到3.0\"></a>从2.0迁移到3.0</h3><ul>\n<li>将所有的<code>Glide.load()</code>替换为<code>Glide.with([fragment/activity/context]).load()</code>。</li>\n<li>将所有的自定义的加载调用<code>Glide.load(url).into(new SimpleTarget(){ ... }).with(context)</code>替换成<code>Glide.with(context).load(url).into(new SimpleTarget(width, height) { ... })</code>。</li>\n</ul>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>除了3.0引入的新功能，Glide继承了2.0的所有功能：</p>\n<ul>\n<li>后台图片加载</li>\n<li>如果你使用了listview的复用机制，那么Glide会自动取消作业（job）</li>\n<li>内存和磁盘缓存</li>\n<li>Bitmap和资源池来减少内存抖动</li>\n<li>支持任意的图像变换</li>\n</ul>\n<hr>\n<h2 id=\"缓存机制与缓存失效\"><a href=\"#缓存机制与缓存失效\" class=\"headerlink\" title=\"缓存机制与缓存失效\"></a>缓存机制与缓存失效</h2><p>缓存失效是一个比较复杂的话题，理想情况下，你尽可能不要考虑这个问题。这一节主要是让你粗略的了解一下Glide中cache的key是如何生成，以及提供一些关于如何合理利用缓存的提示。</p>\n<h3 id=\"缓存的key\"><a href=\"#缓存的key\" class=\"headerlink\" title=\"缓存的key\"></a>缓存的key</h3><p><code>DiskCacheStrategy.RESULT</code>磁盘缓存策略（注：我们配置的一种磁盘缓存策略）使用的key由以下四个主要部分组成：</p>\n<ul>\n<li>DataFetcher的方法<code>getId()</code>返回的字符。典型地，DataFetcher仅仅返回由数据Model的<code>toString()</code>方法得到的值。所以，如果Model是一个<strong>URL</strong>，那么会返回URL的字符串，如果Model是是一个文件，那么会返回文件的<strong>路径</strong>。。。</li>\n<li>宽和高。如果你调用过override(width,height)方法，那么就是是它传入的值。没有调用过，默认是通过<strong>Target</strong>的<code>getSize()</code>方法获得这个值。</li>\n<li>各种编码器、解码器的<code>getId()</code>方法返回的字符串。这些编码器、解码器用于加载和缓存你的图片。仅有哪些堆bytes数据有影响的编码器、解码器才会有这些<code>id</code>值。比如，你只有一个将bytes数据写入磁盘的编码器，那么它就没有id值，因为不管怎样它都不会修改数据。</li>\n<li>可选地，你可以为图片加载提供签名(Signature)，请看下面的缓存失效部分。</li>\n</ul>\n<p>所有的这些key，以特定的顺序计算出hash值，并将这个值作为保存图片到磁盘上的唯一且安全的文件名。</p>\n<h3 id=\"缓存失效\"><a href=\"#缓存失效\" class=\"headerlink\" title=\"缓存失效\"></a>缓存失效</h3><p>由于文件名是hash值，没有简便的方式删除磁盘上某个特定url或者文件路径的所有缓存文件。如果仅仅缓存原文件，问题可能还比较简单，但是Glide会缓存缩略图，各种变换后的图片，所有这些缓存都会产生新文件。跟踪和删除所有文件是十分困难的。</p>\n<h3 id=\"自定义缓存失效\"><a href=\"#自定义缓存失效\" class=\"headerlink\" title=\"自定义缓存失效\"></a>自定义缓存失效</h3><p>通常情况下改变缓存的标志（key）是困难的。Glide提供了<code>signature()</code>API来混入其他数据，帮助你控制缓存的key。签名（Signature）对于多媒体或者有版本信息的内容来说都很有用。</p>\n<ul>\n<li>媒体库内容 - 对于媒体库内容，你可以使用Glide的<code>MediaStoreSignature</code>类作为签名， MediaStoreSignature类允许你混入文件修改时间、mime类型、媒体库的方向(orientation?)这些值作为缓存的key，这三个值足以让你可靠的捕捉到任何修改和更新，使你可以缓存媒体库的缩略图.?</li>\n<li>文件 - 你可以使用<code>StringSignature</code>混入文件修改时间</li>\n<li>url - 虽然使url失效最好的方式是当内容变化时，服务器修改url并更新客户端，但是你也可以用<code>StringSignature</code>混入任意的元数据（如版本号）来使缓存失效。</li>\n</ul>\n<p>使用String Signature加载数据很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourFileDataModel)</div><div class=\"line\">    .signature(<span class=\"keyword\">new</span> StringSignature(yourVersionMetadata))</div><div class=\"line\">    .into(yourImageView);</div></pre></td></tr></table></figure>\n<p>媒体库Signature可以直接使用从MeidaStore(注：一个android api）获得的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(fragment)</div><div class=\"line\">    .load(mediaStoreUri)</div><div class=\"line\">    .signature(<span class=\"keyword\">new</span> MediaStoreSignature(mimeType, dateModified, orientation))</div><div class=\"line\">    .into(view);</div></pre></td></tr></table></figure>\n<p>你还可以通过实现<code>key</code>接口来自定义签名，确保实现了<code>equals()</code>, <code>hashCode()</code>和<code>updateDiskCacheKey()</code>这几个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerVersionSignature</span> <span class=\"keyword\">implements</span> <span class=\"title\">Key</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentVersion;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IntegerVersionSignature</span><span class=\"params\">(<span class=\"keyword\">int</span> currentVersion)</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">this</span>.currentVersion = currentVersion;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> IntegerVersionSignature) &#123;</div><div class=\"line\">            IntegerVersionSignature other = (IntegerVersionSignature) o;</div><div class=\"line\">            <span class=\"keyword\">return</span> currentVersion = other.currentVersion;</div><div class=\"line\">        &#125; </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> currentVersion;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateDiskCacheKey</span><span class=\"params\">(MessageDigest md)</span> </span>&#123;</div><div class=\"line\">        messageDigest.update(ByteBuffer.allocate(Integer.SIZE).putInt(signature).array());</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>请牢记：为了避免性能下降，请在后台线程中批量加载版本元数据(metaData，注：一般查询数据库获得)，只有这样，才能确保当你想加载图片的时候，这些值是可用的。</p>\n<p>如果这些方法都失败了，比如，你不能改变标识符，也不能跟踪一个合理的版本号。你还可以使用<code>diskCacheStrategy()</code>和<code>DiskCacheStrategy.NONE.</code>来完全关闭磁盘缓存。</p>\n<hr>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"懒加载配置\"><a href=\"#懒加载配置\" class=\"headerlink\" title=\"懒加载配置\"></a>懒加载配置</h3><p>从Glide3.5开始，你可以使用<code>GlideModule</code>接口来懒加载配置Glide以及注册组件（如<code>ModelLoaders</code>)，这些配置将会在第一个Glide请求发起的时候被调用。</p>\n<h3 id=\"创建一个GlideModule\"><a href=\"#创建一个GlideModule\" class=\"headerlink\" title=\"创建一个GlideModule\"></a>创建一个GlideModule</h3><p>为了使用和注册GlideModule，首先需要实现该接口，加入你的配置和组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.mypackage; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyGlideModule</span> <span class=\"keyword\">implements</span> <span class=\"title\">GlideModule</span> </span>&#123; </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">applyOptions</span><span class=\"params\">(Context context, GlideBuilder builder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Apply options to the builder here. </span></div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerComponents</span><span class=\"params\">(Context context, Glide glide)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// register ModelLoaders here. </span></div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，添加你的实现类到<code>proguard.cfg</code>文件中，让你的module可以被反射调用到。这个性能开支很少，因为每个module只会在Glide第一次请求的时候实例化一次。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keepnames class com.mypackage.MyGlideModule</div><div class=\"line\"># or more generally:</div><div class=\"line\">#-keep public class * implements com.bumptech.glide.module.GlideModule</div></pre></td></tr></table></figure>\n<p>最后，添加meta-data标记到<code>AndroidManifest.xml</code>，那样Glide才能找到它。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- ... permissions --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta-data</span></span></div><div class=\"line\">            <span class=\"attr\">android:name</span>=<span class=\"string\">\"com.mypackage.MyGlideModule\"</span></div><div class=\"line\">            <span class=\"attr\">android:value</span>=<span class=\"string\">\"GlideModule\"</span> /&gt;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- ... activities and other components --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你可以实现任意个<code>GlideModule</code>，但是每一个都要添加到<code>proguard.cfg</code>，而且每一个GlideModule都要在manifest有自己的meta-data标记。</p>\n<h3 id=\"Library工程\"><a href=\"#Library工程\" class=\"headerlink\" title=\"Library工程\"></a>Library工程</h3><p>Library工程可能含有一个或多个<code>GlideModule</code>。当我们使用Gradle（或者任何支持manifest合并的构建工具）构建app时，如果我们所依赖的Library工程的manifest中含有module，那么这些module会自动并入到app中。如果构建工具不支持manifest合并，那么这些library工程中的module必须手动添加到你app的manifest中。</p>\n<h3 id=\"GlideModule冲突\"><a href=\"#GlideModule冲突\" class=\"headerlink\" title=\"GlideModule冲突\"></a>GlideModule冲突</h3><p>虽然Glide允许每个app注册多个<code>Glidemodule</code>，但是不会以某种特定的顺序调用这些module。所以，如果你的app中多个<code>GlideModules</code>或者依赖的library工程中有多个<code>GlideModules</code>，你必须负责避免他们之间的冲突。<br>如果冲突不可避免，app应该定义自己的默认module，这个module需要手动解决这些冲突，提供所有Library工程所需要的依赖。使用Gradle的开发者，或者使用manifest合并的开发者，可以通过下面的标签来排除冲突的module。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">”com.mypackage.MyGlideModule”</span> <span class=\"attr\">tools:node</span>=<span class=\"string\">”remove”</span> /&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h3><p>你可以配置一些作用于所有请求的全局性配置项。请使用<code>GlideModule#applyOptions</code>方法中（注：作为参数）提供给你的<code>GlideBuilder</code>来配置。本节代码示例中的<code>builder</code>就是一个GlideModule对象。</p>\n<h3 id=\"磁盘缓存\"><a href=\"#磁盘缓存\" class=\"headerlink\" title=\"磁盘缓存\"></a>磁盘缓存</h3><p>你可以使用<code>GlideBuilder</code>的<code>setDiskCache()</code>方法设置磁盘缓存的位置、大小（最大值）。你也可以使用<code>DiskCacheAdapter</code>彻底关闭缓存，或者自己实现<code>DiskCache</code>接口来换掉默认实现。磁盘缓存由<code>DiskCache.Factory</code>接口的实例在后台线程中创建，使用后台线程可以避免在严格模式中出现问题。<br>Glide默认使用<code>InternalCacheDiskCacheFactory</code>类建立磁盘缓存。这个内部缓存工厂（internal cache factory）会把磁盘缓存放到应用程序的内部缓存目录中，并且设置最大空间是250MB，使用内部缓存的目录而不是SD卡的外部目录意味着其他应用程序无法访问到你下载的图片。具体请查看Android的<a href=\"http://developer.android.com/intl/zh-cn/guide/topics/data/data-storage.html#filesInternal\" target=\"_blank\" rel=\"external\">存储选项相关文档</a>。</p>\n<h4 id=\"大小\"><a href=\"#大小\" class=\"headerlink\" title=\"大小\"></a>大小</h4><p>使用<code>InternalCacheDiskCacheFactory</code>设置磁盘缓存大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDiskCache(</div><div class=\"line\">  <span class=\"keyword\">new</span> InternalCacheDiskCacheFactory(context, yourSizeInBytes));</div></pre></td></tr></table></figure>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><p>也可以设置磁盘缓存位置<br>你可以使用<code>InternalCacheDiskCacheFactory</code>来把你的磁盘缓存放到应用程序私有的内部存储目录中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDiskCache(</div><div class=\"line\">  <span class=\"keyword\">new</span> InternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));</div></pre></td></tr></table></figure>\n<p>还可以用<code>ExternalCacheDiskCacheFactory</code>来把你的磁盘缓存放到sd卡的公共缓存目录上。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDiskCache(</div><div class=\"line\">  <span class=\"keyword\">new</span> ExternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));</div></pre></td></tr></table></figure>\n<p>如果你想用其他自定义的路径，可以用<code>DiskLruCacheFactory</code>类的构造函数来实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// If you can figure out the folder without I/O: </span></div><div class=\"line\"><span class=\"comment\">// Calling Context and Environment class methods usually do I/O. </span></div><div class=\"line\">builder.setDiskCache( </div><div class=\"line\">  <span class=\"keyword\">new</span> DiskLruCacheFactory(getMyCacheLocationWithoutIO(), yourSizeInBytes)); </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// In case you want to specify a cache folder (\"glide\"): </span></div><div class=\"line\">builder.setDiskCache( </div><div class=\"line\">  <span class=\"keyword\">new</span> DiskLruCacheFactory(getMyCacheLocationWithoutIO(), <span class=\"string\">\"glide\"</span>, yourSizeInBytes)); </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// In case you need to query the file system while determining the folder: </span></div><div class=\"line\">builder.setDiskCache(<span class=\"keyword\">new</span> DiskLruCacheFactory(<span class=\"keyword\">new</span> CacheDirectoryGetter() &#123; </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getCacheDirectory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> getMyCacheLocationBlockingIO(); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;), yourSizeInBytes);</div></pre></td></tr></table></figure>\n<p>注意：请牢记，写死任何值都不是个好主意，尤其是目录的路径，因为自Android4.2开始，支持单设备多用户。</p>\n<p>如果你想完全控制缓存的创建，可以自己实现<code>DiskCache.Factory</code>接口，使用<code>DiskLruCacheWrapper</code>可以在你想要的位置创建一个新的缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDiskCache(<span class=\"keyword\">new</span> DiskCache.Factory() &#123; </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> DiskCache <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        File cacheLocation = getMyCacheLocationBlockingIO();</div><div class=\"line\">        cacheLocation.mkdirs();</div><div class=\"line\">        <span class=\"keyword\">return</span> DiskLruCacheWrapper.get(cacheLocation, yourSizeInBytes);</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"内存缓存和缓存池\"><a href=\"#内存缓存和缓存池\" class=\"headerlink\" title=\"内存缓存和缓存池\"></a>内存缓存和缓存池</h3><p><code>GlideBuilder</code>类允许你设置内存缓存大小，而且可以实现自定义的<code>MemoryCache</code>和<code>BitmapPool</code>。</p>\n<h4 id=\"大小-1\"><a href=\"#大小-1\" class=\"headerlink\" title=\"大小\"></a>大小</h4><p>默认大小是由<code>MemorySizeCalculator</code>类决定的。MemorySizeCalculator类会考虑该设备的屏幕大小、可用内存来计算出一个合理的默认值。如果你想调整这个默认值，请构建自己的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MemorySizeCalculator calculator = <span class=\"keyword\">new</span> MemorySizeCalculator(context);</div><div class=\"line\"><span class=\"keyword\">int</span> defaultMemoryCacheSize = calculator.getMemoryCacheSize();</div><div class=\"line\"><span class=\"keyword\">int</span> defaultBitmapPoolSize = calculator.getBitmapPoolSize();</div></pre></td></tr></table></figure>\n<p>如果你想在应用的某个阶段动态调整Glide的内存占用，你可以选择一个<code>MemoryCategory</code>并使用<code>setMemoryCategory()</code>方法传入Glide中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.get(context).setMemoryCategory(MemoryCategory.HIGH);</div></pre></td></tr></table></figure>\n<h4 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h4><p>Glide的内存缓存会在内存中持有资源，它的作用是，我们可以不进行IO操作而快速获得可用资源。<br>你可以使用<code>GlideBuilder</code>的<code>setMemoryCache()</code>方法设置大小，或者设置你关于内存缓存的自定义实现（自定义类）。<code>LruResourceCache</code>类是Glide的默认实现。你可以通过<code>LruResourceCache</code>的构造函数来配置内存占用的bytes的最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setMemoryCache(<span class=\"keyword\">new</span> LruResourceCache(yourSizeInBytes));</div></pre></td></tr></table></figure>\n<h4 id=\"Bitmap池\"><a href=\"#Bitmap池\" class=\"headerlink\" title=\"Bitmap池\"></a>Bitmap池</h4><p>Glide的Bitmap池主要作用是，可以让各种尺寸的Bitmap被复用，可以可观地减少由垃圾回收引起的内存抖动。在解码图片时，需要给像素数组分配空间，这会触发垃圾回收。<br>你可以使用<code>GlideBuilder</code>的<code>setBitmapPool()</code>方法设置大小，或者设置你关于Bitmap池的自定义实现，<code>LruBitmapPool</code>类是Glide的默认实现。LruBitmapPool类使用了LRU算法维护最近最常使用的Bitmap的尺寸。你可以通过<code>LruBitmapPool</code>的构造函数配置内存占用的bytes的最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setBitmapPool(<span class=\"keyword\">new</span> LruBitmapPool(sizeInBytes));</div></pre></td></tr></table></figure>\n<h3 id=\"Bitmap格式\"><a href=\"#Bitmap格式\" class=\"headerlink\" title=\"Bitmap格式\"></a>Bitmap格式</h3><p><code>GlideBuilder</code> 类也允许你配置一个App全局使用的Bitmap的Config属性。<br>Glide默认使用RGB_565，因为它每个像素只需要2bytes（16bit）的空间，它仅需要高质量图片（既系统默认的<code>ARGB_8888</code>）一半的内存空间。但是，这对于某些图片这可能会出现『条带』的问题，而且它也不支持透明度。<br>如果在你的应用中『条带』是一个重要的问题，或者你需要尽可能好的图片质量，你可以使用<code>GlideBuilder</code>的<code>setDecodeFormat</code>方法设置DecodeFormat.ALWAYS_ARGB_8888作为首选配置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"自定义目标（Targets）\"><a href=\"#自定义目标（Targets）\" class=\"headerlink\" title=\"自定义目标（Targets）\"></a>自定义目标（Targets）</h2><p>除了可以加载图像，视频剧照，gif动画到View中，你还可以加载他们到实现了Target接口的自定义目标中。</p>\n<h3 id=\"SimpleTarget\"><a href=\"#SimpleTarget\" class=\"headerlink\" title=\"SimpleTarget\"></a>SimpleTarget</h3><p>如果你只是想加载一个Bitmap，并不想直接展示给用户而是有一些特殊用途，比如在通知栏中显示或者作为头像上传。<br>Glide也可以做到。<br>SimpleTarget为Target接口提供了大部分的默认实现。你可以专注于处理加载的结果。<br>为了使用SimpleTarget，你需要在它的构造函数中提供你要加载的资源的宽和高（单位像素），你还需要实现<code>onResourceReady(T resource, GlideAnimation animation)</code>方法。<br>一个典型的使用SimpleTarget的例子如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> myWidth = <span class=\"number\">512</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> myHeight = <span class=\"number\">384</span>;</div><div class=\"line\"> </div><div class=\"line\">Glide.with(yourApplicationContext)) </div><div class=\"line\">    .load(youUrl) </div><div class=\"line\">    .asBitmap() </div><div class=\"line\">    .into(<span class=\"keyword\">new</span> SimpleTarget&lt;Bitmap&gt;(myWidth, myHeight) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span> </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(Bitmap bitmap, GlideAnimation anim)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// Do something with bitmap here. </span></div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"一些警告\"><a href=\"#一些警告\" class=\"headerlink\" title=\"一些警告\"></a>一些警告</h4><p>正常情况下，你加载一个资源会把他们放到view中。当你的Activity或者Fragment被pause或者destroy时，Glide会暂停或取消加载，确保你不会加载那些根本不会显示的资源。<br>可是当我们使用SimpleTarget的时候，这可能并不是我们希望的行为。所以，当你调用<code>Glide.with(context)</code>的时候，你可以传入Application的context，而不是传入Activity或者Fragment。<br>此外，考虑到长时间的加载操作可能导致内存泄漏，请考虑使用静态内部类，而不是匿名内部类。</p>\n<h3 id=\"ViewTarget\"><a href=\"#ViewTarget\" class=\"headerlink\" title=\"ViewTarget\"></a>ViewTarget</h3><p>如果你想加载一个图片到View中，但是你想观察或者覆盖Glide的默认行为。你可以覆盖ViewTarget或者它的子类。<br>当你想让Glide来获取view的的大小，但是由自己来启动动画和设置资源到view中，ViewTarget是个不错的选择。如果你要加载一个图片到ImageView之外的自定义view中，那么ImageViewTarget或者它的子类就不能满足你的要求，此时继承ViewTarget就特别合适。<br>你可以静态的定义一个ViewTarget的子类，或者传递一个匿名内部类到你的加载调用里：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .into(<span class=\"keyword\">new</span> ViewTarget&lt;YourViewClass, GlideDrawable&gt;(yourViewObject) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(GlideDrawable resource, GlideAnimation anim)</span> </span>&#123;</div><div class=\"line\">            YourViewClass myView = <span class=\"keyword\">this</span>.view;</div><div class=\"line\">            <span class=\"comment\">// Set your resource on myView and/or start your animation here.</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>注意，如果你想指定加载Bitmap还是GifDrawable，请在<code>.load(yourUrl)</code>调用后面直接添加<code>.asBitmap()</code>或者<code>.asGif()</code>，同时将ViewTarget的类型参数<code>GlideDrawable</code>换成对应加载的类型。<br>为了更多控制，你也可以在Target实现<code>LifecycleListener</code>回调，<code>onStart()</code>、<code>onStop()</code>或者<code>onDestroy()</code>会和你view所在的fragment的生命周期保持同步。</p>\n<h3 id=\"覆盖默认行为\"><a href=\"#覆盖默认行为\" class=\"headerlink\" title=\"覆盖默认行为\"></a>覆盖默认行为</h3><p>如果你只想观察不想修改Glide的默认行为，你可以继承任何一个Glide对ImageViewTargets的默认实现。</p>\n<ul>\n<li>GlideDrawableImageViewTarget - 默认的Target，用于正常的加载和<code>asGif()</code>。</li>\n<li>BitmapImageViewTarget - 当使用<code>asBitmap()</code>加载时，使用的默认Target。</li>\n</ul>\n<p>只有你在每个方法里面调用<code>super()</code>，将会保留默认的行为，同时还可以添加一些你希望的功能。</p>\n<p>例如，想要生成一个<a href=\"http://chris.banes.me/2014/07/04/palette-preview/\" target=\"_blank\" rel=\"external\">调色板</a>，你可以这样做。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment) </div><div class=\"line\">    .load(yourUrl) </div><div class=\"line\">    .asBitmap() </div><div class=\"line\">    .into(<span class=\"keyword\">new</span> BitmapImageViewTarget(yourImageView)) &#123; </div><div class=\"line\">        <span class=\"meta\">@Override</span> </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(Bitmap bitmap, GlideAnimation anim)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.onResourceReady(bitmap, anim);</div><div class=\"line\">            Palette.generateAsync(bitmap, <span class=\"keyword\">new</span> Palette.PaletteAsyncListener() &#123;  </div><div class=\"line\">                <span class=\"meta\">@Override</span> </div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onGenerated</span><span class=\"params\">(Palette palette)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"comment\">// Here's your generated palette </span></div><div class=\"line\">                &#125; </div><div class=\"line\">            &#125;); </div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>虽然这个例子还不错，但是，通常情况下，我不推荐用这个方式生成调色板。请查看Glide的 <code>ResourceTranscoder</code> 接口和<code>.transcode()</code>方法，考虑返回一个包含Bitmap和调色板的自定义资源。调色板可在在后台线程生成。？？？？？更多内容会在以后推出。。。</p>\n<hr>\n<h2 id=\"调试和错误处理\"><a href=\"#调试和错误处理\" class=\"headerlink\" title=\"调试和错误处理\"></a>调试和错误处理</h2><p>Glide在加载过程中出现异常默认情况下不会打日志。Glide为你提供了两种方式查看和处理这些异常。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>仅仅为了查看异常的话，你可以为<code>GenericRequest</code>类打开Debug日志。这个类处理所有媒体资源的加载响应（response）。你可以在命令行里运行：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell setprop log.tag.GenericRequest DEBUG</div></pre></td></tr></table></figure>\n<p>想要包括详细的请求时序信息，你可以把<code>DEBUG</code>缓存<code>VERBOSE</code>。</p>\n<p>关闭日志使用：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell setprop log.tag.GenericRequest ERROR</div></pre></td></tr></table></figure>\n<h3 id=\"调试工作流\"><a href=\"#调试工作流\" class=\"headerlink\" title=\"调试工作流\"></a>调试<a href=\"https://docs.google.com/drawings/d/1KyOJkNd5Dlm8_awZpftzW7KtqgNR6GURvuF6RfB210g/edit\" target=\"_blank\" rel=\"external\">工作流</a></h3><p>为了查看内部引擎（engine）如何以及何时查找到资源，你可以打开日志：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell setprop log.tag.Engine VERBOSE</div><div class=\"line\">adb shell setprop log.tag.EngineJob VERBOSE</div><div class=\"line\">adb shell setprop log.tag.DecodeJob VERBOSE</div></pre></td></tr></table></figure>\n<p>打开这个有助于你找出为什么某个资源没有从内存缓存中加载，为什么请求再次从外部的url下载数据。这也可以帮助你了解：如果想命中磁盘缓存，什么样的参数需要匹配。启用<code>DecodeJob</code>日志也可以帮助你去定位自定义transformation/decoder/encoder相关的问题。</p>\n<h3 id=\"监听请求-RequestListener\"><a href=\"#监听请求-RequestListener\" class=\"headerlink\" title=\"监听请求-RequestListener\"></a>监听请求-RequestListener</h3><p>虽然启用debug日志很简单，但是只有在你可以连接到设备时才能这样干。为了把Glide集成到已有的更专业的错误日志系统。你可以使用<code>RequestListener</code>类的<code>onException()</code>。当请求失败时，该方法会告知你导致失败的<code>异常</code>(Exception)，如果解码器（Decoder）不能从数据中解析出任何有用的信息，Exception也可能传<code>null</code>。你可以使用<code>listener()</code>API传一个你的监听器（listener）到每一个请求中。<br>请确保<code>onException()</code>返回<code>false</code>，以免覆盖了Glide的默认错误处理行为（例如，它默认会通知<code>Target</code>这个error）。<br>这是一个快速调试的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// example usage: .listener(new LoggingListener&lt;String, GlideDrawable&gt;()) </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggingListener</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RequestListener</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onException</span><span class=\"params\">(Exception e, Object model, Target target, <span class=\"keyword\">boolean</span> isFirstResource)</span> </span>&#123;</div><div class=\"line\">        android.util.Log.d(<span class=\"string\">\"GLIDE\"</span>, String.format(Locale.ROOT,</div><div class=\"line\">                <span class=\"string\">\"onException(%s, %s, %s, %s)\"</span>, e, model, target, isFirstResource), e);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(Object resource, Object model, Target target, <span class=\"keyword\">boolean</span> isFromMemoryCache, <span class=\"keyword\">boolean</span> isFirstResource)</span> </span>&#123;</div><div class=\"line\">        android.util.Log.d(<span class=\"string\">\"GLIDE\"</span>, String.format(Locale.ROOT,</div><div class=\"line\">                <span class=\"string\">\"onResourceReady(%s, %s, %s, %s, %s)\"</span>, resource, model, target, isFromMemoryCache, isFirstResource));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>确保发版前移除相关代码</strong></p>\n<h3 id=\"更多日志\"><a href=\"#更多日志\" class=\"headerlink\" title=\"更多日志\"></a>更多日志</h3><p>这个列表是给3.6.0版本用的，可能不完整。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd .../android-sdk/platform-tools</div><div class=\"line\">adb shell setprop log.tag.AnimatedGifEncoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.AssetUriFetcher VERBOSE</div><div class=\"line\">adb shell setprop log.tag.BitmapEncoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.BufferedIs VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ByteArrayPool VERBOSE</div><div class=\"line\">adb shell setprop log.tag.CacheLoader VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ContentLengthStream VERBOSE</div><div class=\"line\">adb shell setprop log.tag.DecodeJob VERBOSE</div><div class=\"line\">adb shell setprop log.tag.DiskLruCacheWrapper VERBOSE</div><div class=\"line\">adb shell setprop log.tag.Downsampler VERBOSE</div><div class=\"line\">adb shell setprop log.tag.Engine VERBOSE</div><div class=\"line\">adb shell setprop log.tag.EngineRunnable VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GenericRequest VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GifDecoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GifEncoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GifHeaderParser VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GifResourceDecoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.Glide VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ImageHeaderParser VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ImageVideoDecoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.IVML VERBOSE</div><div class=\"line\">adb shell setprop log.tag.LocalUriFetcher VERBOSE</div><div class=\"line\">adb shell setprop log.tag.LruBitmapPool VERBOSE</div><div class=\"line\">adb shell setprop log.tag.MediaStoreThumbFetcher VERBOSE</div><div class=\"line\">adb shell setprop log.tag.MemorySizeCalculator VERBOSE</div><div class=\"line\">adb shell setprop log.tag.PreFillRunner VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ResourceLoader VERBOSE</div><div class=\"line\">adb shell setprop log.tag.RMRetriever VERBOSE</div><div class=\"line\">adb shell setprop log.tag.StreamEncoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.TransformationUtils VERBOSE</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"使用Glide下载自定义大小的图片\"><a href=\"#使用Glide下载自定义大小的图片\" class=\"headerlink\" title=\"使用Glide下载自定义大小的图片\"></a>使用Glide下载自定义大小的图片</h2><p>开发者可以通过Glide的ModelLoader接口获得图片大小，并根据这个大小来加载一个合适尺寸的图片url。<br>使用合适尺寸的图片可以节约带宽，设备的存储空间，还可以提升app性能。<br>2014年的Google I/O app团队写了一篇关于如何使用ModelLoader接口调整加载的图片大小的文章。请在GitHub上查看 <a href=\"https://github.com/google/iosched/blob/master/doc/IMAGES.md\" target=\"_blank\" rel=\"external\">I/O app的源码</a>。<br>为了实现自定义的ModelLoader来通过http/https下载图片，可以继承BaseGlideUrlLoader这个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyDataModel</span> </span>&#123; </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">buildUrl</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</div><div class=\"line\">&#125;  </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUrlLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseGlideUrlLoader</span>&lt;<span class=\"title\">MyDataModel</span>&gt; </span>&#123; </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">getUrl</span><span class=\"params\">(MyDataModel model, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Construct the url for the correct size here. </span></div><div class=\"line\">        <span class=\"keyword\">return</span> model.buildUrl(width, height);</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，你就可以使用自定义的ModelLoader来加载图片了，其他的事情会自动完成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .using(<span class=\"keyword\">new</span> MyUrlLoader())</div><div class=\"line\">    .load(yourModel)</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>如果你想避免调用<code>.using(new  MyUrlLoader())</code>，你可以实现一个自定义的<code>ModelLoaderFactory</code>，并在<code>GlideModule</code>中注册它。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyGlideModule</span> <span class=\"keyword\">implements</span> <span class=\"title\">GlideModule</span> </span>&#123; </div><div class=\"line\">    ... </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerComponents</span><span class=\"params\">(Context context, Glide glide)</span> </span>&#123;</div><div class=\"line\">        glide.register(MyDataModel.class, InputStream.class, </div><div class=\"line\">            <span class=\"keyword\">new</span> MyUrlLoader.Factory()); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注册ModelLoaderFactory之后，你就不用调用<code>.using()</code>了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourModel)</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>其他的例子，关于如何使用自定义ModelLoader加载各种尺寸的图片，请查看<a href=\"https://github.com/bumptech/glide/blob/master/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java\" target=\"_blank\" rel=\"external\">Flicker示例应用</a>，和<a href=\"https://github.com/bumptech/glide/blob/master/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java\" target=\"_blank\" rel=\"external\">Giphy示例应用</a>。</p>\n<hr>\n<h2 id=\"集成（Integration）库-Glide与其他库整合\"><a href=\"#集成（Integration）库-Glide与其他库整合\" class=\"headerlink\" title=\"集成（Integration）库-Glide与其他库整合\"></a>集成（Integration）库-Glide与其他库整合</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>####什么是集成库（Integration Library）<br>Glide包括一系列小巧可配置的集成库，这些库可以让Glide与外部的库相结合。现在集成库可以使Glide支持Volley和OkHttp的http/https请求。</p>\n<p>我们坚信，您所选择的客户端媒体库既不应该决定你在你的应用程序中使用的网络库，也不需要你仅仅为了加载图像额外添加网络库。集成库和Glide的ModelLoader系统，允许开发人员对所有网络请求使用统一的网络库。</p>\n<h4 id=\"为什么没有XXX库的实现\"><a href=\"#为什么没有XXX库的实现\" class=\"headerlink\" title=\"为什么没有XXX库的实现\"></a>为什么没有XXX库的实现</h4><p>因为我们还没有为这个库写集成库。OkHttp和Volley是十分流行的库，许多开发者都使用，但是，我们不是排斥其他库，如果你写了其他库的<code>ModelLoader</code>并且打算开源，我们很乐意看到这样的提交请求（pull request）。</p>\n<h4 id=\"我如何依赖一个集成库呢？\"><a href=\"#我如何依赖一个集成库呢？\" class=\"headerlink\" title=\"我如何依赖一个集成库呢？\"></a>我如何依赖一个集成库呢？</h4><p>依赖任何的集成库需要两g个步骤。</p>\n<ol>\n<li>添加相应的继承库的Maven/Gradle/jar依赖，因为作为可选项的集成库并不包含在glide的jar依赖中。</li>\n<li>确保app包含了集成库的GlideModule，具体内容看<a href=\"https://github.com/bumptech/glide/wiki/Configuration\" target=\"_blank\" rel=\"external\">配置wiki</a>部分。对于Glide集成库的具体说明见下面。</li>\n</ol>\n<h4 id=\"我应当选择哪个版本？\"><a href=\"#我应当选择哪个版本？\" class=\"headerlink\" title=\"我应当选择哪个版本？\"></a>我应当选择哪个版本？</h4><p>集成库的版本跟随着Glide的release版本。但是多了一个不同的数字。确保选择与所依赖的Glide对应的集成库。在<a href=\"https://github.com/bumptech/glide/releases\" target=\"_blank\" rel=\"external\">release页</a>查看.<br>网络库有自己的版本号。继承库会依赖的库就是你在Maven/Gradle中指定的库。你可以通过版本号来指定具体依赖的网络库。？？</p>\n<h3 id=\"Volley\"><a href=\"#Volley\" class=\"headerlink\" title=\"Volley\"></a>Volley</h3><p>Volley是一个Http库，可以使Android上的网络请求更简单，更快速。</p>\n<h4 id=\"Gradle中使用Volley\"><a href=\"#Gradle中使用Volley\" class=\"headerlink\" title=\"Gradle中使用Volley\"></a>Gradle中使用Volley</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile <span class=\"string\">'com.github.bumptech.glide:volley-integration:1.3.1@aar'</span></div><div class=\"line\">    <span class=\"comment\">//compile 'com.mcxiaoke.volley:library:1.0.8'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>集成库的<code>GlideModule</code>会自动合并到你app的manifest中。</p>\n<h4 id=\"Maven中是Volley\"><a href=\"#Maven中是Volley\" class=\"headerlink\" title=\"Maven中是Volley\"></a>Maven中是Volley</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.bumptech.glide<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>volley-integration<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>aar<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.mcxiaoke.volley<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>library<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0.8<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>aar<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>请查看对应的manifest章节，了解如何添加对应的GlideModule。</p>\n<h4 id=\"手动添加Volley\"><a href=\"#手动添加Volley\" class=\"headerlink\" title=\"手动添加Volley\"></a>手动添加Volley</h4><p>从<a href=\"https://github.com/bumptech/glide/releases\" target=\"_blank\" rel=\"external\">release页</a>下载<a href=\"https://github.com/bumptech/glide/releases/download/v3.6.1/glide-volley-integration-1.3.1.jar\" target=\"_blank\" rel=\"external\">glide-volley-integration-<version>.jar </version></a>。并添加到你app的编译路径中(compile classpath)。</p>\n<p>请查看对应的manifest章节，了解如何添加对应的GlideModule。</p>\n<h4 id=\"Volley的Manifest\"><a href=\"#Volley的Manifest\" class=\"headerlink\" title=\"Volley的Manifest\"></a>Volley的Manifest</h4><p>如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加<code>GlideModule</code>的metadata标签到<code>AndroidManifest.xml</code>中。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span></span></div><div class=\"line\">    <span class=\"attr\">android:name</span>=<span class=\"string\">\"com.bumptech.glide.integration.volley.VolleyGlideModule\"</span></div><div class=\"line\">    <span class=\"attr\">android:value</span>=<span class=\"string\">\"GlideModule\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"Volley的混淆设置\"><a href=\"#Volley的混淆设置\" class=\"headerlink\" title=\"Volley的混淆设置\"></a>Volley的混淆设置</h4><p>无论使用什么编译系统，不要混淆<code>VolleyGlideModule</code>类，它需要被反射来实例化。添加下面的代码到<code>proguard.cfg</code>文件（或者查看“通用部分”）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keep <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">bumptech</span>.<span class=\"title\">glide</span>.<span class=\"title\">integration</span>.<span class=\"title\">volley</span>.<span class=\"title\">VolleyGlideModule</span></span></div></pre></td></tr></table></figure>\n<h3 id=\"OkHttp\"><a href=\"#OkHttp\" class=\"headerlink\" title=\"OkHttp\"></a>OkHttp</h3><p>OKHttp是一个高效且易于使用的Http客户端。</p>\n<h4 id=\"Gradle中使用OkHttp\"><a href=\"#Gradle中使用OkHttp\" class=\"headerlink\" title=\"Gradle中使用OkHttp\"></a>Gradle中使用OkHttp</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile <span class=\"string\">'com.github.bumptech.glide:okhttp-integration:1.3.1@aar'</span></div><div class=\"line\">    <span class=\"comment\">//compile 'com.squareup.okhttp:okhttp:2.2.0'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>集成库的<code>GlideModule</code>会自动合并到你app的manifest中。</p>\n<h4 id=\"Maven中是OkHttp\"><a href=\"#Maven中是OkHttp\" class=\"headerlink\" title=\"Maven中是OkHttp\"></a>Maven中是OkHttp</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.bumptech.glide<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>okhttp-integration<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>aar<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!--</span></div><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.squareup.okhttp&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;2.2.0&lt;/version&gt;</div><div class=\"line\">    &lt;type&gt;jar&lt;/type&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">--&gt;</div></pre></td></tr></table></figure>\n<p>请查看对应的manifest章节，了解如何添加对应的GlideModule。</p>\n<h4 id=\"手动添加OkHttp\"><a href=\"#手动添加OkHttp\" class=\"headerlink\" title=\"手动添加OkHttp\"></a>手动添加OkHttp</h4><p>从<a href=\"https://github.com/bumptech/glide/releases\" target=\"_blank\" rel=\"external\">release页</a>下载<a href=\"https://github.com/bumptech/glide/releases/download/v3.6.1/glide-okhttp-integration-1.3.1.jar\" target=\"_blank\" rel=\"external\">glide-okhttp-integration-<version>.jar </version></a>。并添加到你app的编译路径中(compile classpath)。</p>\n<p>请查看对应的manifest章节，了解如何添加对应的GlideModule。</p>\n<h4 id=\"OkHttp的Manifest\"><a href=\"#OkHttp的Manifest\" class=\"headerlink\" title=\"OkHttp的Manifest\"></a>OkHttp的Manifest</h4><p>如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加<code>GlideModule</code>的metadata标签到<code>AndroidManifest.xml</code>中。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span></span></div><div class=\"line\">    <span class=\"attr\">android:name</span>=<span class=\"string\">\"com.bumptech.glide.integration.okhttp.OkHttpGlideModule\"</span></div><div class=\"line\">    <span class=\"attr\">android:value</span>=<span class=\"string\">\"GlideModule\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"OkHttp的混淆设置\"><a href=\"#OkHttp的混淆设置\" class=\"headerlink\" title=\"OkHttp的混淆设置\"></a>OkHttp的混淆设置</h4><p>无论使用什么编译系统，不要混淆<code>OkHttpGlideModule</code>类，它需要被反射来实例化。添加下面的代码到<code>proguard.cfg</code>文件（或者查看“通用部分”）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keep <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">bumptech</span>.<span class=\"title\">glide</span>.<span class=\"title\">integration</span>.<span class=\"title\">okhttp</span>.<span class=\"title\">OkHttpGlideModule</span></span></div></pre></td></tr></table></figure>\n<h3 id=\"更多选项\"><a href=\"#更多选项\" class=\"headerlink\" title=\"更多选项\"></a>更多选项</h3><h4 id=\"通用的混淆配置\"><a href=\"#通用的混淆配置\" class=\"headerlink\" title=\"通用的混淆配置\"></a>通用的混淆配置</h4><p>你也可以使用下面的配置来避免混淆所有的<code>GlideModule</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keep <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> * <span class=\"keyword\">implements</span> <span class=\"title\">com</span>.<span class=\"title\">bumptech</span>.<span class=\"title\">glide</span>.<span class=\"title\">module</span>.<span class=\"title\">GlideModule</span></span></div></pre></td></tr></table></figure>\n<p>这种方式有其他的好处，当修改集成库或者自定义集成库的行为时，不需要修改。当你添加或者移动其他module的时候，也不需要修改什么。</p>\n<h4 id=\"覆盖默认的行为\"><a href=\"#覆盖默认的行为\" class=\"headerlink\" title=\"覆盖默认的行为\"></a>覆盖默认的行为</h4><p>如果默认配置无法满足你，所有的集成库还有一些额外的选项。比如添加重试行为，请查看集成库的<code>GlideModule</code>的源码（位于<a href=\"https://github.com/bumptech/glide/tree/3.0/integration\" target=\"_blank\" rel=\"external\">/integration/<lib>/src/main/java/<package></package></lib></a>）了解默认的注册做了些什么。你可以通过在自定义的<code>GlideModule</code>中修改参数为<code>UrlLoader.Factory</code>类来改变默认行为。<br>当你要覆盖默认行为时，请确保自定义的<code>GlideModule</code>被注册，且默认的GlideModule被排除在外。排除GlideModule可能是从manifest中移除相应的的metadata，或者使用jar包依赖代替aar依赖。关于<code>GlideModule</code>的更多信息请查看<a href=\"https://github.com/bumptech/glide/wiki/Configuration\" target=\"_blank\" rel=\"external\">配置的wiki页</a>\\</p>\n<hr>\n<h2 id=\"在后台线程中加载和缓存\"><a href=\"#在后台线程中加载和缓存\" class=\"headerlink\" title=\"在后台线程中加载和缓存\"></a>在后台线程中加载和缓存</h2><p>为了使后台加载资源和与媒体交互更加容易，除了<code>Glide.with(fragment).load(url).into(view)</code>这个API外，Glide还提供了额外两个API。</p>\n<ul>\n<li><code>downloadOnly(int, int)</code></li>\n<li><code>into(int, int)</code></li>\n</ul>\n<h3 id=\"downloadOnly方法\"><a href=\"#downloadOnly方法\" class=\"headerlink\" title=\"downloadOnly方法\"></a>downloadOnly方法</h3><p>Glide的<code>downloadOnly(int, int)</code>方法允许你把图片bytes下载到磁盘缓存中，以便以后获取使用。你可以在UI线程异步地调用<code>downloadOnly()</code>，也可以在后台线程同步的使用。但是，注意他们的参数有些不同，异步API的参数是<code>Target</code>，同步api的参数是宽和高的整数值。<br>为了在后台线程下载图片，你必须使用同步方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">FutureTarget&lt;File&gt; future = Glide.with(applicationContext)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .downloadOnly(<span class=\"number\">500</span>, <span class=\"number\">500</span>);</div><div class=\"line\">File cacheFile = future.get();</div></pre></td></tr></table></figure>\n<p>当future返回时，图片的bytes数据就在缓存中可用了。一种典型的情况是，你使用<code>downloadOnly()</code>API只是为了确保数据下载到了磁盘上。一般情况下，虽然你有权访问底层的缓存文件，但是你不需要直接和它交互。<br>而是，当你想要获取这个图片时，你只要像平常加载图片时那样调用就行，<strong>只有一点不同</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .diskCacheStrategy(DiskCacheStrategy.ALL)</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>通过传入 <code>DiskCacheStrategy.ALL</code>或者<code>DiskCacheStrategy.SOURCE</code>，确保Glide可以使用你通过<code>downloadOnly()</code>下载的数据。</p>\n<h3 id=\"into方法\"><a href=\"#into方法\" class=\"headerlink\" title=\"into方法\"></a>into方法</h3><p>如果你想在一个<strong>后台线程</strong>与一张已经解码的图片交互。你可以使用这个版本的<code>into()</code>方法来返回一个<code>FutureTarget</code>。例如，获取一张中心剪裁后的500*500像素的图片：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bitmap myBitmap = Glide.with(applicationContext)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .centerCrop()</div><div class=\"line\">    .into(<span class=\"number\">500</span>, <span class=\"number\">500</span>)</div><div class=\"line\">    .get()</div></pre></td></tr></table></figure>\n<p>虽然<code>into(int, int)</code>方法在后台线程中很有效，但是，你不能把它用在主线程中。即使这个同步方法在你的主线程中不会抛出异常，调用get()也会阻塞主线程。会使你的APP性能变差，反应迟钝。</p>\n<hr>\n<h2 id=\"Glide中的资源复用\"><a href=\"#Glide中的资源复用\" class=\"headerlink\" title=\"Glide中的资源复用\"></a>Glide中的资源复用</h2><h3 id=\"为什么-资源复用的作用\"><a href=\"#为什么-资源复用的作用\" class=\"headerlink\" title=\"为什么 - 资源复用的作用\"></a>为什么 - 资源复用的作用</h3><p>Glide通过复用资源避免不必要的内存分配。Dalvik虚拟机（在Lollipop之前）有两种基本的垃圾回收方式，<code>GC_CONCURRENT</code> 和<code>GC_FOR_ALLOC</code>。每次<code>GC_CONCURRENT</code>会阻塞主线程5ms。由于每次操作的时间少于16ms（1帧的时间），<code>GC_CONCURRENT</code>并不会引起掉帧。相反的是<code>GC_FOR_ALLOC</code>，他会停止所有操作，阻塞主线程125+ms，事实上，GC_FOR_ALLOC总是会让你的app掉很多帧。尤其是在滑动时，导致明显的卡顿。<br>很不幸，即使只是分配适当的空间（比如16kb的buffer）Dalvik表现的也很糟糕。不断的小内存分配，或者一次大的内存分配（比如说bitmap），将会引起GC_FOR_ALLOC。因此，你分配内存的越多，你会遇到垃圾回收器阻塞应用的情况就越多，应用掉帧就越严重。<br>通过适度复用大块资源，Glide可以避免内存抖动，减少垃圾回收器阻塞app的次数。</p>\n<h3 id=\"怎么做-Glide是如何复用资源\"><a href=\"#怎么做-Glide是如何复用资源\" class=\"headerlink\" title=\"怎么做 - Glide是如何复用资源\"></a>怎么做 - Glide是如何复用资源</h3><p>Glide的资源复用策略比较宽松。这意味着，当Glide认为该资源可以被安全的复用时，才有几率去复用它，并不需要开发者在每个request后面去手动释放资源。</p>\n<h4 id=\"标志-哪些资源可复用\"><a href=\"#标志-哪些资源可复用\" class=\"headerlink\" title=\"标志-哪些资源可复用\"></a>标志-哪些资源可复用</h4><p>Glide有两个简单的标志来识别可复用的资源。</p>\n<ol>\n<li><p><code>Glide.clear()</code> </p>\n<p> 在<code>View</code>或者<code>Target</code>上调用<code>clear()</code>方法都表示，Glide要取消加载，可以安全地把Target占用的所有资源（Bitmap，bytes数组等）放入资源池中（pool）。用户可以在任何时候安全地手动调用<code>clear()</code>方法，但是典型情况下，我们不需要这样做，看第二条。</p>\n</li>\n<li><p>View或者Target的复用 </p>\n<p> 当用户把图片加载到一个已经存在的View或者Target上时（注：确切的说是调用<code>into(xxx)</code>方法之后），Glide会先调用<code>clear()</code>清空该View/Target上的加载请求并复用已经显示过的资源。因此，如果你的ListView或者RecyclerView中的view使用了复用机制（注：如ViewHolder），那么Glide会自动为他们缓存资源和管理加载请求。</p>\n</li>\n</ol>\n<h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>如果两个请求指向同一个资源，为了避免额外的工作，Glide会把单个资源分配给他们。这就导致一个问题，当Glide得知某个资源不被某个调用者使用，这并不表示它不会被其他调用者使用。为了避免回收调依旧被使用的资源，Glide使用引用计数来跟踪资源。<br>当把资源提供给View/Target时，该资源的引用计数加1，当清空View/Target时，引用计数减1。当引用计数为0时，Glide会回收资源，并把它的内容放回可用内存池中。</p>\n<h4 id=\"放入缓存池\"><a href=\"#放入缓存池\" class=\"headerlink\" title=\"放入缓存池\"></a>放入缓存池</h4><p>Glide的Resource API有一个<code>recycle()</code>方法，当Glide认为资源不再被引用时，会调用该方法，资源会放入缓存池中。</p>\n<p>Glide提供的BitmapPool接口可以让Resource获取<code>Bitmap</code>和复用Bitmap对象。Glide的BitmapPool可以通过Glide单例获得：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.get(context).getBitmapPool();</div></pre></td></tr></table></figure>\n<p>ResourceDecoder可以返回Resource的任何实现。所有，开发者可以实现他们自己的Resource和ResourceDecoder来自定义地缓存一些特有类型的数据。<br>同样地，开发者如果想更多地控制Bitmap缓存，可以实现自己的BitmapPool，然后通过GlideModule配置到Glide中。</p>\n<h3 id=\"常见的错误\"><a href=\"#常见的错误\" class=\"headerlink\" title=\"常见的错误\"></a>常见的错误</h3><p>不幸的是，缓存池设计使我们很难判断开发者是否误用了资源或者bitmap。但是，在Glide中有两个主要的现象会暗示你某些地方可能出了问题。</p>\n<h4 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h4><ol>\n<li><p><code>Cannot draw a recycled Bitmap</code></p>\n<p> Glide有个固定大小的Bitmap池。当Bitmap不再被复用（注：不是使用，区分使用和复用），会从池中移走。Glide会调用<a href=\"http://developer.android.com/reference/android/graphics/Bitmap.html#recycle(\" target=\"_blank\" rel=\"external\"><code>recycle()</code></a>)（注：指的是Bitmap真正的recycle，不是Resource类的recycle）。你告诉Glide放心地回收某个Bitmap，但是，你的应用不小心还持有这个Bitmap的引用，应用程序可能会绘制这个Bitmap，导致崩溃。</p>\n</li>\n<li><p>View在多张图片之间闪烁，或者同样的图片出现在多个View中</p>\n<p> 如果一张图片被放入BitmapPool中多次。或者虽然一张图片被放入了pool中，但是某个View依然持有这个图的引用，与此同时，另一张图片被解析成了Bitmap（注：此Bitmap正好用了刚才那张图片的控件来存放解析后的数据）。如果发生这种事情，Bitmap的内容就会被换成了新的图片内容。此时，View依然尝试着绘制Bitmap，导致原来的View中显示了一张新的图片！</p>\n</li>\n</ol>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><p>这些问题主要有两个原因：</p>\n<ol>\n<li><p>尝试加载两个不同的资源到同一Target中</p>\n<p> 在Glide中，没有安全的方法来加载多个资源到单一的Target中。开发者可以使用<code>thumbnail()</code>来加载一系列资源到到某个Target中，但是对于每一个加载的资源来说，只有在下一个<code>onResourceReady()</code>被调用前，它的引用才是安全的。<br>开发者如果想加载多个资源到同一个View中，可以使用两个独立的Target。为了确保加载过程不相互取消，开发者要么不使用ViewTarget的子类，要么在继承ViewTarget时，复写<code>setRequest()</code> 和 <code>getRequest()</code>，不要使用tag来存储Request。（注：需要一个demo)</p>\n<p> <strong>译者注：对于同一个view，调用两次Glide.xxx.into(view)，第二次调用会先清空第一个加载的图片（出现空白），再去下载新的图片，如果想要在第二张图片下载下来之前依旧显示之前的，需要一些技巧</strong></p>\n</li>\n<li><p>加载一个资源放入到Target，然后清空或者复用了Target，但是依然引用这这个资源。</p>\n<p> 最简单的避免这个错误的方法是在<code>onLoadCleared()</code>方法中把所有对资源对象的引用置null。一般情况下，加载一个Bitmap，然后引用它的Target是安全的。不安全的是，你清空了这个Target，却依然引用着这个Bitmap。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"使用快照\"><a href=\"#使用快照\" class=\"headerlink\" title=\"使用快照\"></a>使用快照</h2><h3 id=\"关于快照\"><a href=\"#关于快照\" class=\"headerlink\" title=\"关于快照\"></a>关于快照</h3><p>对于那些不想等待Glide下个正式版本而愿意尝鲜的用户，我们在<a href=\"https://travis-ci.org/bumptech/glide\" target=\"_blank\" rel=\"external\">Sonatype</a>上部署了这个库的快照。<br>每一次我们push代码待GitHub的master分支，<a href=\"https://oss.sonatype.org/content/repositories/snapshots/\" target=\"_blank\" rel=\"external\">travis-ci</a>会构建Glide.如果构建成功，会自动部署最新版本的库到Sonatype上。<br>和Glide主库一样，每个Intergration库也有自己的快照，如果你使用快照版本的Glide库，请使用快照版本的Intergration库，反之依然。</p>\n<h3 id=\"获取快照\"><a href=\"#获取快照\" class=\"headerlink\" title=\"获取快照\"></a>获取快照</h3><p>Sonatype的快照库和其他的maven库一样，提供jar，maven，gradle等版本。</p>\n<h4 id=\"Jar\"><a href=\"#Jar\" class=\"headerlink\" title=\"Jar\"></a>Jar</h4><p>Jar包可以直接从Sonatype上下载，再次检查一下日期，确保使用最新版本</p>\n<h4 id=\"Gradle\"><a href=\"#Gradle\" class=\"headerlink\" title=\"Gradle\"></a>Gradle</h4><p>在仓库列表中添加快照仓库</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">  jcenter()</div><div class=\"line\">  maven &#123;</div><div class=\"line\">    url 'http://oss.sonatype.org/content/repositories/snapshots'</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后修改依赖为快照版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">  compile \"com.github.bumptech.glide:glide:3.6.0-SNAPSHOT\"</div><div class=\"line\">  compile \"com.github.bumptech.glide:okhttp-integration:1.3.0-SNAPSHOT\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h4><p>这种方式没有测试，直接从<a href=\"http://stackoverflow.com/questions/7715321/how-to-download-snapshot-version-from-maven-snapshot-repository\" target=\"_blank\" rel=\"external\">StackOverflow</a>拷过来的。欢迎改进下面的内容。<br>添加下面的代码到<code>~/.m2/settings.xml</code>中：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>allow-snapshots<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">activation</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">activeByDefault</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">activeByDefault</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>snapshots-repo<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>修改依赖为快照版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.bumptech.glide<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>glide<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.6.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.bumptech.glide<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>okhttp-integration<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图形变换\"><a href=\"#图形变换\" class=\"headerlink\" title=\"图形变换\"></a>图形变换</h2><h3 id=\"默认的变换\"><a href=\"#默认的变换\" class=\"headerlink\" title=\"默认的变换\"></a>默认的变换</h3><p>Glide包含两种默认的图像变换方式，fitCenter和centerCrop。如果开发者需要其他类型的变换，可以考虑使用这个独立的<a href=\"https://github.com/wasabeef/glide-transformations\" target=\"_blank\" rel=\"external\">变换库</a>。</p>\n<h4 id=\"Fit-center\"><a href=\"#Fit-center\" class=\"headerlink\" title=\"Fit center\"></a>Fit center</h4><p>FitCenter会按原始比例缩小图像，使图像可以在放在给定的区域内。FitCenter会尽可能少地缩小图片，使宽或者高的一边等于给定的值。另外一边会等于或者小于给定值。<br>FitCenter和Android中的ScaleType.FIT_CENTER效果相同。</p>\n<h4 id=\"CenterCrop\"><a href=\"#CenterCrop\" class=\"headerlink\" title=\"CenterCrop\"></a>CenterCrop</h4><p>CenterCrop会按原始比例缩小图像，使宽或者高的一边等于给定的值，另外一边会等于或者大于给定值。CenterCrop会裁剪掉多余部分。<br>CenterCrop和Android中的ScaleType.CENTER_CROP效果相同。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>fit center效果使用<code>.fitCenter()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .fitCenter()</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>center crop效果使用<code>.centerCrop()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    . centerCrop()</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>如果你只加载Bitmap或者Gif，也可以使用这个变换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// For Bitmaps:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .centerCrop()</div><div class=\"line\">    .into(yourView);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// For gifs:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asGif()</div><div class=\"line\">    .fitCenter()</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>当在类型间转码时，也可以使用这些变换。例如，获取一个变形后的jpeg图片的bytes数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .toBytes()</div><div class=\"line\">    .centerCrop()</div><div class=\"line\">    .into(<span class=\"keyword\">new</span> SimpleTarget&lt;<span class=\"keyword\">byte</span>[]&gt;(...) &#123; ... &#125;);</div></pre></td></tr></table></figure>\n<p>自定义变换<br>除了两个内置的变换，你还可以自定义变换。<br>最简单的方式是继承BitmapTransformation。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTransformation</span> <span class=\"keyword\">extends</span> <span class=\"title\">BitmapTransformation</span> </span>&#123; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyTransformation</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">super</span>(context);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Bitmap <span class=\"title\">transform</span><span class=\"params\">(BitmapPool pool, Bitmap toTransform, </span></span></div><div class=\"line\">            <span class=\"keyword\">int</span> outWidth, <span class=\"keyword\">int</span> outHeight) &#123;</div><div class=\"line\">       Bitmap myTransformedBitmap = ... <span class=\"comment\">// apply some transformation here. </span></div><div class=\"line\">       <span class=\"keyword\">return</span> myTransformedBitmap; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Return some id that uniquely identifies your transformation. </span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"com.example.myapp.MyTransformation\"</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>之后一就可以用同样的方式使用它。使用<code>.transform(...)</code>代替<code>.fitCenter()</code>/<code>.centerCrop()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// For the default drawable type:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .transform(<span class=\"keyword\">new</span> MyTransformation(context))</div><div class=\"line\">    .into(yourView);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// For Bitmaps:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .transform(<span class=\"keyword\">new</span> MyTransformation(context))</div><div class=\"line\">    .into(yourView);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// For Gifs:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asGif()</div><div class=\"line\">    .transform(<span class=\"keyword\">new</span> MyTransformation(context))</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<h4 id=\"调整大小\"><a href=\"#调整大小\" class=\"headerlink\" title=\"调整大小\"></a>调整大小</h4><p>你可能注意到上面的例子没有传入具体的尺寸，那么，Transformation中的尺寸是如何获得的呢？<br>Transformation中的尺寸就是View或者Target的大小。Glide会根据布局文件中的weight，match_parent或者具体值算出View的大小。，当你拥有View/Target的具体大小，又拥有原始图片的大小时，就可以通过图像变换生成一个正确大小的图片。<br>如果你想指定View/Target的自定义大小，可以使用<code>.override(int, int)</code>方法，如果你想加载一个图片有其他用途，而不是显示在View中，请查看『自定义Target』章节。</p>\n<h4 id=\"Bitmap-复用\"><a href=\"#Bitmap-复用\" class=\"headerlink\" title=\"Bitmap 复用\"></a>Bitmap 复用</h4><p>为了减少垃圾回收，你可以说使用<code>BitmapPool</code>接口来释放不想要的Bitmap或者复用存在的Bitmap。一个在Transformation中复用Bitmap典型的例子：从pool中获取Bitmap，使用该Bitmap创建一个<code>Canvas</code>，然后使用Matrix/Paint/Shader来变换图像并绘制到Canvas上。为了正确有效地在Transformation中复用Bitmap中，遵守下面的规则：</p>\n<ol>\n<li>在<code>transform()</code>不要回收资源或者把Bitmap放入Bitmap池中，这些步骤会自动完成。</li>\n<li>如果你从Bitmap池中获取了多个Bitmap，或者没有使用从pool中获取到的Bitmap，确保把多余的Bitmap放回pool中。</li>\n<li>如果你的Trasformation并没有替换调原始图片（比如，图片已经满足你要求的大小，直接返回了），请在<code>transform()</code>方法中返回原始的资源或者Bitmap。</li>\n</ol>\n<p>一个典型的用法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Bitmap <span class=\"title\">transform</span><span class=\"params\">(BitmapPool bitmapPool, Bitmap original, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">    Bitmap result = bitmapPool.get(width, height, Bitmap.Config.ARGB_8888);</div><div class=\"line\">    <span class=\"comment\">// If no matching Bitmap is in the pool, get will return null, so we should allocate. </span></div><div class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// Use ARGB_8888 since we're going to add alpha to the image. </span></div><div class=\"line\">        result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">// Create a Canvas backed by the result Bitmap. </span></div><div class=\"line\">    Canvas canvas = <span class=\"keyword\">new</span> Canvas(result);</div><div class=\"line\">    Paint paint = <span class=\"keyword\">new</span> Paint();</div><div class=\"line\">    paint.setAlpha(<span class=\"number\">128</span>);</div><div class=\"line\">    <span class=\"comment\">// Draw the original Bitmap onto the result Bitmap with a transformation. </span></div><div class=\"line\">    canvas.drawBitmap(original, <span class=\"number\">0</span>, <span class=\"number\">0</span>, paint);</div><div class=\"line\">    <span class=\"comment\">// Since we've replaced our original Bitmap, we return our new Bitmap here. Glide will </span></div><div class=\"line\">    <span class=\"comment\">// will take care of returning our original Bitmap to the BitmapPool for us.  </span></div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>最近，一直在捣鼓Glide这个图片库，确切地说应当叫『媒体框架』。为了支持Gif播放，项目中使用Glide代替了Universal Image Loader。起初我们打算使用的是Fresco方案，最终因为Lib体积的问题放弃。万万没想到apk的size这么敏感，国外很多推广服务是根据apk体积收费的，3M一个门槛，5M一个门槛。fresco引入之后即使proguard、7zip，apk的大小也增加了1M+，多平台的os库是个大头，第三世界的应用市场还不支持按平台分发😓。。<br>Glide的使用还不深入，仅仅停留在Api的范畴，为了解决bug，跟踪了代码，也是云里雾里。不得不说，Glide源码的设计十分NB，面向接口的理念贯彻的很彻底，是一个学习设计的好demo。<br>GitHub的README作为最简单的入门足够了，但是遇到具体问题还是要理解一些设计思想的，GitHub上的Wiki有一份不错的文档，可惜木有中文，正好学习的过程中翻译一下。<br>在看wiki之前，可以先看这两篇中文入门，了解基本的用法。</p>\n<ul>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html\">Google推荐的图片加载库Glide介绍</a></li>\n<li><a href=\"http://www.jianshu.com/p/4a3177b57949\">Glide 一个专注于平滑滚动的图片加载和缓存库</a></li>\n</ul>\n<p>本文是基于<strong>Glide 3.x</strong>正式版的<a href=\"https://github.com/bumptech/glide/wiki\">Wiki文档</a>的翻译（原文编辑日期：2015-2-9,18 revision，当时Glide release的版本号3.6.1）。</p>\n<p>翻译Version：1.1 简单校对</p>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><p>Glide中有一部分单词，我不知道用什么中文可以确切的表达出含义，用英文单词可能在行文中更加合适，还有一些词在Glide中有特别的含义，我理解的可能也不深入，这里先记录一下。</p>\n<ul>\n<li>View： 一般情况下，指Android中的View及其子类控件（包括自定义的），尤其指ImageView。这些控件可在上面绘制Drawable</li>\n<li>Target： Glide中重要的概念，目标。它即可以指封装了一个View的Target（ViewTarget），也可以不包含View（SimpleTarget）。</li>\n<li>Drawable： 指Android中的Drawable类或者它的子类，如BitmapDrawable等。或者Glide中基础Drawable实现的自定义Drawable（如GifDrawable等）</li>\n<li>Request - 加载请求，可以是网络请求或者其他任何下载图片的请求，也是Glide中的一个类。</li>\n<li>Model：数据源的提供者，如Url，文件路径等，可以从model中获取InputStream。</li>\n<li>Signature：签名，可以唯一地标识一个对象。</li>\n<li>recycle()：Glide中Resource类有此方法，表示该资源不被引用，可以放入池中（此时并没有释放空间）。Android中Bitmap也有此方法，表示释放Bitmap占用的内存。</li>\n</ul>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li>主目录</li>\n<li>缓存机制与缓存失效</li>\n<li>Glide配置</li>\n<li>自定义Target</li>\n<li>调试与错误处理</li>\n<li>使用Glide下载自定义大小图片</li>\n<li>集成库-与其他库相整合</li>\n<li>在后台线程中加载与缓存数据</li>\n<li>Glide中的资源复用</li>\n<li>快照（Snapshots）</li>\n<li>图形变换（Transformations）</li>\n</ul>\n<hr>\n<h2 id=\"主目录\"><a href=\"#主目录\" class=\"headerlink\" title=\"主目录\"></a>主目录</h2><h3 id=\"报告问题\"><a href=\"#报告问题\" class=\"headerlink\" title=\"报告问题\"></a>报告问题</h3><p>如果你有任何问题，可以在<a href=\"https://github.com/bumptech/glide/issues/\">Github上提出</a>或者发送e-mail到我们的<a href=\"https://groups.google.com/forum/#!forum/glidelibrary\">邮件列表</a>，也可以在IRC(Internet Relay Chat 网络中继聊天？)频道上联系我们：<a href=\"http://webchat.freenode.net/?channels=glide-library\">irc.freenode.net#glide-library</a>。</p>\n<h3 id=\"3-0版本的新特性\"><a href=\"#3-0版本的新特性\" class=\"headerlink\" title=\"3.0版本的新特性\"></a>3.0版本的新特性</h3><ul>\n<li><p>支持Gif动画的解码 - 与加载图片相同，只要调用Glide.with(…).load(…)，如果你加载的图片是一个可以播放的Gif，Glide会自动加载它并显示在一个自定义的Drawable上（注：GifDrawable）。此外，你还可以控制的更多，比如</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 你想加载Gif为一张静态图片</span></div><div class=\"line\">Glide.with(context).load(...).asBitmap()。</div><div class=\"line\"><span class=\"comment\">// 或者你想只有加载对象是Gif时才能加载成功</span></div><div class=\"line\">Glide.with(context).load(...).asGif()。</div></pre></td></tr></table></figure>\n</li>\n<li><p>本地视频播放技术 - 除了解码Gif，Glide也能解码你设备上的视频（video）。使用方法和加载gif相同，Glide支持所有Android可以直接解码的视频。</p>\n</li>\n<li><p>支持缩略图加载 - 有时我们希望减少用户等待的时间又不想牺牲图片的质量，我们可以同时加载多张图片到一个View中，先加载缩略图（只有view的1/10大小），然后再加载一个完整的图像覆盖在上面。使用下面的代码</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment).load(yourUrl).thumbnail(<span class=\"number\">0.1f</span>).into(yourView)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当然，你也可以传入一个Request到<code>.thumbnail()</code>函数中作为参数。</p>\n<ul>\n<li>与生命周期集成 - 加载请求现在会自动在onStop中暂停在，onStart中重新开始。为了节约电量，Gif动画也会在onStop中自动暂停。此外，当设备的连接状态改变时，所有失败的请求会自动重试，确保Glide不会因为临时性的连接问题，导致请求永远失败。</li>\n<li><p>转码 - 除了解码资源，Glide的<code>.toBytes()</code>和<code>.transcode()</code>方法允许你在后台正常地获取、解码、变换一张图片。你还可以在这些调用中把图片转码成更有用的格式，比如，上传一张大小为250*250像素的用户头像的图片bytes数据，代码如下</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context)</div><div class=\"line\">    .load(“/user/profile/photo/path”)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .toBytes()</div><div class=\"line\">    .centerCrop()</div><div class=\"line\">    .into(<span class=\"keyword\">new</span> SimpleTarget&lt;<span class=\"keyword\">byte</span>[]&gt;(<span class=\"number\">250</span>, <span class=\"number\">250</span>) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data, GlideAnimation anim)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 在此处，将bytes数据传入后台线程，再上传他们</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>动画 - Glide3.X支持『淡入淡出』动画（<code>.crossFade()</code>）和view的属性动画(<code>.animate(ViewPropertyAnimation.Animator)</code>)。此外，还有Glide2.0就支持的android view动画。</p>\n</li>\n<li>支持 OkHttp 和 Volley - 现在你可以选择用OkHttp、Volley或者默认的HttpUrlConnection作为网络栈。OkHttp和Volley可以通过添加对应的集成库(integration library)和注册相应的<code>ModelLoaderFactory</code>来引入。具体查看ReadMe文件。</li>\n<li>其他 - 可以使用Drawable对象作为加载中的占位图、请求优先级、覆盖自定义宽和高、可以缓存变换后的缩略图或者缓存原始文件</li>\n</ul>\n<h3 id=\"从2-0迁移到3-0\"><a href=\"#从2-0迁移到3-0\" class=\"headerlink\" title=\"从2.0迁移到3.0\"></a>从2.0迁移到3.0</h3><ul>\n<li>将所有的<code>Glide.load()</code>替换为<code>Glide.with([fragment/activity/context]).load()</code>。</li>\n<li>将所有的自定义的加载调用<code>Glide.load(url).into(new SimpleTarget(){ ... }).with(context)</code>替换成<code>Glide.with(context).load(url).into(new SimpleTarget(width, height) { ... })</code>。</li>\n</ul>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>除了3.0引入的新功能，Glide继承了2.0的所有功能：</p>\n<ul>\n<li>后台图片加载</li>\n<li>如果你使用了listview的复用机制，那么Glide会自动取消作业（job）</li>\n<li>内存和磁盘缓存</li>\n<li>Bitmap和资源池来减少内存抖动</li>\n<li>支持任意的图像变换</li>\n</ul>\n<hr>\n<h2 id=\"缓存机制与缓存失效\"><a href=\"#缓存机制与缓存失效\" class=\"headerlink\" title=\"缓存机制与缓存失效\"></a>缓存机制与缓存失效</h2><p>缓存失效是一个比较复杂的话题，理想情况下，你尽可能不要考虑这个问题。这一节主要是让你粗略的了解一下Glide中cache的key是如何生成，以及提供一些关于如何合理利用缓存的提示。</p>\n<h3 id=\"缓存的key\"><a href=\"#缓存的key\" class=\"headerlink\" title=\"缓存的key\"></a>缓存的key</h3><p><code>DiskCacheStrategy.RESULT</code>磁盘缓存策略（注：我们配置的一种磁盘缓存策略）使用的key由以下四个主要部分组成：</p>\n<ul>\n<li>DataFetcher的方法<code>getId()</code>返回的字符。典型地，DataFetcher仅仅返回由数据Model的<code>toString()</code>方法得到的值。所以，如果Model是一个<strong>URL</strong>，那么会返回URL的字符串，如果Model是是一个文件，那么会返回文件的<strong>路径</strong>。。。</li>\n<li>宽和高。如果你调用过override(width,height)方法，那么就是是它传入的值。没有调用过，默认是通过<strong>Target</strong>的<code>getSize()</code>方法获得这个值。</li>\n<li>各种编码器、解码器的<code>getId()</code>方法返回的字符串。这些编码器、解码器用于加载和缓存你的图片。仅有哪些堆bytes数据有影响的编码器、解码器才会有这些<code>id</code>值。比如，你只有一个将bytes数据写入磁盘的编码器，那么它就没有id值，因为不管怎样它都不会修改数据。</li>\n<li>可选地，你可以为图片加载提供签名(Signature)，请看下面的缓存失效部分。</li>\n</ul>\n<p>所有的这些key，以特定的顺序计算出hash值，并将这个值作为保存图片到磁盘上的唯一且安全的文件名。</p>\n<h3 id=\"缓存失效\"><a href=\"#缓存失效\" class=\"headerlink\" title=\"缓存失效\"></a>缓存失效</h3><p>由于文件名是hash值，没有简便的方式删除磁盘上某个特定url或者文件路径的所有缓存文件。如果仅仅缓存原文件，问题可能还比较简单，但是Glide会缓存缩略图，各种变换后的图片，所有这些缓存都会产生新文件。跟踪和删除所有文件是十分困难的。</p>\n<h3 id=\"自定义缓存失效\"><a href=\"#自定义缓存失效\" class=\"headerlink\" title=\"自定义缓存失效\"></a>自定义缓存失效</h3><p>通常情况下改变缓存的标志（key）是困难的。Glide提供了<code>signature()</code>API来混入其他数据，帮助你控制缓存的key。签名（Signature）对于多媒体或者有版本信息的内容来说都很有用。</p>\n<ul>\n<li>媒体库内容 - 对于媒体库内容，你可以使用Glide的<code>MediaStoreSignature</code>类作为签名， MediaStoreSignature类允许你混入文件修改时间、mime类型、媒体库的方向(orientation?)这些值作为缓存的key，这三个值足以让你可靠的捕捉到任何修改和更新，使你可以缓存媒体库的缩略图.?</li>\n<li>文件 - 你可以使用<code>StringSignature</code>混入文件修改时间</li>\n<li>url - 虽然使url失效最好的方式是当内容变化时，服务器修改url并更新客户端，但是你也可以用<code>StringSignature</code>混入任意的元数据（如版本号）来使缓存失效。</li>\n</ul>\n<p>使用String Signature加载数据很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourFileDataModel)</div><div class=\"line\">    .signature(<span class=\"keyword\">new</span> StringSignature(yourVersionMetadata))</div><div class=\"line\">    .into(yourImageView);</div></pre></td></tr></table></figure>\n<p>媒体库Signature可以直接使用从MeidaStore(注：一个android api）获得的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(fragment)</div><div class=\"line\">    .load(mediaStoreUri)</div><div class=\"line\">    .signature(<span class=\"keyword\">new</span> MediaStoreSignature(mimeType, dateModified, orientation))</div><div class=\"line\">    .into(view);</div></pre></td></tr></table></figure>\n<p>你还可以通过实现<code>key</code>接口来自定义签名，确保实现了<code>equals()</code>, <code>hashCode()</code>和<code>updateDiskCacheKey()</code>这几个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerVersionSignature</span> <span class=\"keyword\">implements</span> <span class=\"title\">Key</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentVersion;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IntegerVersionSignature</span><span class=\"params\">(<span class=\"keyword\">int</span> currentVersion)</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">this</span>.currentVersion = currentVersion;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> IntegerVersionSignature) &#123;</div><div class=\"line\">            IntegerVersionSignature other = (IntegerVersionSignature) o;</div><div class=\"line\">            <span class=\"keyword\">return</span> currentVersion = other.currentVersion;</div><div class=\"line\">        &#125; </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> currentVersion;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateDiskCacheKey</span><span class=\"params\">(MessageDigest md)</span> </span>&#123;</div><div class=\"line\">        messageDigest.update(ByteBuffer.allocate(Integer.SIZE).putInt(signature).array());</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>请牢记：为了避免性能下降，请在后台线程中批量加载版本元数据(metaData，注：一般查询数据库获得)，只有这样，才能确保当你想加载图片的时候，这些值是可用的。</p>\n<p>如果这些方法都失败了，比如，你不能改变标识符，也不能跟踪一个合理的版本号。你还可以使用<code>diskCacheStrategy()</code>和<code>DiskCacheStrategy.NONE.</code>来完全关闭磁盘缓存。</p>\n<hr>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"懒加载配置\"><a href=\"#懒加载配置\" class=\"headerlink\" title=\"懒加载配置\"></a>懒加载配置</h3><p>从Glide3.5开始，你可以使用<code>GlideModule</code>接口来懒加载配置Glide以及注册组件（如<code>ModelLoaders</code>)，这些配置将会在第一个Glide请求发起的时候被调用。</p>\n<h3 id=\"创建一个GlideModule\"><a href=\"#创建一个GlideModule\" class=\"headerlink\" title=\"创建一个GlideModule\"></a>创建一个GlideModule</h3><p>为了使用和注册GlideModule，首先需要实现该接口，加入你的配置和组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.mypackage; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyGlideModule</span> <span class=\"keyword\">implements</span> <span class=\"title\">GlideModule</span> </span>&#123; </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">applyOptions</span><span class=\"params\">(Context context, GlideBuilder builder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Apply options to the builder here. </span></div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerComponents</span><span class=\"params\">(Context context, Glide glide)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// register ModelLoaders here. </span></div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，添加你的实现类到<code>proguard.cfg</code>文件中，让你的module可以被反射调用到。这个性能开支很少，因为每个module只会在Glide第一次请求的时候实例化一次。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keepnames class com.mypackage.MyGlideModule</div><div class=\"line\"># or more generally:</div><div class=\"line\">#-keep public class * implements com.bumptech.glide.module.GlideModule</div></pre></td></tr></table></figure>\n<p>最后，添加meta-data标记到<code>AndroidManifest.xml</code>，那样Glide才能找到它。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- ... permissions --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta-data</span></div><div class=\"line\">            <span class=\"attr\">android:name</span>=<span class=\"string\">\"com.mypackage.MyGlideModule\"</span></div><div class=\"line\">            <span class=\"attr\">android:value</span>=<span class=\"string\">\"GlideModule\"</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- ... activities and other components --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>你可以实现任意个<code>GlideModule</code>，但是每一个都要添加到<code>proguard.cfg</code>，而且每一个GlideModule都要在manifest有自己的meta-data标记。</p>\n<h3 id=\"Library工程\"><a href=\"#Library工程\" class=\"headerlink\" title=\"Library工程\"></a>Library工程</h3><p>Library工程可能含有一个或多个<code>GlideModule</code>。当我们使用Gradle（或者任何支持manifest合并的构建工具）构建app时，如果我们所依赖的Library工程的manifest中含有module，那么这些module会自动并入到app中。如果构建工具不支持manifest合并，那么这些library工程中的module必须手动添加到你app的manifest中。</p>\n<h3 id=\"GlideModule冲突\"><a href=\"#GlideModule冲突\" class=\"headerlink\" title=\"GlideModule冲突\"></a>GlideModule冲突</h3><p>虽然Glide允许每个app注册多个<code>Glidemodule</code>，但是不会以某种特定的顺序调用这些module。所以，如果你的app中多个<code>GlideModules</code>或者依赖的library工程中有多个<code>GlideModules</code>，你必须负责避免他们之间的冲突。<br>如果冲突不可避免，app应该定义自己的默认module，这个module需要手动解决这些冲突，提供所有Library工程所需要的依赖。使用Gradle的开发者，或者使用manifest合并的开发者，可以通过下面的标签来排除冲突的module。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">”com.mypackage.MyGlideModule”</span> <span class=\"attr\">tools:node</span>=<span class=\"string\">”remove”</span> /&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h3><p>你可以配置一些作用于所有请求的全局性配置项。请使用<code>GlideModule#applyOptions</code>方法中（注：作为参数）提供给你的<code>GlideBuilder</code>来配置。本节代码示例中的<code>builder</code>就是一个GlideModule对象。</p>\n<h3 id=\"磁盘缓存\"><a href=\"#磁盘缓存\" class=\"headerlink\" title=\"磁盘缓存\"></a>磁盘缓存</h3><p>你可以使用<code>GlideBuilder</code>的<code>setDiskCache()</code>方法设置磁盘缓存的位置、大小（最大值）。你也可以使用<code>DiskCacheAdapter</code>彻底关闭缓存，或者自己实现<code>DiskCache</code>接口来换掉默认实现。磁盘缓存由<code>DiskCache.Factory</code>接口的实例在后台线程中创建，使用后台线程可以避免在严格模式中出现问题。<br>Glide默认使用<code>InternalCacheDiskCacheFactory</code>类建立磁盘缓存。这个内部缓存工厂（internal cache factory）会把磁盘缓存放到应用程序的内部缓存目录中，并且设置最大空间是250MB，使用内部缓存的目录而不是SD卡的外部目录意味着其他应用程序无法访问到你下载的图片。具体请查看Android的<a href=\"http://developer.android.com/intl/zh-cn/guide/topics/data/data-storage.html#filesInternal\">存储选项相关文档</a>。</p>\n<h4 id=\"大小\"><a href=\"#大小\" class=\"headerlink\" title=\"大小\"></a>大小</h4><p>使用<code>InternalCacheDiskCacheFactory</code>设置磁盘缓存大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDiskCache(</div><div class=\"line\">  <span class=\"keyword\">new</span> InternalCacheDiskCacheFactory(context, yourSizeInBytes));</div></pre></td></tr></table></figure>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><p>也可以设置磁盘缓存位置<br>你可以使用<code>InternalCacheDiskCacheFactory</code>来把你的磁盘缓存放到应用程序私有的内部存储目录中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDiskCache(</div><div class=\"line\">  <span class=\"keyword\">new</span> InternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));</div></pre></td></tr></table></figure>\n<p>还可以用<code>ExternalCacheDiskCacheFactory</code>来把你的磁盘缓存放到sd卡的公共缓存目录上。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDiskCache(</div><div class=\"line\">  <span class=\"keyword\">new</span> ExternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes));</div></pre></td></tr></table></figure>\n<p>如果你想用其他自定义的路径，可以用<code>DiskLruCacheFactory</code>类的构造函数来实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// If you can figure out the folder without I/O: </span></div><div class=\"line\"><span class=\"comment\">// Calling Context and Environment class methods usually do I/O. </span></div><div class=\"line\">builder.setDiskCache( </div><div class=\"line\">  <span class=\"keyword\">new</span> DiskLruCacheFactory(getMyCacheLocationWithoutIO(), yourSizeInBytes)); </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// In case you want to specify a cache folder (\"glide\"): </span></div><div class=\"line\">builder.setDiskCache( </div><div class=\"line\">  <span class=\"keyword\">new</span> DiskLruCacheFactory(getMyCacheLocationWithoutIO(), <span class=\"string\">\"glide\"</span>, yourSizeInBytes)); </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// In case you need to query the file system while determining the folder: </span></div><div class=\"line\">builder.setDiskCache(<span class=\"keyword\">new</span> DiskLruCacheFactory(<span class=\"keyword\">new</span> CacheDirectoryGetter() &#123; </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getCacheDirectory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> getMyCacheLocationBlockingIO(); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;), yourSizeInBytes);</div></pre></td></tr></table></figure>\n<p>注意：请牢记，写死任何值都不是个好主意，尤其是目录的路径，因为自Android4.2开始，支持单设备多用户。</p>\n<p>如果你想完全控制缓存的创建，可以自己实现<code>DiskCache.Factory</code>接口，使用<code>DiskLruCacheWrapper</code>可以在你想要的位置创建一个新的缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDiskCache(<span class=\"keyword\">new</span> DiskCache.Factory() &#123; </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> DiskCache <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        File cacheLocation = getMyCacheLocationBlockingIO();</div><div class=\"line\">        cacheLocation.mkdirs();</div><div class=\"line\">        <span class=\"keyword\">return</span> DiskLruCacheWrapper.get(cacheLocation, yourSizeInBytes);</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"内存缓存和缓存池\"><a href=\"#内存缓存和缓存池\" class=\"headerlink\" title=\"内存缓存和缓存池\"></a>内存缓存和缓存池</h3><p><code>GlideBuilder</code>类允许你设置内存缓存大小，而且可以实现自定义的<code>MemoryCache</code>和<code>BitmapPool</code>。</p>\n<h4 id=\"大小-1\"><a href=\"#大小-1\" class=\"headerlink\" title=\"大小\"></a>大小</h4><p>默认大小是由<code>MemorySizeCalculator</code>类决定的。MemorySizeCalculator类会考虑该设备的屏幕大小、可用内存来计算出一个合理的默认值。如果你想调整这个默认值，请构建自己的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MemorySizeCalculator calculator = <span class=\"keyword\">new</span> MemorySizeCalculator(context);</div><div class=\"line\"><span class=\"keyword\">int</span> defaultMemoryCacheSize = calculator.getMemoryCacheSize();</div><div class=\"line\"><span class=\"keyword\">int</span> defaultBitmapPoolSize = calculator.getBitmapPoolSize();</div></pre></td></tr></table></figure>\n<p>如果你想在应用的某个阶段动态调整Glide的内存占用，你可以选择一个<code>MemoryCategory</code>并使用<code>setMemoryCategory()</code>方法传入Glide中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.get(context).setMemoryCategory(MemoryCategory.HIGH);</div></pre></td></tr></table></figure>\n<h4 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h4><p>Glide的内存缓存会在内存中持有资源，它的作用是，我们可以不进行IO操作而快速获得可用资源。<br>你可以使用<code>GlideBuilder</code>的<code>setMemoryCache()</code>方法设置大小，或者设置你关于内存缓存的自定义实现（自定义类）。<code>LruResourceCache</code>类是Glide的默认实现。你可以通过<code>LruResourceCache</code>的构造函数来配置内存占用的bytes的最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setMemoryCache(<span class=\"keyword\">new</span> LruResourceCache(yourSizeInBytes));</div></pre></td></tr></table></figure>\n<h4 id=\"Bitmap池\"><a href=\"#Bitmap池\" class=\"headerlink\" title=\"Bitmap池\"></a>Bitmap池</h4><p>Glide的Bitmap池主要作用是，可以让各种尺寸的Bitmap被复用，可以可观地减少由垃圾回收引起的内存抖动。在解码图片时，需要给像素数组分配空间，这会触发垃圾回收。<br>你可以使用<code>GlideBuilder</code>的<code>setBitmapPool()</code>方法设置大小，或者设置你关于Bitmap池的自定义实现，<code>LruBitmapPool</code>类是Glide的默认实现。LruBitmapPool类使用了LRU算法维护最近最常使用的Bitmap的尺寸。你可以通过<code>LruBitmapPool</code>的构造函数配置内存占用的bytes的最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setBitmapPool(<span class=\"keyword\">new</span> LruBitmapPool(sizeInBytes));</div></pre></td></tr></table></figure>\n<h3 id=\"Bitmap格式\"><a href=\"#Bitmap格式\" class=\"headerlink\" title=\"Bitmap格式\"></a>Bitmap格式</h3><p><code>GlideBuilder</code> 类也允许你配置一个App全局使用的Bitmap的Config属性。<br>Glide默认使用RGB_565，因为它每个像素只需要2bytes（16bit）的空间，它仅需要高质量图片（既系统默认的<code>ARGB_8888</code>）一半的内存空间。但是，这对于某些图片这可能会出现『条带』的问题，而且它也不支持透明度。<br>如果在你的应用中『条带』是一个重要的问题，或者你需要尽可能好的图片质量，你可以使用<code>GlideBuilder</code>的<code>setDecodeFormat</code>方法设置DecodeFormat.ALWAYS_ARGB_8888作为首选配置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"自定义目标（Targets）\"><a href=\"#自定义目标（Targets）\" class=\"headerlink\" title=\"自定义目标（Targets）\"></a>自定义目标（Targets）</h2><p>除了可以加载图像，视频剧照，gif动画到View中，你还可以加载他们到实现了Target接口的自定义目标中。</p>\n<h3 id=\"SimpleTarget\"><a href=\"#SimpleTarget\" class=\"headerlink\" title=\"SimpleTarget\"></a>SimpleTarget</h3><p>如果你只是想加载一个Bitmap，并不想直接展示给用户而是有一些特殊用途，比如在通知栏中显示或者作为头像上传。<br>Glide也可以做到。<br>SimpleTarget为Target接口提供了大部分的默认实现。你可以专注于处理加载的结果。<br>为了使用SimpleTarget，你需要在它的构造函数中提供你要加载的资源的宽和高（单位像素），你还需要实现<code>onResourceReady(T resource, GlideAnimation animation)</code>方法。<br>一个典型的使用SimpleTarget的例子如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> myWidth = <span class=\"number\">512</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> myHeight = <span class=\"number\">384</span>;</div><div class=\"line\"> </div><div class=\"line\">Glide.with(yourApplicationContext)) </div><div class=\"line\">    .load(youUrl) </div><div class=\"line\">    .asBitmap() </div><div class=\"line\">    .into(<span class=\"keyword\">new</span> SimpleTarget&lt;Bitmap&gt;(myWidth, myHeight) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span> </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(Bitmap bitmap, GlideAnimation anim)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// Do something with bitmap here. </span></div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"一些警告\"><a href=\"#一些警告\" class=\"headerlink\" title=\"一些警告\"></a>一些警告</h4><p>正常情况下，你加载一个资源会把他们放到view中。当你的Activity或者Fragment被pause或者destroy时，Glide会暂停或取消加载，确保你不会加载那些根本不会显示的资源。<br>可是当我们使用SimpleTarget的时候，这可能并不是我们希望的行为。所以，当你调用<code>Glide.with(context)</code>的时候，你可以传入Application的context，而不是传入Activity或者Fragment。<br>此外，考虑到长时间的加载操作可能导致内存泄漏，请考虑使用静态内部类，而不是匿名内部类。</p>\n<h3 id=\"ViewTarget\"><a href=\"#ViewTarget\" class=\"headerlink\" title=\"ViewTarget\"></a>ViewTarget</h3><p>如果你想加载一个图片到View中，但是你想观察或者覆盖Glide的默认行为。你可以覆盖ViewTarget或者它的子类。<br>当你想让Glide来获取view的的大小，但是由自己来启动动画和设置资源到view中，ViewTarget是个不错的选择。如果你要加载一个图片到ImageView之外的自定义view中，那么ImageViewTarget或者它的子类就不能满足你的要求，此时继承ViewTarget就特别合适。<br>你可以静态的定义一个ViewTarget的子类，或者传递一个匿名内部类到你的加载调用里：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .into(<span class=\"keyword\">new</span> ViewTarget&lt;YourViewClass, GlideDrawable&gt;(yourViewObject) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(GlideDrawable resource, GlideAnimation anim)</span> </span>&#123;</div><div class=\"line\">            YourViewClass myView = <span class=\"keyword\">this</span>.view;</div><div class=\"line\">            <span class=\"comment\">// Set your resource on myView and/or start your animation here.</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>注意，如果你想指定加载Bitmap还是GifDrawable，请在<code>.load(yourUrl)</code>调用后面直接添加<code>.asBitmap()</code>或者<code>.asGif()</code>，同时将ViewTarget的类型参数<code>GlideDrawable</code>换成对应加载的类型。<br>为了更多控制，你也可以在Target实现<code>LifecycleListener</code>回调，<code>onStart()</code>、<code>onStop()</code>或者<code>onDestroy()</code>会和你view所在的fragment的生命周期保持同步。</p>\n<h3 id=\"覆盖默认行为\"><a href=\"#覆盖默认行为\" class=\"headerlink\" title=\"覆盖默认行为\"></a>覆盖默认行为</h3><p>如果你只想观察不想修改Glide的默认行为，你可以继承任何一个Glide对ImageViewTargets的默认实现。</p>\n<ul>\n<li>GlideDrawableImageViewTarget - 默认的Target，用于正常的加载和<code>asGif()</code>。</li>\n<li>BitmapImageViewTarget - 当使用<code>asBitmap()</code>加载时，使用的默认Target。</li>\n</ul>\n<p>只有你在每个方法里面调用<code>super()</code>，将会保留默认的行为，同时还可以添加一些你希望的功能。</p>\n<p>例如，想要生成一个<a href=\"http://chris.banes.me/2014/07/04/palette-preview/\">调色板</a>，你可以这样做。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment) </div><div class=\"line\">    .load(yourUrl) </div><div class=\"line\">    .asBitmap() </div><div class=\"line\">    .into(<span class=\"keyword\">new</span> BitmapImageViewTarget(yourImageView)) &#123; </div><div class=\"line\">        <span class=\"meta\">@Override</span> </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(Bitmap bitmap, GlideAnimation anim)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.onResourceReady(bitmap, anim);</div><div class=\"line\">            Palette.generateAsync(bitmap, <span class=\"keyword\">new</span> Palette.PaletteAsyncListener() &#123;  </div><div class=\"line\">                <span class=\"meta\">@Override</span> </div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onGenerated</span><span class=\"params\">(Palette palette)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"comment\">// Here's your generated palette </span></div><div class=\"line\">                &#125; </div><div class=\"line\">            &#125;); </div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>虽然这个例子还不错，但是，通常情况下，我不推荐用这个方式生成调色板。请查看Glide的 <code>ResourceTranscoder</code> 接口和<code>.transcode()</code>方法，考虑返回一个包含Bitmap和调色板的自定义资源。调色板可在在后台线程生成。？？？？？更多内容会在以后推出。。。</p>\n<hr>\n<h2 id=\"调试和错误处理\"><a href=\"#调试和错误处理\" class=\"headerlink\" title=\"调试和错误处理\"></a>调试和错误处理</h2><p>Glide在加载过程中出现异常默认情况下不会打日志。Glide为你提供了两种方式查看和处理这些异常。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>仅仅为了查看异常的话，你可以为<code>GenericRequest</code>类打开Debug日志。这个类处理所有媒体资源的加载响应（response）。你可以在命令行里运行：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell setprop log.tag.GenericRequest DEBUG</div></pre></td></tr></table></figure>\n<p>想要包括详细的请求时序信息，你可以把<code>DEBUG</code>缓存<code>VERBOSE</code>。</p>\n<p>关闭日志使用：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell setprop log.tag.GenericRequest ERROR</div></pre></td></tr></table></figure>\n<h3 id=\"调试工作流\"><a href=\"#调试工作流\" class=\"headerlink\" title=\"调试工作流\"></a>调试<a href=\"https://docs.google.com/drawings/d/1KyOJkNd5Dlm8_awZpftzW7KtqgNR6GURvuF6RfB210g/edit\">工作流</a></h3><p>为了查看内部引擎（engine）如何以及何时查找到资源，你可以打开日志：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell setprop log.tag.Engine VERBOSE</div><div class=\"line\">adb shell setprop log.tag.EngineJob VERBOSE</div><div class=\"line\">adb shell setprop log.tag.DecodeJob VERBOSE</div></pre></td></tr></table></figure>\n<p>打开这个有助于你找出为什么某个资源没有从内存缓存中加载，为什么请求再次从外部的url下载数据。这也可以帮助你了解：如果想命中磁盘缓存，什么样的参数需要匹配。启用<code>DecodeJob</code>日志也可以帮助你去定位自定义transformation/decoder/encoder相关的问题。</p>\n<h3 id=\"监听请求-RequestListener\"><a href=\"#监听请求-RequestListener\" class=\"headerlink\" title=\"监听请求-RequestListener\"></a>监听请求-RequestListener</h3><p>虽然启用debug日志很简单，但是只有在你可以连接到设备时才能这样干。为了把Glide集成到已有的更专业的错误日志系统。你可以使用<code>RequestListener</code>类的<code>onException()</code>。当请求失败时，该方法会告知你导致失败的<code>异常</code>(Exception)，如果解码器（Decoder）不能从数据中解析出任何有用的信息，Exception也可能传<code>null</code>。你可以使用<code>listener()</code>API传一个你的监听器（listener）到每一个请求中。<br>请确保<code>onException()</code>返回<code>false</code>，以免覆盖了Glide的默认错误处理行为（例如，它默认会通知<code>Target</code>这个error）。<br>这是一个快速调试的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// example usage: .listener(new LoggingListener&lt;String, GlideDrawable&gt;()) </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggingListener</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RequestListener</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onException</span><span class=\"params\">(Exception e, Object model, Target target, <span class=\"keyword\">boolean</span> isFirstResource)</span> </span>&#123;</div><div class=\"line\">        android.util.Log.d(<span class=\"string\">\"GLIDE\"</span>, String.format(Locale.ROOT,</div><div class=\"line\">                <span class=\"string\">\"onException(%s, %s, %s, %s)\"</span>, e, model, target, isFirstResource), e);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(Object resource, Object model, Target target, <span class=\"keyword\">boolean</span> isFromMemoryCache, <span class=\"keyword\">boolean</span> isFirstResource)</span> </span>&#123;</div><div class=\"line\">        android.util.Log.d(<span class=\"string\">\"GLIDE\"</span>, String.format(Locale.ROOT,</div><div class=\"line\">                <span class=\"string\">\"onResourceReady(%s, %s, %s, %s, %s)\"</span>, resource, model, target, isFromMemoryCache, isFirstResource));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>确保发版前移除相关代码</strong></p>\n<h3 id=\"更多日志\"><a href=\"#更多日志\" class=\"headerlink\" title=\"更多日志\"></a>更多日志</h3><p>这个列表是给3.6.0版本用的，可能不完整。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd .../android-sdk/platform-tools</div><div class=\"line\">adb shell setprop log.tag.AnimatedGifEncoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.AssetUriFetcher VERBOSE</div><div class=\"line\">adb shell setprop log.tag.BitmapEncoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.BufferedIs VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ByteArrayPool VERBOSE</div><div class=\"line\">adb shell setprop log.tag.CacheLoader VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ContentLengthStream VERBOSE</div><div class=\"line\">adb shell setprop log.tag.DecodeJob VERBOSE</div><div class=\"line\">adb shell setprop log.tag.DiskLruCacheWrapper VERBOSE</div><div class=\"line\">adb shell setprop log.tag.Downsampler VERBOSE</div><div class=\"line\">adb shell setprop log.tag.Engine VERBOSE</div><div class=\"line\">adb shell setprop log.tag.EngineRunnable VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GenericRequest VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GifDecoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GifEncoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GifHeaderParser VERBOSE</div><div class=\"line\">adb shell setprop log.tag.GifResourceDecoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.Glide VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ImageHeaderParser VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ImageVideoDecoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.IVML VERBOSE</div><div class=\"line\">adb shell setprop log.tag.LocalUriFetcher VERBOSE</div><div class=\"line\">adb shell setprop log.tag.LruBitmapPool VERBOSE</div><div class=\"line\">adb shell setprop log.tag.MediaStoreThumbFetcher VERBOSE</div><div class=\"line\">adb shell setprop log.tag.MemorySizeCalculator VERBOSE</div><div class=\"line\">adb shell setprop log.tag.PreFillRunner VERBOSE</div><div class=\"line\">adb shell setprop log.tag.ResourceLoader VERBOSE</div><div class=\"line\">adb shell setprop log.tag.RMRetriever VERBOSE</div><div class=\"line\">adb shell setprop log.tag.StreamEncoder VERBOSE</div><div class=\"line\">adb shell setprop log.tag.TransformationUtils VERBOSE</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"使用Glide下载自定义大小的图片\"><a href=\"#使用Glide下载自定义大小的图片\" class=\"headerlink\" title=\"使用Glide下载自定义大小的图片\"></a>使用Glide下载自定义大小的图片</h2><p>开发者可以通过Glide的ModelLoader接口获得图片大小，并根据这个大小来加载一个合适尺寸的图片url。<br>使用合适尺寸的图片可以节约带宽，设备的存储空间，还可以提升app性能。<br>2014年的Google I/O app团队写了一篇关于如何使用ModelLoader接口调整加载的图片大小的文章。请在GitHub上查看 <a href=\"https://github.com/google/iosched/blob/master/doc/IMAGES.md\">I/O app的源码</a>。<br>为了实现自定义的ModelLoader来通过http/https下载图片，可以继承BaseGlideUrlLoader这个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyDataModel</span> </span>&#123; </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">buildUrl</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</div><div class=\"line\">&#125;  </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUrlLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseGlideUrlLoader</span>&lt;<span class=\"title\">MyDataModel</span>&gt; </span>&#123; </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">getUrl</span><span class=\"params\">(MyDataModel model, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Construct the url for the correct size here. </span></div><div class=\"line\">        <span class=\"keyword\">return</span> model.buildUrl(width, height);</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，你就可以使用自定义的ModelLoader来加载图片了，其他的事情会自动完成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .using(<span class=\"keyword\">new</span> MyUrlLoader())</div><div class=\"line\">    .load(yourModel)</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>如果你想避免调用<code>.using(new  MyUrlLoader())</code>，你可以实现一个自定义的<code>ModelLoaderFactory</code>，并在<code>GlideModule</code>中注册它。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyGlideModule</span> <span class=\"keyword\">implements</span> <span class=\"title\">GlideModule</span> </span>&#123; </div><div class=\"line\">    ... </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerComponents</span><span class=\"params\">(Context context, Glide glide)</span> </span>&#123;</div><div class=\"line\">        glide.register(MyDataModel.class, InputStream.class, </div><div class=\"line\">            <span class=\"keyword\">new</span> MyUrlLoader.Factory()); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注册ModelLoaderFactory之后，你就不用调用<code>.using()</code>了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourModel)</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>其他的例子，关于如何使用自定义ModelLoader加载各种尺寸的图片，请查看<a href=\"https://github.com/bumptech/glide/blob/master/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java\">Flicker示例应用</a>，和<a href=\"https://github.com/bumptech/glide/blob/master/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java\">Giphy示例应用</a>。</p>\n<hr>\n<h2 id=\"集成（Integration）库-Glide与其他库整合\"><a href=\"#集成（Integration）库-Glide与其他库整合\" class=\"headerlink\" title=\"集成（Integration）库-Glide与其他库整合\"></a>集成（Integration）库-Glide与其他库整合</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>####什么是集成库（Integration Library）<br>Glide包括一系列小巧可配置的集成库，这些库可以让Glide与外部的库相结合。现在集成库可以使Glide支持Volley和OkHttp的http/https请求。</p>\n<p>我们坚信，您所选择的客户端媒体库既不应该决定你在你的应用程序中使用的网络库，也不需要你仅仅为了加载图像额外添加网络库。集成库和Glide的ModelLoader系统，允许开发人员对所有网络请求使用统一的网络库。</p>\n<h4 id=\"为什么没有XXX库的实现\"><a href=\"#为什么没有XXX库的实现\" class=\"headerlink\" title=\"为什么没有XXX库的实现\"></a>为什么没有XXX库的实现</h4><p>因为我们还没有为这个库写集成库。OkHttp和Volley是十分流行的库，许多开发者都使用，但是，我们不是排斥其他库，如果你写了其他库的<code>ModelLoader</code>并且打算开源，我们很乐意看到这样的提交请求（pull request）。</p>\n<h4 id=\"我如何依赖一个集成库呢？\"><a href=\"#我如何依赖一个集成库呢？\" class=\"headerlink\" title=\"我如何依赖一个集成库呢？\"></a>我如何依赖一个集成库呢？</h4><p>依赖任何的集成库需要两g个步骤。</p>\n<ol>\n<li>添加相应的继承库的Maven/Gradle/jar依赖，因为作为可选项的集成库并不包含在glide的jar依赖中。</li>\n<li>确保app包含了集成库的GlideModule，具体内容看<a href=\"https://github.com/bumptech/glide/wiki/Configuration\">配置wiki</a>部分。对于Glide集成库的具体说明见下面。</li>\n</ol>\n<h4 id=\"我应当选择哪个版本？\"><a href=\"#我应当选择哪个版本？\" class=\"headerlink\" title=\"我应当选择哪个版本？\"></a>我应当选择哪个版本？</h4><p>集成库的版本跟随着Glide的release版本。但是多了一个不同的数字。确保选择与所依赖的Glide对应的集成库。在<a href=\"https://github.com/bumptech/glide/releases\">release页</a>查看.<br>网络库有自己的版本号。继承库会依赖的库就是你在Maven/Gradle中指定的库。你可以通过版本号来指定具体依赖的网络库。？？</p>\n<h3 id=\"Volley\"><a href=\"#Volley\" class=\"headerlink\" title=\"Volley\"></a>Volley</h3><p>Volley是一个Http库，可以使Android上的网络请求更简单，更快速。</p>\n<h4 id=\"Gradle中使用Volley\"><a href=\"#Gradle中使用Volley\" class=\"headerlink\" title=\"Gradle中使用Volley\"></a>Gradle中使用Volley</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile <span class=\"string\">'com.github.bumptech.glide:volley-integration:1.3.1@aar'</span></div><div class=\"line\">    <span class=\"comment\">//compile 'com.mcxiaoke.volley:library:1.0.8'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>集成库的<code>GlideModule</code>会自动合并到你app的manifest中。</p>\n<h4 id=\"Maven中是Volley\"><a href=\"#Maven中是Volley\" class=\"headerlink\" title=\"Maven中是Volley\"></a>Maven中是Volley</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.bumptech.glide<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>volley-integration<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>aar<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.mcxiaoke.volley<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>library<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0.8<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>aar<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>请查看对应的manifest章节，了解如何添加对应的GlideModule。</p>\n<h4 id=\"手动添加Volley\"><a href=\"#手动添加Volley\" class=\"headerlink\" title=\"手动添加Volley\"></a>手动添加Volley</h4><p>从<a href=\"https://github.com/bumptech/glide/releases\">release页</a>下载<a href=\"https://github.com/bumptech/glide/releases/download/v3.6.1/glide-volley-integration-1.3.1.jar\">glide-volley-integration-<version>.jar </a>。并添加到你app的编译路径中(compile classpath)。</p>\n<p>请查看对应的manifest章节，了解如何添加对应的GlideModule。</p>\n<h4 id=\"Volley的Manifest\"><a href=\"#Volley的Manifest\" class=\"headerlink\" title=\"Volley的Manifest\"></a>Volley的Manifest</h4><p>如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加<code>GlideModule</code>的metadata标签到<code>AndroidManifest.xml</code>中。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span></div><div class=\"line\">    <span class=\"attr\">android:name</span>=<span class=\"string\">\"com.bumptech.glide.integration.volley.VolleyGlideModule\"</span></div><div class=\"line\">    <span class=\"attr\">android:value</span>=<span class=\"string\">\"GlideModule\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"Volley的混淆设置\"><a href=\"#Volley的混淆设置\" class=\"headerlink\" title=\"Volley的混淆设置\"></a>Volley的混淆设置</h4><p>无论使用什么编译系统，不要混淆<code>VolleyGlideModule</code>类，它需要被反射来实例化。添加下面的代码到<code>proguard.cfg</code>文件（或者查看“通用部分”）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keep <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">bumptech</span>.<span class=\"title\">glide</span>.<span class=\"title\">integration</span>.<span class=\"title\">volley</span>.<span class=\"title\">VolleyGlideModule</span></span></div></pre></td></tr></table></figure>\n<h3 id=\"OkHttp\"><a href=\"#OkHttp\" class=\"headerlink\" title=\"OkHttp\"></a>OkHttp</h3><p>OKHttp是一个高效且易于使用的Http客户端。</p>\n<h4 id=\"Gradle中使用OkHttp\"><a href=\"#Gradle中使用OkHttp\" class=\"headerlink\" title=\"Gradle中使用OkHttp\"></a>Gradle中使用OkHttp</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile <span class=\"string\">'com.github.bumptech.glide:okhttp-integration:1.3.1@aar'</span></div><div class=\"line\">    <span class=\"comment\">//compile 'com.squareup.okhttp:okhttp:2.2.0'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>集成库的<code>GlideModule</code>会自动合并到你app的manifest中。</p>\n<h4 id=\"Maven中是OkHttp\"><a href=\"#Maven中是OkHttp\" class=\"headerlink\" title=\"Maven中是OkHttp\"></a>Maven中是OkHttp</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.bumptech.glide<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>okhttp-integration<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>aar<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!--</div><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.squareup.okhttp&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;2.2.0&lt;/version&gt;</div><div class=\"line\">    &lt;type&gt;jar&lt;/type&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">--&gt;</span></div></pre></td></tr></table></figure>\n<p>请查看对应的manifest章节，了解如何添加对应的GlideModule。</p>\n<h4 id=\"手动添加OkHttp\"><a href=\"#手动添加OkHttp\" class=\"headerlink\" title=\"手动添加OkHttp\"></a>手动添加OkHttp</h4><p>从<a href=\"https://github.com/bumptech/glide/releases\">release页</a>下载<a href=\"https://github.com/bumptech/glide/releases/download/v3.6.1/glide-okhttp-integration-1.3.1.jar\">glide-okhttp-integration-<version>.jar </a>。并添加到你app的编译路径中(compile classpath)。</p>\n<p>请查看对应的manifest章节，了解如何添加对应的GlideModule。</p>\n<h4 id=\"OkHttp的Manifest\"><a href=\"#OkHttp的Manifest\" class=\"headerlink\" title=\"OkHttp的Manifest\"></a>OkHttp的Manifest</h4><p>如果你使用那些不支持manifest合并的编译系统（如Maven，Ant），你必须手动添加<code>GlideModule</code>的metadata标签到<code>AndroidManifest.xml</code>中。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span></div><div class=\"line\">    <span class=\"attr\">android:name</span>=<span class=\"string\">\"com.bumptech.glide.integration.okhttp.OkHttpGlideModule\"</span></div><div class=\"line\">    <span class=\"attr\">android:value</span>=<span class=\"string\">\"GlideModule\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"OkHttp的混淆设置\"><a href=\"#OkHttp的混淆设置\" class=\"headerlink\" title=\"OkHttp的混淆设置\"></a>OkHttp的混淆设置</h4><p>无论使用什么编译系统，不要混淆<code>OkHttpGlideModule</code>类，它需要被反射来实例化。添加下面的代码到<code>proguard.cfg</code>文件（或者查看“通用部分”）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keep <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">bumptech</span>.<span class=\"title\">glide</span>.<span class=\"title\">integration</span>.<span class=\"title\">okhttp</span>.<span class=\"title\">OkHttpGlideModule</span></span></div></pre></td></tr></table></figure>\n<h3 id=\"更多选项\"><a href=\"#更多选项\" class=\"headerlink\" title=\"更多选项\"></a>更多选项</h3><h4 id=\"通用的混淆配置\"><a href=\"#通用的混淆配置\" class=\"headerlink\" title=\"通用的混淆配置\"></a>通用的混淆配置</h4><p>你也可以使用下面的配置来避免混淆所有的<code>GlideModule</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keep <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> * <span class=\"keyword\">implements</span> <span class=\"title\">com</span>.<span class=\"title\">bumptech</span>.<span class=\"title\">glide</span>.<span class=\"title\">module</span>.<span class=\"title\">GlideModule</span></span></div></pre></td></tr></table></figure>\n<p>这种方式有其他的好处，当修改集成库或者自定义集成库的行为时，不需要修改。当你添加或者移动其他module的时候，也不需要修改什么。</p>\n<h4 id=\"覆盖默认的行为\"><a href=\"#覆盖默认的行为\" class=\"headerlink\" title=\"覆盖默认的行为\"></a>覆盖默认的行为</h4><p>如果默认配置无法满足你，所有的集成库还有一些额外的选项。比如添加重试行为，请查看集成库的<code>GlideModule</code>的源码（位于<a href=\"https://github.com/bumptech/glide/tree/3.0/integration\">/integration/<lib>/src/main/java/<package></a>）了解默认的注册做了些什么。你可以通过在自定义的<code>GlideModule</code>中修改参数为<code>UrlLoader.Factory</code>类来改变默认行为。<br>当你要覆盖默认行为时，请确保自定义的<code>GlideModule</code>被注册，且默认的GlideModule被排除在外。排除GlideModule可能是从manifest中移除相应的的metadata，或者使用jar包依赖代替aar依赖。关于<code>GlideModule</code>的更多信息请查看<a href=\"https://github.com/bumptech/glide/wiki/Configuration\">配置的wiki页</a>\\</p>\n<hr>\n<h2 id=\"在后台线程中加载和缓存\"><a href=\"#在后台线程中加载和缓存\" class=\"headerlink\" title=\"在后台线程中加载和缓存\"></a>在后台线程中加载和缓存</h2><p>为了使后台加载资源和与媒体交互更加容易，除了<code>Glide.with(fragment).load(url).into(view)</code>这个API外，Glide还提供了额外两个API。</p>\n<ul>\n<li><code>downloadOnly(int, int)</code></li>\n<li><code>into(int, int)</code></li>\n</ul>\n<h3 id=\"downloadOnly方法\"><a href=\"#downloadOnly方法\" class=\"headerlink\" title=\"downloadOnly方法\"></a>downloadOnly方法</h3><p>Glide的<code>downloadOnly(int, int)</code>方法允许你把图片bytes下载到磁盘缓存中，以便以后获取使用。你可以在UI线程异步地调用<code>downloadOnly()</code>，也可以在后台线程同步的使用。但是，注意他们的参数有些不同，异步API的参数是<code>Target</code>，同步api的参数是宽和高的整数值。<br>为了在后台线程下载图片，你必须使用同步方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">FutureTarget&lt;File&gt; future = Glide.with(applicationContext)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .downloadOnly(<span class=\"number\">500</span>, <span class=\"number\">500</span>);</div><div class=\"line\">File cacheFile = future.get();</div></pre></td></tr></table></figure>\n<p>当future返回时，图片的bytes数据就在缓存中可用了。一种典型的情况是，你使用<code>downloadOnly()</code>API只是为了确保数据下载到了磁盘上。一般情况下，虽然你有权访问底层的缓存文件，但是你不需要直接和它交互。<br>而是，当你想要获取这个图片时，你只要像平常加载图片时那样调用就行，<strong>只有一点不同</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .diskCacheStrategy(DiskCacheStrategy.ALL)</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>通过传入 <code>DiskCacheStrategy.ALL</code>或者<code>DiskCacheStrategy.SOURCE</code>，确保Glide可以使用你通过<code>downloadOnly()</code>下载的数据。</p>\n<h3 id=\"into方法\"><a href=\"#into方法\" class=\"headerlink\" title=\"into方法\"></a>into方法</h3><p>如果你想在一个<strong>后台线程</strong>与一张已经解码的图片交互。你可以使用这个版本的<code>into()</code>方法来返回一个<code>FutureTarget</code>。例如，获取一张中心剪裁后的500*500像素的图片：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bitmap myBitmap = Glide.with(applicationContext)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .centerCrop()</div><div class=\"line\">    .into(<span class=\"number\">500</span>, <span class=\"number\">500</span>)</div><div class=\"line\">    .get()</div></pre></td></tr></table></figure>\n<p>虽然<code>into(int, int)</code>方法在后台线程中很有效，但是，你不能把它用在主线程中。即使这个同步方法在你的主线程中不会抛出异常，调用get()也会阻塞主线程。会使你的APP性能变差，反应迟钝。</p>\n<hr>\n<h2 id=\"Glide中的资源复用\"><a href=\"#Glide中的资源复用\" class=\"headerlink\" title=\"Glide中的资源复用\"></a>Glide中的资源复用</h2><h3 id=\"为什么-资源复用的作用\"><a href=\"#为什么-资源复用的作用\" class=\"headerlink\" title=\"为什么 - 资源复用的作用\"></a>为什么 - 资源复用的作用</h3><p>Glide通过复用资源避免不必要的内存分配。Dalvik虚拟机（在Lollipop之前）有两种基本的垃圾回收方式，<code>GC_CONCURRENT</code> 和<code>GC_FOR_ALLOC</code>。每次<code>GC_CONCURRENT</code>会阻塞主线程5ms。由于每次操作的时间少于16ms（1帧的时间），<code>GC_CONCURRENT</code>并不会引起掉帧。相反的是<code>GC_FOR_ALLOC</code>，他会停止所有操作，阻塞主线程125+ms，事实上，GC_FOR_ALLOC总是会让你的app掉很多帧。尤其是在滑动时，导致明显的卡顿。<br>很不幸，即使只是分配适当的空间（比如16kb的buffer）Dalvik表现的也很糟糕。不断的小内存分配，或者一次大的内存分配（比如说bitmap），将会引起GC_FOR_ALLOC。因此，你分配内存的越多，你会遇到垃圾回收器阻塞应用的情况就越多，应用掉帧就越严重。<br>通过适度复用大块资源，Glide可以避免内存抖动，减少垃圾回收器阻塞app的次数。</p>\n<h3 id=\"怎么做-Glide是如何复用资源\"><a href=\"#怎么做-Glide是如何复用资源\" class=\"headerlink\" title=\"怎么做 - Glide是如何复用资源\"></a>怎么做 - Glide是如何复用资源</h3><p>Glide的资源复用策略比较宽松。这意味着，当Glide认为该资源可以被安全的复用时，才有几率去复用它，并不需要开发者在每个request后面去手动释放资源。</p>\n<h4 id=\"标志-哪些资源可复用\"><a href=\"#标志-哪些资源可复用\" class=\"headerlink\" title=\"标志-哪些资源可复用\"></a>标志-哪些资源可复用</h4><p>Glide有两个简单的标志来识别可复用的资源。</p>\n<ol>\n<li><p><code>Glide.clear()</code> </p>\n<p> 在<code>View</code>或者<code>Target</code>上调用<code>clear()</code>方法都表示，Glide要取消加载，可以安全地把Target占用的所有资源（Bitmap，bytes数组等）放入资源池中（pool）。用户可以在任何时候安全地手动调用<code>clear()</code>方法，但是典型情况下，我们不需要这样做，看第二条。</p>\n</li>\n<li><p>View或者Target的复用 </p>\n<p> 当用户把图片加载到一个已经存在的View或者Target上时（注：确切的说是调用<code>into(xxx)</code>方法之后），Glide会先调用<code>clear()</code>清空该View/Target上的加载请求并复用已经显示过的资源。因此，如果你的ListView或者RecyclerView中的view使用了复用机制（注：如ViewHolder），那么Glide会自动为他们缓存资源和管理加载请求。</p>\n</li>\n</ol>\n<h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>如果两个请求指向同一个资源，为了避免额外的工作，Glide会把单个资源分配给他们。这就导致一个问题，当Glide得知某个资源不被某个调用者使用，这并不表示它不会被其他调用者使用。为了避免回收调依旧被使用的资源，Glide使用引用计数来跟踪资源。<br>当把资源提供给View/Target时，该资源的引用计数加1，当清空View/Target时，引用计数减1。当引用计数为0时，Glide会回收资源，并把它的内容放回可用内存池中。</p>\n<h4 id=\"放入缓存池\"><a href=\"#放入缓存池\" class=\"headerlink\" title=\"放入缓存池\"></a>放入缓存池</h4><p>Glide的Resource API有一个<code>recycle()</code>方法，当Glide认为资源不再被引用时，会调用该方法，资源会放入缓存池中。</p>\n<p>Glide提供的BitmapPool接口可以让Resource获取<code>Bitmap</code>和复用Bitmap对象。Glide的BitmapPool可以通过Glide单例获得：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.get(context).getBitmapPool();</div></pre></td></tr></table></figure>\n<p>ResourceDecoder可以返回Resource的任何实现。所有，开发者可以实现他们自己的Resource和ResourceDecoder来自定义地缓存一些特有类型的数据。<br>同样地，开发者如果想更多地控制Bitmap缓存，可以实现自己的BitmapPool，然后通过GlideModule配置到Glide中。</p>\n<h3 id=\"常见的错误\"><a href=\"#常见的错误\" class=\"headerlink\" title=\"常见的错误\"></a>常见的错误</h3><p>不幸的是，缓存池设计使我们很难判断开发者是否误用了资源或者bitmap。但是，在Glide中有两个主要的现象会暗示你某些地方可能出了问题。</p>\n<h4 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h4><ol>\n<li><p><code>Cannot draw a recycled Bitmap</code></p>\n<p> Glide有个固定大小的Bitmap池。当Bitmap不再被复用（注：不是使用，区分使用和复用），会从池中移走。Glide会调用<a href=\"http://developer.android.com/reference/android/graphics/Bitmap.html#recycle(\"><code>recycle()</code></a>)（注：指的是Bitmap真正的recycle，不是Resource类的recycle）。你告诉Glide放心地回收某个Bitmap，但是，你的应用不小心还持有这个Bitmap的引用，应用程序可能会绘制这个Bitmap，导致崩溃。</p>\n</li>\n<li><p>View在多张图片之间闪烁，或者同样的图片出现在多个View中</p>\n<p> 如果一张图片被放入BitmapPool中多次。或者虽然一张图片被放入了pool中，但是某个View依然持有这个图的引用，与此同时，另一张图片被解析成了Bitmap（注：此Bitmap正好用了刚才那张图片的控件来存放解析后的数据）。如果发生这种事情，Bitmap的内容就会被换成了新的图片内容。此时，View依然尝试着绘制Bitmap，导致原来的View中显示了一张新的图片！</p>\n</li>\n</ol>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><p>这些问题主要有两个原因：</p>\n<ol>\n<li><p>尝试加载两个不同的资源到同一Target中</p>\n<p> 在Glide中，没有安全的方法来加载多个资源到单一的Target中。开发者可以使用<code>thumbnail()</code>来加载一系列资源到到某个Target中，但是对于每一个加载的资源来说，只有在下一个<code>onResourceReady()</code>被调用前，它的引用才是安全的。<br>开发者如果想加载多个资源到同一个View中，可以使用两个独立的Target。为了确保加载过程不相互取消，开发者要么不使用ViewTarget的子类，要么在继承ViewTarget时，复写<code>setRequest()</code> 和 <code>getRequest()</code>，不要使用tag来存储Request。（注：需要一个demo)</p>\n<p> <strong>译者注：对于同一个view，调用两次Glide.xxx.into(view)，第二次调用会先清空第一个加载的图片（出现空白），再去下载新的图片，如果想要在第二张图片下载下来之前依旧显示之前的，需要一些技巧</strong></p>\n</li>\n<li><p>加载一个资源放入到Target，然后清空或者复用了Target，但是依然引用这这个资源。</p>\n<p> 最简单的避免这个错误的方法是在<code>onLoadCleared()</code>方法中把所有对资源对象的引用置null。一般情况下，加载一个Bitmap，然后引用它的Target是安全的。不安全的是，你清空了这个Target，却依然引用着这个Bitmap。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"使用快照\"><a href=\"#使用快照\" class=\"headerlink\" title=\"使用快照\"></a>使用快照</h2><h3 id=\"关于快照\"><a href=\"#关于快照\" class=\"headerlink\" title=\"关于快照\"></a>关于快照</h3><p>对于那些不想等待Glide下个正式版本而愿意尝鲜的用户，我们在<a href=\"https://travis-ci.org/bumptech/glide\">Sonatype</a>上部署了这个库的快照。<br>每一次我们push代码待GitHub的master分支，<a href=\"https://oss.sonatype.org/content/repositories/snapshots/\">travis-ci</a>会构建Glide.如果构建成功，会自动部署最新版本的库到Sonatype上。<br>和Glide主库一样，每个Intergration库也有自己的快照，如果你使用快照版本的Glide库，请使用快照版本的Intergration库，反之依然。</p>\n<h3 id=\"获取快照\"><a href=\"#获取快照\" class=\"headerlink\" title=\"获取快照\"></a>获取快照</h3><p>Sonatype的快照库和其他的maven库一样，提供jar，maven，gradle等版本。</p>\n<h4 id=\"Jar\"><a href=\"#Jar\" class=\"headerlink\" title=\"Jar\"></a>Jar</h4><p>Jar包可以直接从Sonatype上下载，再次检查一下日期，确保使用最新版本</p>\n<h4 id=\"Gradle\"><a href=\"#Gradle\" class=\"headerlink\" title=\"Gradle\"></a>Gradle</h4><p>在仓库列表中添加快照仓库</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">  jcenter()</div><div class=\"line\">  maven &#123;</div><div class=\"line\">    url 'http://oss.sonatype.org/content/repositories/snapshots'</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后修改依赖为快照版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">  compile \"com.github.bumptech.glide:glide:3.6.0-SNAPSHOT\"</div><div class=\"line\">  compile \"com.github.bumptech.glide:okhttp-integration:1.3.0-SNAPSHOT\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h4><p>这种方式没有测试，直接从<a href=\"http://stackoverflow.com/questions/7715321/how-to-download-snapshot-version-from-maven-snapshot-repository\">StackOverflow</a>拷过来的。欢迎改进下面的内容。<br>添加下面的代码到<code>~/.m2/settings.xml</code>中：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>allow-snapshots<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">activation</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">activeByDefault</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">activeByDefault</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>snapshots-repo<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>修改依赖为快照版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.bumptech.glide<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>glide<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.6.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.bumptech.glide<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>okhttp-integration<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图形变换\"><a href=\"#图形变换\" class=\"headerlink\" title=\"图形变换\"></a>图形变换</h2><h3 id=\"默认的变换\"><a href=\"#默认的变换\" class=\"headerlink\" title=\"默认的变换\"></a>默认的变换</h3><p>Glide包含两种默认的图像变换方式，fitCenter和centerCrop。如果开发者需要其他类型的变换，可以考虑使用这个独立的<a href=\"https://github.com/wasabeef/glide-transformations\">变换库</a>。</p>\n<h4 id=\"Fit-center\"><a href=\"#Fit-center\" class=\"headerlink\" title=\"Fit center\"></a>Fit center</h4><p>FitCenter会按原始比例缩小图像，使图像可以在放在给定的区域内。FitCenter会尽可能少地缩小图片，使宽或者高的一边等于给定的值。另外一边会等于或者小于给定值。<br>FitCenter和Android中的ScaleType.FIT_CENTER效果相同。</p>\n<h4 id=\"CenterCrop\"><a href=\"#CenterCrop\" class=\"headerlink\" title=\"CenterCrop\"></a>CenterCrop</h4><p>CenterCrop会按原始比例缩小图像，使宽或者高的一边等于给定的值，另外一边会等于或者大于给定值。CenterCrop会裁剪掉多余部分。<br>CenterCrop和Android中的ScaleType.CENTER_CROP效果相同。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>fit center效果使用<code>.fitCenter()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .fitCenter()</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>center crop效果使用<code>.centerCrop()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    . centerCrop()</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>如果你只加载Bitmap或者Gif，也可以使用这个变换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// For Bitmaps:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .centerCrop()</div><div class=\"line\">    .into(yourView);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// For gifs:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asGif()</div><div class=\"line\">    .fitCenter()</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<p>当在类型间转码时，也可以使用这些变换。例如，获取一个变形后的jpeg图片的bytes数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .toBytes()</div><div class=\"line\">    .centerCrop()</div><div class=\"line\">    .into(<span class=\"keyword\">new</span> SimpleTarget&lt;<span class=\"keyword\">byte</span>[]&gt;(...) &#123; ... &#125;);</div></pre></td></tr></table></figure>\n<p>自定义变换<br>除了两个内置的变换，你还可以自定义变换。<br>最简单的方式是继承BitmapTransformation。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTransformation</span> <span class=\"keyword\">extends</span> <span class=\"title\">BitmapTransformation</span> </span>&#123; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyTransformation</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">super</span>(context);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Bitmap <span class=\"title\">transform</span><span class=\"params\">(BitmapPool pool, Bitmap toTransform, </div><div class=\"line\">            <span class=\"keyword\">int</span> outWidth, <span class=\"keyword\">int</span> outHeight)</span> </span>&#123;</div><div class=\"line\">       Bitmap myTransformedBitmap = ... <span class=\"comment\">// apply some transformation here. </span></div><div class=\"line\">       <span class=\"keyword\">return</span> myTransformedBitmap; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Return some id that uniquely identifies your transformation. </span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"com.example.myapp.MyTransformation\"</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>之后一就可以用同样的方式使用它。使用<code>.transform(...)</code>代替<code>.fitCenter()</code>/<code>.centerCrop()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// For the default drawable type:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .transform(<span class=\"keyword\">new</span> MyTransformation(context))</div><div class=\"line\">    .into(yourView);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// For Bitmaps:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asBitmap()</div><div class=\"line\">    .transform(<span class=\"keyword\">new</span> MyTransformation(context))</div><div class=\"line\">    .into(yourView);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// For Gifs:</span></div><div class=\"line\">Glide.with(yourFragment)</div><div class=\"line\">    .load(yourUrl)</div><div class=\"line\">    .asGif()</div><div class=\"line\">    .transform(<span class=\"keyword\">new</span> MyTransformation(context))</div><div class=\"line\">    .into(yourView);</div></pre></td></tr></table></figure>\n<h4 id=\"调整大小\"><a href=\"#调整大小\" class=\"headerlink\" title=\"调整大小\"></a>调整大小</h4><p>你可能注意到上面的例子没有传入具体的尺寸，那么，Transformation中的尺寸是如何获得的呢？<br>Transformation中的尺寸就是View或者Target的大小。Glide会根据布局文件中的weight，match_parent或者具体值算出View的大小。，当你拥有View/Target的具体大小，又拥有原始图片的大小时，就可以通过图像变换生成一个正确大小的图片。<br>如果你想指定View/Target的自定义大小，可以使用<code>.override(int, int)</code>方法，如果你想加载一个图片有其他用途，而不是显示在View中，请查看『自定义Target』章节。</p>\n<h4 id=\"Bitmap-复用\"><a href=\"#Bitmap-复用\" class=\"headerlink\" title=\"Bitmap 复用\"></a>Bitmap 复用</h4><p>为了减少垃圾回收，你可以说使用<code>BitmapPool</code>接口来释放不想要的Bitmap或者复用存在的Bitmap。一个在Transformation中复用Bitmap典型的例子：从pool中获取Bitmap，使用该Bitmap创建一个<code>Canvas</code>，然后使用Matrix/Paint/Shader来变换图像并绘制到Canvas上。为了正确有效地在Transformation中复用Bitmap中，遵守下面的规则：</p>\n<ol>\n<li>在<code>transform()</code>不要回收资源或者把Bitmap放入Bitmap池中，这些步骤会自动完成。</li>\n<li>如果你从Bitmap池中获取了多个Bitmap，或者没有使用从pool中获取到的Bitmap，确保把多余的Bitmap放回pool中。</li>\n<li>如果你的Trasformation并没有替换调原始图片（比如，图片已经满足你要求的大小，直接返回了），请在<code>transform()</code>方法中返回原始的资源或者Bitmap。</li>\n</ol>\n<p>一个典型的用法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Bitmap <span class=\"title\">transform</span><span class=\"params\">(BitmapPool bitmapPool, Bitmap original, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">    Bitmap result = bitmapPool.get(width, height, Bitmap.Config.ARGB_8888);</div><div class=\"line\">    <span class=\"comment\">// If no matching Bitmap is in the pool, get will return null, so we should allocate. </span></div><div class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// Use ARGB_8888 since we're going to add alpha to the image. </span></div><div class=\"line\">        result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">// Create a Canvas backed by the result Bitmap. </span></div><div class=\"line\">    Canvas canvas = <span class=\"keyword\">new</span> Canvas(result);</div><div class=\"line\">    Paint paint = <span class=\"keyword\">new</span> Paint();</div><div class=\"line\">    paint.setAlpha(<span class=\"number\">128</span>);</div><div class=\"line\">    <span class=\"comment\">// Draw the original Bitmap onto the result Bitmap with a transformation. </span></div><div class=\"line\">    canvas.drawBitmap(original, <span class=\"number\">0</span>, <span class=\"number\">0</span>, paint);</div><div class=\"line\">    <span class=\"comment\">// Since we've replaced our original Bitmap, we return our new Bitmap here. Glide will </span></div><div class=\"line\">    <span class=\"comment\">// will take care of returning our original Bitmap to the BitmapPool for us.  </span></div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Android构架系列之一--工程结构与Gradle配置","date":"2016-03-27T05:51:46.000Z","_content":"## 从最基本结构说起\n新建一个helloworld工程结构：\n![](images/android_helloworld_project_gradle_files.png)\n工程目录下只有根目录和一个app模块，没有其他模块。\n\n* 根目录`build.gradle`：关于项目的一些总体配置(比如编译系统使用的仓库和依赖，其他模块都使用的仓库和依赖)；\n* 根目录`settings.gralde`：项目的模块构成，最简单。\n* app模块`build.gradle`：app模块的具体配置，该模块自身的性质，该模块依赖的库（jcenter的开源外部库，内部模块之间）\n\n### 根目录build.gradle\n```groovy\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.5.0'\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\n```\n首先，区分一个概念：**编译系统自身**与**被编译的内容**,[见stackoverflow](http://stackoverflow.com/questions/30158971/whats-the-difference-between-buildscript-and-allprojects-in-build-gradle)。\n\n* `buildscript`：配置的是**buildsystem自身（即Gradle）**使用的仓库和依赖，在这里，buildsystem依赖的库/插件是android gradle1.5，从jcenter下载。gradle就是用来编译的。\n\n\t> 区分一个东西：gradle 与 Android tools的gradle插件\n> gradle自身是一个编译系统，它的版本配置在AS的设置中。\n> Android tools的gradle插件，是google开发的在一个gradle插件，在gralde中使用，可以让gradle支持编译Android应用程序。也就是说\n> \n> * 如果gradle引用其他插件可以编译其他应用程序\n> * 可以自定义插件，修改gradle编译android应用的行为，实现一些自定义功能。相应的**会引入plugin（必有）、一些自定义的命令、配置区块！**\n\n\t此外buildsystem还可能依赖一些其他常用的库/插件，**编译注解**常用的apt：\n\t\n\t```groovy\n\t dependencies {\n    classpath 'com.android.tools.build:gradle:1.5.0'\n    classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4'\n  }\n\t```\n\n* `allprojects`：不是必须的，作用是遍历所有的模块并且应用同一个配置。在这里配置的是所有模块都使用jcenter仓库。如果不在这里配置，可以在每个模块的`build.gradle`中单独配置（思考：how to？）。除此之外，`allprojects`中还可以配置：\n\t* `dependencies`，所有模块公用的dependencies\n\t* 一些变量，所有模块都用的变量,\n\t\n\t``` groovy\n\tallprojects {\n\t//为什么是ext，请参考其他文章\n  ext {\n    androidApplicationId = 'com.fernanependocejas.android10.sample.presentation'\n    androidVersionCode = 1\n    androidVersionName = \"1.0\"\n    testInstrumentationRunner = \"android.support.test.runner.AndroidJUnitRunner\"\n    testApplicationId = 'com.fernandocejas.android10.sample.presentation.test'\n  }\n}\n\t```\n\t\n* 自定义`task`：上面的clean是覆盖了系统的clean任务，同样在这里我们可以写一下自定义的gradle 任务\n\n\t```groovy\n\ttask wrapper(type: Wrapper) {\n  description 'Creates the gradle wrapper.'\n  gradleVersion '2.10'\n}\n// 例如定义一下task运行某个模块的单元测试\ntask runDomainUnitTests(dependsOn: [':domain:test']) {\n  description 'Run unit tests for the domain layer.'\n}\ntask runDataUnitTests(dependsOn: [':data:cleanTestDebugUnitTest', ':data:testDebugUnitTest']) {\n  description 'Run unit tests for the data layer.'\n}\ntask runUnitTests(dependsOn: ['runDomainUnitTests', 'runDataUnitTests']) {\n  description 'Run unit tests for both domain and data layers.'\n}\n```\n\n* 其他内容：是否需要 `apply plugin: 'com.android.application'`？这个例子中不可以，application插件一般放在app模块。\n\t> 有些特别的例子（比如eclipse转换成的as工程），根目录就是app模块，此时的app的build.gradle与根目录的build.gradle是一个文件，所有可以这么写。[android gradle的官方demo](http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Basic-Project-Setup)中，最简单的gradle工程也是用了一个`build.gradle`文件。\n\n### 根目录的settings.gradle\n```groovy\ninclude ':app'\n```\n这个文件最简单，含义是这个项目包括的**所有**模块的名字（位置），这里的含义是根目录下面的app模块，如果是子目录，需要写出目录\n\n```groovy\ninclude ':app'\n// 子目录third_party下的android_support模块\ninclude 'third_party:android_support'\n// 也可以这样写\n// include ':app', 'third_party:android_support'\n```\n注意：一个特例：当根目录就是app模块是不需要在`setting.gradle`中写出。\n\n### app模块build.gradle\n```groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 23\n    buildToolsVersion \"23.0.2\"\n\n    defaultConfig {\n        applicationId \"com.example.baidu.helloworld\"\n        minSdkVersion 14\n        targetSdkVersion 23\n        versionCode 1\n        versionName \"1.0\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\n\n\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    testCompile 'junit:junit:4.12'\n    compile 'com.android.support:appcompat-v7:23.2.1'\n}\n\n```\n\n这个是android app配置的主要内容，从顶层开始看：`apply plugin`,`android`,`dependencies`三大区块内容（除此此外还可以有`repositories`，**`configurations`**）。\n\n* `apply plugin: xxx`：插件就是之前引入的android gradle 1.5库导入的常用的有：\n\t* `'com.android.application'` 指示当前编译的是android app主模块，一个应用中有且仅有一个。\n\t* `'com.android.library'` 指示当前编译的是android 库模块，这种library可以包含android包和资源并且**可以导出aar包**，这是AS特有的功能，包含了资源文件。\n\t* `'java'` 指示当前编译的是纯的java库模块，注意这个plugin不是android gradle插件引入的，是gradle原生。如果某个库被定义成此类型，**此模块不能引用其他Android模块！**这种library能导出jar包，和eclipse的功能类似。**疑问：可以只引用，不编译android.jar吗？**\n\t\n* `dependencies`区块：该模块依赖的库。通常有下面这些写法：\n\t* `compile fileTree(dir: 'libs', include: ['*.jar'])` ：编译位于libs目录下的一下jar包。\n\t* `compile xxx` ：编译jcenter的某个库。最常用。\n\t* `compile project(':xxx')` ：编译其他模块，**建立模块之间的依赖，十分重要**，也可以在AS的项目配置中查看。\n\t\t\n\t除此之外，还可能包括：\n\t\n\t* `provided xxx` ：**还不了解，只引用，不编译？？？**\n\t* `testCompile xxx` ：**测试情况下编译?**\n\t\n\t当请入第三方gradle插件时，比如apt插件会引入：\n\t\n\t* `apt xxx` ：引入第三方注解依赖，**思考并理解与apt插件的关系**：apt是编译工具，xxx是被编译的内容，比如dagger的注解。\n\t\n* `android`区块：这里android gradle插件引入的区块，可以定义所有android相关的配置，比如应用编译的签名，applicationId，版本，lint开关，编译选项(java版本)，设置源码目录，生成多个包等等，**大部分的android编译的配置**。[请阅读文档！](ttp://tools.android.com/tech-docs/new-build-system/user-guide)\n* 其他区块：还有一些区块是其他gradle插件引入的，比如微信的资源混淆插件就回加入一个自己的区块，可以配置资源混淆相关的选项。\n\n### 其他\n* `apply from: \"$rootDir/config/config.gradle\"`：这种样式可能有多个，表示引入配置文件。`build.gradle`可能很长，按照功能把build分为多个子build是不错的实践。\n\n\t> 在根目录新建文件夹`config`，在文件夹config中，写多个`xxx.gradle`文件，比如`quality.gradle`，它来为我的项目集成并配置所有的质量控制工具。然后通过`apply from`导入到对应的build.gradle文件。\n\t\n## 一些待理解的问题\n* `provided` 的具体含义的理解\n* `configurations` 区块\n* 测试相关的内容\n\n## 工程实践\n参考[clean构架的demo](https://github.com/android10/Android-CleanArchitecture)，总结几点\n\n* `build.gradle`按功能分成多个`xxx.gradle`文件，即必须分块！\n* 将所有依赖的内容放入一个单独的文件中，如`config.gradle`。方便以后配置管理。（`ext`的使用！）\n* 细节：\n\t* `compile project()` 模块间依赖的建立。 \n\n## 深入学习\n* [深入理解Android之Gradle](http://blog.csdn.net/innost/article/details/48228651)\n* [android gradle 插件官方文档](http://tools.android.com/tech-docs/new-build-system/user-guide)\n* [gradle官方文档](https://docs.gradle.org/current/userguide/userguide_single.html)\n\n","source":"_posts/Android构架系列之一-工程结构与Gradle配置.md","raw":"title: Android构架系列之一--工程结构与Gradle配置\ndate: 2016-03-27 13:51:46\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n## 从最基本结构说起\n新建一个helloworld工程结构：\n![](images/android_helloworld_project_gradle_files.png)\n工程目录下只有根目录和一个app模块，没有其他模块。\n\n* 根目录`build.gradle`：关于项目的一些总体配置(比如编译系统使用的仓库和依赖，其他模块都使用的仓库和依赖)；\n* 根目录`settings.gralde`：项目的模块构成，最简单。\n* app模块`build.gradle`：app模块的具体配置，该模块自身的性质，该模块依赖的库（jcenter的开源外部库，内部模块之间）\n\n### 根目录build.gradle\n```groovy\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.5.0'\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\n```\n首先，区分一个概念：**编译系统自身**与**被编译的内容**,[见stackoverflow](http://stackoverflow.com/questions/30158971/whats-the-difference-between-buildscript-and-allprojects-in-build-gradle)。\n\n* `buildscript`：配置的是**buildsystem自身（即Gradle）**使用的仓库和依赖，在这里，buildsystem依赖的库/插件是android gradle1.5，从jcenter下载。gradle就是用来编译的。\n\n\t> 区分一个东西：gradle 与 Android tools的gradle插件\n> gradle自身是一个编译系统，它的版本配置在AS的设置中。\n> Android tools的gradle插件，是google开发的在一个gradle插件，在gralde中使用，可以让gradle支持编译Android应用程序。也就是说\n> \n> * 如果gradle引用其他插件可以编译其他应用程序\n> * 可以自定义插件，修改gradle编译android应用的行为，实现一些自定义功能。相应的**会引入plugin（必有）、一些自定义的命令、配置区块！**\n\n\t此外buildsystem还可能依赖一些其他常用的库/插件，**编译注解**常用的apt：\n\t\n\t```groovy\n\t dependencies {\n    classpath 'com.android.tools.build:gradle:1.5.0'\n    classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4'\n  }\n\t```\n\n* `allprojects`：不是必须的，作用是遍历所有的模块并且应用同一个配置。在这里配置的是所有模块都使用jcenter仓库。如果不在这里配置，可以在每个模块的`build.gradle`中单独配置（思考：how to？）。除此之外，`allprojects`中还可以配置：\n\t* `dependencies`，所有模块公用的dependencies\n\t* 一些变量，所有模块都用的变量,\n\t\n\t``` groovy\n\tallprojects {\n\t//为什么是ext，请参考其他文章\n  ext {\n    androidApplicationId = 'com.fernanependocejas.android10.sample.presentation'\n    androidVersionCode = 1\n    androidVersionName = \"1.0\"\n    testInstrumentationRunner = \"android.support.test.runner.AndroidJUnitRunner\"\n    testApplicationId = 'com.fernandocejas.android10.sample.presentation.test'\n  }\n}\n\t```\n\t\n* 自定义`task`：上面的clean是覆盖了系统的clean任务，同样在这里我们可以写一下自定义的gradle 任务\n\n\t```groovy\n\ttask wrapper(type: Wrapper) {\n  description 'Creates the gradle wrapper.'\n  gradleVersion '2.10'\n}\n// 例如定义一下task运行某个模块的单元测试\ntask runDomainUnitTests(dependsOn: [':domain:test']) {\n  description 'Run unit tests for the domain layer.'\n}\ntask runDataUnitTests(dependsOn: [':data:cleanTestDebugUnitTest', ':data:testDebugUnitTest']) {\n  description 'Run unit tests for the data layer.'\n}\ntask runUnitTests(dependsOn: ['runDomainUnitTests', 'runDataUnitTests']) {\n  description 'Run unit tests for both domain and data layers.'\n}\n```\n\n* 其他内容：是否需要 `apply plugin: 'com.android.application'`？这个例子中不可以，application插件一般放在app模块。\n\t> 有些特别的例子（比如eclipse转换成的as工程），根目录就是app模块，此时的app的build.gradle与根目录的build.gradle是一个文件，所有可以这么写。[android gradle的官方demo](http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Basic-Project-Setup)中，最简单的gradle工程也是用了一个`build.gradle`文件。\n\n### 根目录的settings.gradle\n```groovy\ninclude ':app'\n```\n这个文件最简单，含义是这个项目包括的**所有**模块的名字（位置），这里的含义是根目录下面的app模块，如果是子目录，需要写出目录\n\n```groovy\ninclude ':app'\n// 子目录third_party下的android_support模块\ninclude 'third_party:android_support'\n// 也可以这样写\n// include ':app', 'third_party:android_support'\n```\n注意：一个特例：当根目录就是app模块是不需要在`setting.gradle`中写出。\n\n### app模块build.gradle\n```groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 23\n    buildToolsVersion \"23.0.2\"\n\n    defaultConfig {\n        applicationId \"com.example.baidu.helloworld\"\n        minSdkVersion 14\n        targetSdkVersion 23\n        versionCode 1\n        versionName \"1.0\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\n\n\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    testCompile 'junit:junit:4.12'\n    compile 'com.android.support:appcompat-v7:23.2.1'\n}\n\n```\n\n这个是android app配置的主要内容，从顶层开始看：`apply plugin`,`android`,`dependencies`三大区块内容（除此此外还可以有`repositories`，**`configurations`**）。\n\n* `apply plugin: xxx`：插件就是之前引入的android gradle 1.5库导入的常用的有：\n\t* `'com.android.application'` 指示当前编译的是android app主模块，一个应用中有且仅有一个。\n\t* `'com.android.library'` 指示当前编译的是android 库模块，这种library可以包含android包和资源并且**可以导出aar包**，这是AS特有的功能，包含了资源文件。\n\t* `'java'` 指示当前编译的是纯的java库模块，注意这个plugin不是android gradle插件引入的，是gradle原生。如果某个库被定义成此类型，**此模块不能引用其他Android模块！**这种library能导出jar包，和eclipse的功能类似。**疑问：可以只引用，不编译android.jar吗？**\n\t\n* `dependencies`区块：该模块依赖的库。通常有下面这些写法：\n\t* `compile fileTree(dir: 'libs', include: ['*.jar'])` ：编译位于libs目录下的一下jar包。\n\t* `compile xxx` ：编译jcenter的某个库。最常用。\n\t* `compile project(':xxx')` ：编译其他模块，**建立模块之间的依赖，十分重要**，也可以在AS的项目配置中查看。\n\t\t\n\t除此之外，还可能包括：\n\t\n\t* `provided xxx` ：**还不了解，只引用，不编译？？？**\n\t* `testCompile xxx` ：**测试情况下编译?**\n\t\n\t当请入第三方gradle插件时，比如apt插件会引入：\n\t\n\t* `apt xxx` ：引入第三方注解依赖，**思考并理解与apt插件的关系**：apt是编译工具，xxx是被编译的内容，比如dagger的注解。\n\t\n* `android`区块：这里android gradle插件引入的区块，可以定义所有android相关的配置，比如应用编译的签名，applicationId，版本，lint开关，编译选项(java版本)，设置源码目录，生成多个包等等，**大部分的android编译的配置**。[请阅读文档！](ttp://tools.android.com/tech-docs/new-build-system/user-guide)\n* 其他区块：还有一些区块是其他gradle插件引入的，比如微信的资源混淆插件就回加入一个自己的区块，可以配置资源混淆相关的选项。\n\n### 其他\n* `apply from: \"$rootDir/config/config.gradle\"`：这种样式可能有多个，表示引入配置文件。`build.gradle`可能很长，按照功能把build分为多个子build是不错的实践。\n\n\t> 在根目录新建文件夹`config`，在文件夹config中，写多个`xxx.gradle`文件，比如`quality.gradle`，它来为我的项目集成并配置所有的质量控制工具。然后通过`apply from`导入到对应的build.gradle文件。\n\t\n## 一些待理解的问题\n* `provided` 的具体含义的理解\n* `configurations` 区块\n* 测试相关的内容\n\n## 工程实践\n参考[clean构架的demo](https://github.com/android10/Android-CleanArchitecture)，总结几点\n\n* `build.gradle`按功能分成多个`xxx.gradle`文件，即必须分块！\n* 将所有依赖的内容放入一个单独的文件中，如`config.gradle`。方便以后配置管理。（`ext`的使用！）\n* 细节：\n\t* `compile project()` 模块间依赖的建立。 \n\n## 深入学习\n* [深入理解Android之Gradle](http://blog.csdn.net/innost/article/details/48228651)\n* [android gradle 插件官方文档](http://tools.android.com/tech-docs/new-build-system/user-guide)\n* [gradle官方文档](https://docs.gradle.org/current/userguide/userguide_single.html)\n\n","slug":"Android构架系列之一-工程结构与Gradle配置","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbbs0003nac96bgbslhp","content":"<h2 id=\"从最基本结构说起\"><a href=\"#从最基本结构说起\" class=\"headerlink\" title=\"从最基本结构说起\"></a>从最基本结构说起</h2><p>新建一个helloworld工程结构：<br><img src=\"images/android_helloworld_project_gradle_files.png\" alt=\"\"><br>工程目录下只有根目录和一个app模块，没有其他模块。</p>\n<ul>\n<li>根目录<code>build.gradle</code>：关于项目的一些总体配置(比如编译系统使用的仓库和依赖，其他模块都使用的仓库和依赖)；</li>\n<li>根目录<code>settings.gralde</code>：项目的模块构成，最简单。</li>\n<li>app模块<code>build.gradle</code>：app模块的具体配置，该模块自身的性质，该模块依赖的库（jcenter的开源外部库，内部模块之间）</li>\n</ul>\n<h3 id=\"根目录build-gradle\"><a href=\"#根目录build-gradle\" class=\"headerlink\" title=\"根目录build.gradle\"></a>根目录build.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></div><div class=\"line\"></div><div class=\"line\">buildscript &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        jcenter()</div><div class=\"line\">    &#125;</div><div class=\"line\">    dependencies &#123;</div><div class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:1.5.0'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> Do not place your application dependencies here; they belong</span></div><div class=\"line\">        <span class=\"comment\">// in the individual module build.gradle files</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">allprojects &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        jcenter()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">task clean(<span class=\"string\">type:</span> Delete) &#123;</div><div class=\"line\">    delete rootProject.buildDir</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，区分一个概念：<strong>编译系统自身</strong>与<strong>被编译的内容</strong>,<a href=\"http://stackoverflow.com/questions/30158971/whats-the-difference-between-buildscript-and-allprojects-in-build-gradle\" target=\"_blank\" rel=\"external\">见stackoverflow</a>。</p>\n<ul>\n<li><p><code>buildscript</code>：配置的是<strong>buildsystem自身（即Gradle）</strong>使用的仓库和依赖，在这里，buildsystem依赖的库/插件是android gradle1.5，从jcenter下载。gradle就是用来编译的。</p>\n<blockquote>\n<p>区分一个东西：gradle 与 Android tools的gradle插件<br>gradle自身是一个编译系统，它的版本配置在AS的设置中。<br>Android tools的gradle插件，是google开发的在一个gradle插件，在gralde中使用，可以让gradle支持编译Android应用程序。也就是说</p>\n<ul>\n<li>如果gradle引用其他插件可以编译其他应用程序</li>\n<li>可以自定义插件，修改gradle编译android应用的行为，实现一些自定义功能。相应的<strong>会引入plugin（必有）、一些自定义的命令、配置区块！</strong></li>\n</ul>\n</blockquote>\n<p>  此外buildsystem还可能依赖一些其他常用的库/插件，<strong>编译注解</strong>常用的apt：</p>\n  <figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">  classpath <span class=\"string\">'com.android.tools.build:gradle:1.5.0'</span></div><div class=\"line\">  classpath <span class=\"string\">'com.neenbedankt.gradle.plugins:android-apt:1.4'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>allprojects</code>：不是必须的，作用是遍历所有的模块并且应用同一个配置。在这里配置的是所有模块都使用jcenter仓库。如果不在这里配置，可以在每个模块的<code>build.gradle</code>中单独配置（思考：how to？）。除此之外，<code>allprojects</code>中还可以配置：</p>\n<ul>\n<li><code>dependencies</code>，所有模块公用的dependencies</li>\n<li><p>一些变量，所有模块都用的变量,</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tallprojects &#123;</div><div class=\"line\">\t<span class=\"comment\">//为什么是ext，请参考其他文章</span></div><div class=\"line\">  ext &#123;</div><div class=\"line\">    androidApplicationId = <span class=\"string\">'com.fernanependocejas.android10.sample.presentation'</span></div><div class=\"line\">    androidVersionCode = <span class=\"number\">1</span></div><div class=\"line\">    androidVersionName = <span class=\"string\">\"1.0\"</span></div><div class=\"line\">    testInstrumentationRunner = <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></div><div class=\"line\">    testApplicationId = <span class=\"string\">'com.fernandocejas.android10.sample.presentation.test'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>自定义<code>task</code>：上面的clean是覆盖了系统的clean任务，同样在这里我们可以写一下自定义的gradle 任务</p>\n  <figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttask wrapper(<span class=\"string\">type:</span> Wrapper) &#123;</div><div class=\"line\">  description <span class=\"string\">'Creates the gradle wrapper.'</span></div><div class=\"line\">  gradleVersion <span class=\"string\">'2.10'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 例如定义一下task运行某个模块的单元测试</span></div><div class=\"line\">task runDomainUnitTests(<span class=\"string\">dependsOn:</span> [<span class=\"string\">':domain:test'</span>]) &#123;</div><div class=\"line\">  description <span class=\"string\">'Run unit tests for the domain layer.'</span></div><div class=\"line\">&#125;</div><div class=\"line\">task runDataUnitTests(<span class=\"string\">dependsOn:</span> [<span class=\"string\">':data:cleanTestDebugUnitTest'</span>, <span class=\"string\">':data:testDebugUnitTest'</span>]) &#123;</div><div class=\"line\">  description <span class=\"string\">'Run unit tests for the data layer.'</span></div><div class=\"line\">&#125;</div><div class=\"line\">task runUnitTests(<span class=\"string\">dependsOn:</span> [<span class=\"string\">'runDomainUnitTests'</span>, <span class=\"string\">'runDataUnitTests'</span>]) &#123;</div><div class=\"line\">  description <span class=\"string\">'Run unit tests for both domain and data layers.'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>其他内容：是否需要 <code>apply plugin: &#39;com.android.application&#39;</code>？这个例子中不可以，application插件一般放在app模块。</p>\n<blockquote>\n<p>有些特别的例子（比如eclipse转换成的as工程），根目录就是app模块，此时的app的build.gradle与根目录的build.gradle是一个文件，所有可以这么写。<a href=\"http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Basic-Project-Setup\" target=\"_blank\" rel=\"external\">android gradle的官方demo</a>中，最简单的gradle工程也是用了一个<code>build.gradle</code>文件。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"根目录的settings-gradle\"><a href=\"#根目录的settings-gradle\" class=\"headerlink\" title=\"根目录的settings.gradle\"></a>根目录的settings.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include <span class=\"string\">':app'</span></div></pre></td></tr></table></figure>\n<p>这个文件最简单，含义是这个项目包括的<strong>所有</strong>模块的名字（位置），这里的含义是根目录下面的app模块，如果是子目录，需要写出目录</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">include <span class=\"string\">':app'</span></div><div class=\"line\"><span class=\"comment\">// 子目录third_party下的android_support模块</span></div><div class=\"line\">include <span class=\"string\">'third_party:android_support'</span></div><div class=\"line\"><span class=\"comment\">// 也可以这样写</span></div><div class=\"line\"><span class=\"comment\">// include ':app', 'third_party:android_support'</span></div></pre></td></tr></table></figure>\n<p>注意：一个特例：当根目录就是app模块是不需要在<code>setting.gradle</code>中写出。</p>\n<h3 id=\"app模块build-gradle\"><a href=\"#app模块build-gradle\" class=\"headerlink\" title=\"app模块build.gradle\"></a>app模块build.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></div><div class=\"line\"></div><div class=\"line\">android &#123;</div><div class=\"line\">    compileSdkVersion <span class=\"number\">23</span></div><div class=\"line\">    buildToolsVersion <span class=\"string\">\"23.0.2\"</span></div><div class=\"line\"></div><div class=\"line\">    defaultConfig &#123;</div><div class=\"line\">        applicationId <span class=\"string\">\"com.example.baidu.helloworld\"</span></div><div class=\"line\">        minSdkVersion <span class=\"number\">14</span></div><div class=\"line\">        targetSdkVersion <span class=\"number\">23</span></div><div class=\"line\">        versionCode <span class=\"number\">1</span></div><div class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    buildTypes &#123;</div><div class=\"line\">        release &#123;</div><div class=\"line\">            minifyEnabled <span class=\"literal\">false</span></div><div class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</div><div class=\"line\">    testCompile <span class=\"string\">'junit:junit:4.12'</span></div><div class=\"line\">    compile <span class=\"string\">'com.android.support:appcompat-v7:23.2.1'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个是android app配置的主要内容，从顶层开始看：<code>apply plugin</code>,<code>android</code>,<code>dependencies</code>三大区块内容（除此此外还可以有<code>repositories</code>，<strong><code>configurations</code></strong>）。</p>\n<ul>\n<li><p><code>apply plugin: xxx</code>：插件就是之前引入的android gradle 1.5库导入的常用的有：</p>\n<ul>\n<li><code>&#39;com.android.application&#39;</code> 指示当前编译的是android app主模块，一个应用中有且仅有一个。</li>\n<li><code>&#39;com.android.library&#39;</code> 指示当前编译的是android 库模块，这种library可以包含android包和资源并且<strong>可以导出aar包</strong>，这是AS特有的功能，包含了资源文件。</li>\n<li><code>&#39;java&#39;</code> 指示当前编译的是纯的java库模块，注意这个plugin不是android gradle插件引入的，是gradle原生。如果某个库被定义成此类型，<strong>此模块不能引用其他Android模块！</strong>这种library能导出jar包，和eclipse的功能类似。<strong>疑问：可以只引用，不编译android.jar吗？</strong></li>\n</ul>\n</li>\n<li><p><code>dependencies</code>区块：该模块依赖的库。通常有下面这些写法：</p>\n<ul>\n<li><code>compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</code> ：编译位于libs目录下的一下jar包。</li>\n<li><code>compile xxx</code> ：编译jcenter的某个库。最常用。</li>\n<li><p><code>compile project(&#39;:xxx&#39;)</code> ：编译其他模块，<strong>建立模块之间的依赖，十分重要</strong>，也可以在AS的项目配置中查看。</p>\n<p>除此之外，还可能包括：</p>\n</li>\n<li><p><code>provided xxx</code> ：<strong>还不了解，只引用，不编译？？？</strong></p>\n</li>\n<li><p><code>testCompile xxx</code> ：<strong>测试情况下编译?</strong></p>\n<p>当请入第三方gradle插件时，比如apt插件会引入：</p>\n</li>\n<li><p><code>apt xxx</code> ：引入第三方注解依赖，<strong>思考并理解与apt插件的关系</strong>：apt是编译工具，xxx是被编译的内容，比如dagger的注解。</p>\n</li>\n</ul>\n</li>\n<li><p><code>android</code>区块：这里android gradle插件引入的区块，可以定义所有android相关的配置，比如应用编译的签名，applicationId，版本，lint开关，编译选项(java版本)，设置源码目录，生成多个包等等，<strong>大部分的android编译的配置</strong>。<a href=\"ttp://tools.android.com/tech-docs/new-build-system/user-guide\" target=\"_blank\" rel=\"external\">请阅读文档！</a></p>\n</li>\n<li>其他区块：还有一些区块是其他gradle插件引入的，比如微信的资源混淆插件就回加入一个自己的区块，可以配置资源混淆相关的选项。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><p><code>apply from: &quot;$rootDir/config/config.gradle&quot;</code>：这种样式可能有多个，表示引入配置文件。<code>build.gradle</code>可能很长，按照功能把build分为多个子build是不错的实践。</p>\n<blockquote>\n<p>在根目录新建文件夹<code>config</code>，在文件夹config中，写多个<code>xxx.gradle</code>文件，比如<code>quality.gradle</code>，它来为我的项目集成并配置所有的质量控制工具。然后通过<code>apply from</code>导入到对应的build.gradle文件。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"一些待理解的问题\"><a href=\"#一些待理解的问题\" class=\"headerlink\" title=\"一些待理解的问题\"></a>一些待理解的问题</h2><ul>\n<li><code>provided</code> 的具体含义的理解</li>\n<li><code>configurations</code> 区块</li>\n<li>测试相关的内容</li>\n</ul>\n<h2 id=\"工程实践\"><a href=\"#工程实践\" class=\"headerlink\" title=\"工程实践\"></a>工程实践</h2><p>参考<a href=\"https://github.com/android10/Android-CleanArchitecture\" target=\"_blank\" rel=\"external\">clean构架的demo</a>，总结几点</p>\n<ul>\n<li><code>build.gradle</code>按功能分成多个<code>xxx.gradle</code>文件，即必须分块！</li>\n<li>将所有依赖的内容放入一个单独的文件中，如<code>config.gradle</code>。方便以后配置管理。（<code>ext</code>的使用！）</li>\n<li>细节：<ul>\n<li><code>compile project()</code> 模块间依赖的建立。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"深入学习\"><a href=\"#深入学习\" class=\"headerlink\" title=\"深入学习\"></a>深入学习</h2><ul>\n<li><a href=\"http://blog.csdn.net/innost/article/details/48228651\" target=\"_blank\" rel=\"external\">深入理解Android之Gradle</a></li>\n<li><a href=\"http://tools.android.com/tech-docs/new-build-system/user-guide\" target=\"_blank\" rel=\"external\">android gradle 插件官方文档</a></li>\n<li><a href=\"https://docs.gradle.org/current/userguide/userguide_single.html\" target=\"_blank\" rel=\"external\">gradle官方文档</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"从最基本结构说起\"><a href=\"#从最基本结构说起\" class=\"headerlink\" title=\"从最基本结构说起\"></a>从最基本结构说起</h2><p>新建一个helloworld工程结构：<br><img src=\"images/android_helloworld_project_gradle_files.png\" alt=\"\"><br>工程目录下只有根目录和一个app模块，没有其他模块。</p>\n<ul>\n<li>根目录<code>build.gradle</code>：关于项目的一些总体配置(比如编译系统使用的仓库和依赖，其他模块都使用的仓库和依赖)；</li>\n<li>根目录<code>settings.gralde</code>：项目的模块构成，最简单。</li>\n<li>app模块<code>build.gradle</code>：app模块的具体配置，该模块自身的性质，该模块依赖的库（jcenter的开源外部库，内部模块之间）</li>\n</ul>\n<h3 id=\"根目录build-gradle\"><a href=\"#根目录build-gradle\" class=\"headerlink\" title=\"根目录build.gradle\"></a>根目录build.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></div><div class=\"line\"></div><div class=\"line\">buildscript &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        jcenter()</div><div class=\"line\">    &#125;</div><div class=\"line\">    dependencies &#123;</div><div class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:1.5.0'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> Do not place your application dependencies here; they belong</span></div><div class=\"line\">        <span class=\"comment\">// in the individual module build.gradle files</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">allprojects &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        jcenter()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">task clean(<span class=\"string\">type:</span> Delete) &#123;</div><div class=\"line\">    delete rootProject.buildDir</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，区分一个概念：<strong>编译系统自身</strong>与<strong>被编译的内容</strong>,<a href=\"http://stackoverflow.com/questions/30158971/whats-the-difference-between-buildscript-and-allprojects-in-build-gradle\">见stackoverflow</a>。</p>\n<ul>\n<li><p><code>buildscript</code>：配置的是<strong>buildsystem自身（即Gradle）</strong>使用的仓库和依赖，在这里，buildsystem依赖的库/插件是android gradle1.5，从jcenter下载。gradle就是用来编译的。</p>\n<blockquote>\n<p>区分一个东西：gradle 与 Android tools的gradle插件<br>gradle自身是一个编译系统，它的版本配置在AS的设置中。<br>Android tools的gradle插件，是google开发的在一个gradle插件，在gralde中使用，可以让gradle支持编译Android应用程序。也就是说</p>\n<ul>\n<li>如果gradle引用其他插件可以编译其他应用程序</li>\n<li>可以自定义插件，修改gradle编译android应用的行为，实现一些自定义功能。相应的<strong>会引入plugin（必有）、一些自定义的命令、配置区块！</strong></li>\n</ul>\n</blockquote>\n<p>  此外buildsystem还可能依赖一些其他常用的库/插件，<strong>编译注解</strong>常用的apt：</p>\n  <figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">  classpath <span class=\"string\">'com.android.tools.build:gradle:1.5.0'</span></div><div class=\"line\">  classpath <span class=\"string\">'com.neenbedankt.gradle.plugins:android-apt:1.4'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>allprojects</code>：不是必须的，作用是遍历所有的模块并且应用同一个配置。在这里配置的是所有模块都使用jcenter仓库。如果不在这里配置，可以在每个模块的<code>build.gradle</code>中单独配置（思考：how to？）。除此之外，<code>allprojects</code>中还可以配置：</p>\n<ul>\n<li><code>dependencies</code>，所有模块公用的dependencies</li>\n<li><p>一些变量，所有模块都用的变量,</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tallprojects &#123;</div><div class=\"line\">\t<span class=\"comment\">//为什么是ext，请参考其他文章</span></div><div class=\"line\">  ext &#123;</div><div class=\"line\">    androidApplicationId = <span class=\"string\">'com.fernanependocejas.android10.sample.presentation'</span></div><div class=\"line\">    androidVersionCode = <span class=\"number\">1</span></div><div class=\"line\">    androidVersionName = <span class=\"string\">\"1.0\"</span></div><div class=\"line\">    testInstrumentationRunner = <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></div><div class=\"line\">    testApplicationId = <span class=\"string\">'com.fernandocejas.android10.sample.presentation.test'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>自定义<code>task</code>：上面的clean是覆盖了系统的clean任务，同样在这里我们可以写一下自定义的gradle 任务</p>\n  <figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttask wrapper(<span class=\"string\">type:</span> Wrapper) &#123;</div><div class=\"line\">  description <span class=\"string\">'Creates the gradle wrapper.'</span></div><div class=\"line\">  gradleVersion <span class=\"string\">'2.10'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 例如定义一下task运行某个模块的单元测试</span></div><div class=\"line\">task runDomainUnitTests(<span class=\"string\">dependsOn:</span> [<span class=\"string\">':domain:test'</span>]) &#123;</div><div class=\"line\">  description <span class=\"string\">'Run unit tests for the domain layer.'</span></div><div class=\"line\">&#125;</div><div class=\"line\">task runDataUnitTests(<span class=\"string\">dependsOn:</span> [<span class=\"string\">':data:cleanTestDebugUnitTest'</span>, <span class=\"string\">':data:testDebugUnitTest'</span>]) &#123;</div><div class=\"line\">  description <span class=\"string\">'Run unit tests for the data layer.'</span></div><div class=\"line\">&#125;</div><div class=\"line\">task runUnitTests(<span class=\"string\">dependsOn:</span> [<span class=\"string\">'runDomainUnitTests'</span>, <span class=\"string\">'runDataUnitTests'</span>]) &#123;</div><div class=\"line\">  description <span class=\"string\">'Run unit tests for both domain and data layers.'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>其他内容：是否需要 <code>apply plugin: &#39;com.android.application&#39;</code>？这个例子中不可以，application插件一般放在app模块。</p>\n<blockquote>\n<p>有些特别的例子（比如eclipse转换成的as工程），根目录就是app模块，此时的app的build.gradle与根目录的build.gradle是一个文件，所有可以这么写。<a href=\"http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Basic-Project-Setup\">android gradle的官方demo</a>中，最简单的gradle工程也是用了一个<code>build.gradle</code>文件。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"根目录的settings-gradle\"><a href=\"#根目录的settings-gradle\" class=\"headerlink\" title=\"根目录的settings.gradle\"></a>根目录的settings.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include <span class=\"string\">':app'</span></div></pre></td></tr></table></figure>\n<p>这个文件最简单，含义是这个项目包括的<strong>所有</strong>模块的名字（位置），这里的含义是根目录下面的app模块，如果是子目录，需要写出目录</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">include <span class=\"string\">':app'</span></div><div class=\"line\"><span class=\"comment\">// 子目录third_party下的android_support模块</span></div><div class=\"line\">include <span class=\"string\">'third_party:android_support'</span></div><div class=\"line\"><span class=\"comment\">// 也可以这样写</span></div><div class=\"line\"><span class=\"comment\">// include ':app', 'third_party:android_support'</span></div></pre></td></tr></table></figure>\n<p>注意：一个特例：当根目录就是app模块是不需要在<code>setting.gradle</code>中写出。</p>\n<h3 id=\"app模块build-gradle\"><a href=\"#app模块build-gradle\" class=\"headerlink\" title=\"app模块build.gradle\"></a>app模块build.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></div><div class=\"line\"></div><div class=\"line\">android &#123;</div><div class=\"line\">    compileSdkVersion <span class=\"number\">23</span></div><div class=\"line\">    buildToolsVersion <span class=\"string\">\"23.0.2\"</span></div><div class=\"line\"></div><div class=\"line\">    defaultConfig &#123;</div><div class=\"line\">        applicationId <span class=\"string\">\"com.example.baidu.helloworld\"</span></div><div class=\"line\">        minSdkVersion <span class=\"number\">14</span></div><div class=\"line\">        targetSdkVersion <span class=\"number\">23</span></div><div class=\"line\">        versionCode <span class=\"number\">1</span></div><div class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    buildTypes &#123;</div><div class=\"line\">        release &#123;</div><div class=\"line\">            minifyEnabled <span class=\"literal\">false</span></div><div class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</div><div class=\"line\">    testCompile <span class=\"string\">'junit:junit:4.12'</span></div><div class=\"line\">    compile <span class=\"string\">'com.android.support:appcompat-v7:23.2.1'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个是android app配置的主要内容，从顶层开始看：<code>apply plugin</code>,<code>android</code>,<code>dependencies</code>三大区块内容（除此此外还可以有<code>repositories</code>，<strong><code>configurations</code></strong>）。</p>\n<ul>\n<li><p><code>apply plugin: xxx</code>：插件就是之前引入的android gradle 1.5库导入的常用的有：</p>\n<ul>\n<li><code>&#39;com.android.application&#39;</code> 指示当前编译的是android app主模块，一个应用中有且仅有一个。</li>\n<li><code>&#39;com.android.library&#39;</code> 指示当前编译的是android 库模块，这种library可以包含android包和资源并且<strong>可以导出aar包</strong>，这是AS特有的功能，包含了资源文件。</li>\n<li><code>&#39;java&#39;</code> 指示当前编译的是纯的java库模块，注意这个plugin不是android gradle插件引入的，是gradle原生。如果某个库被定义成此类型，<strong>此模块不能引用其他Android模块！</strong>这种library能导出jar包，和eclipse的功能类似。<strong>疑问：可以只引用，不编译android.jar吗？</strong></li>\n</ul>\n</li>\n<li><p><code>dependencies</code>区块：该模块依赖的库。通常有下面这些写法：</p>\n<ul>\n<li><code>compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</code> ：编译位于libs目录下的一下jar包。</li>\n<li><code>compile xxx</code> ：编译jcenter的某个库。最常用。</li>\n<li><p><code>compile project(&#39;:xxx&#39;)</code> ：编译其他模块，<strong>建立模块之间的依赖，十分重要</strong>，也可以在AS的项目配置中查看。</p>\n<p>除此之外，还可能包括：</p>\n</li>\n<li><p><code>provided xxx</code> ：<strong>还不了解，只引用，不编译？？？</strong></p>\n</li>\n<li><p><code>testCompile xxx</code> ：<strong>测试情况下编译?</strong></p>\n<p>当请入第三方gradle插件时，比如apt插件会引入：</p>\n</li>\n<li><p><code>apt xxx</code> ：引入第三方注解依赖，<strong>思考并理解与apt插件的关系</strong>：apt是编译工具，xxx是被编译的内容，比如dagger的注解。</p>\n</li>\n</ul>\n</li>\n<li><p><code>android</code>区块：这里android gradle插件引入的区块，可以定义所有android相关的配置，比如应用编译的签名，applicationId，版本，lint开关，编译选项(java版本)，设置源码目录，生成多个包等等，<strong>大部分的android编译的配置</strong>。<a href=\"ttp://tools.android.com/tech-docs/new-build-system/user-guide\">请阅读文档！</a></p>\n</li>\n<li>其他区块：还有一些区块是其他gradle插件引入的，比如微信的资源混淆插件就回加入一个自己的区块，可以配置资源混淆相关的选项。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><p><code>apply from: &quot;$rootDir/config/config.gradle&quot;</code>：这种样式可能有多个，表示引入配置文件。<code>build.gradle</code>可能很长，按照功能把build分为多个子build是不错的实践。</p>\n<blockquote>\n<p>在根目录新建文件夹<code>config</code>，在文件夹config中，写多个<code>xxx.gradle</code>文件，比如<code>quality.gradle</code>，它来为我的项目集成并配置所有的质量控制工具。然后通过<code>apply from</code>导入到对应的build.gradle文件。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"一些待理解的问题\"><a href=\"#一些待理解的问题\" class=\"headerlink\" title=\"一些待理解的问题\"></a>一些待理解的问题</h2><ul>\n<li><code>provided</code> 的具体含义的理解</li>\n<li><code>configurations</code> 区块</li>\n<li>测试相关的内容</li>\n</ul>\n<h2 id=\"工程实践\"><a href=\"#工程实践\" class=\"headerlink\" title=\"工程实践\"></a>工程实践</h2><p>参考<a href=\"https://github.com/android10/Android-CleanArchitecture\">clean构架的demo</a>，总结几点</p>\n<ul>\n<li><code>build.gradle</code>按功能分成多个<code>xxx.gradle</code>文件，即必须分块！</li>\n<li>将所有依赖的内容放入一个单独的文件中，如<code>config.gradle</code>。方便以后配置管理。（<code>ext</code>的使用！）</li>\n<li>细节：<ul>\n<li><code>compile project()</code> 模块间依赖的建立。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"深入学习\"><a href=\"#深入学习\" class=\"headerlink\" title=\"深入学习\"></a>深入学习</h2><ul>\n<li><a href=\"http://blog.csdn.net/innost/article/details/48228651\">深入理解Android之Gradle</a></li>\n<li><a href=\"http://tools.android.com/tech-docs/new-build-system/user-guide\">android gradle 插件官方文档</a></li>\n<li><a href=\"https://docs.gradle.org/current/userguide/userguide_single.html\">gradle官方文档</a></li>\n</ul>\n"},{"title":"Android构架系列之二--MVP&&Clean理解与实践之Clean","date":"2016-05-08T07:40:20.000Z","_content":"\n一万个人心中有十万个Clean。对Clean的理解每个人都不相同，网上也有很多很多的实现，我试图从最原始的资料出发，结合自己的理解讲解一下Clean构架。\n首先，要明确的一点是Clean是一种**分层架构**，是一种软件系统架构模式/思想。\n> 其他架构有：事件驱动架构、微内核架构、微服务架构、基于空间的架构。---《软件架构模式》\n\n这与MVP不同，MVP关注UI层（对应Clean中Presentation）的设计，更偏向与代码的设计，而Clean可以理解成一种自上而下的，全面的构架（会考虑性能等因素），更加抽象。\n\n在开始之前，我想强调的一点是，**Clean构架不适用于所有移动应用，它适用的范围是那些Model非常复杂的应用，但是移动应用的设计趋势是薄的Model，在这种情况下Clean略显臃肿。单独使用MVP可能更适应于快速开发的要求。**可以说Clean的复杂性很大一部分是来自于把Model独立抽出的需求，在移动App上，这很可能没有必要。\n\n原始资料如下：\n\n* [原始文章](http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html)\n：Bob大叔关于Clean的文章，适用于很多场景，不限于Android。比较抽象，难以理解，不建议首先学习！\n* Clean构架详细的解析文章，[原文](http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)，[中文翻译](http://zhuanlan.zhihu.com/p/20001838)：Android平台上Clean的一种实现，Github上Star很多的项目，可以直接学习这一篇文章，GitHub有详细的[代码和讲解](https://github.com/android10/Android-CleanArchitecture)，注意作者迭代了两个版本,第一版是没有依赖注入，RxJava那些框架的，相对比较好理解。\n* Clean构架的[GitHub Issue](https://github.com/android10/Android-CleanArchitecture/issues?utf8=%E2%9C%93&q=)：这个**重点推荐**，里面很多问题很有价值。\n\n其他参考文章：\n\n* [国人讲解的Clean框架](http://blog.chengdazhi.com/index.php/101)：如果上面的有困难，建议优先学习这篇文章，构架在在一个工程Module中，代码干净，比较好理解，但是可能对Clean的理解并不透彻。\n* [Android MVP 详解（下）](http://www.jianshu.com/p/0590f530c617)：也是Clean的总结，加入了自己的理解，可以参考。\n\n> 架构是一种高层思想，我这里只是从Demo中学习，其实Clean有无数种实现方式，比如，依赖的解耦可以用接口，也可以用命令等等，这些其实是细节！\n\n## 理解Clean\n![](images/arch_clean.png)\n这张图可是说是理解Clean的核心，第一次学习Clean就看到了这张图，留下了满满的疑惑，甚至被误解了。相关误解看[这个Issue](https://github.com/android10/Android-CleanArchitecture/issues/136)\n> The one you are citing shows how data flow through the layers, not dependencies or relation of the layers between themselves\n\n最重要的： **洋葱图是依赖图，右下角的图片是控制流图**，不要混淆。\n\n### 依赖原则与控制流\n依赖原则和控制流是Clean构架的核心，只有理解了依赖原则和控制流，才能理解Clean为什么这么设计。\n\n* 向内依赖：洋葱图中，内环里的所有项不能了解外环所发生的东西(内环使用接口操作外环，外环可以直接调用内环）。注意：最内层的Entity是Domain层的业务实体。\n\t> * source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle. In particular, the name of something declared in an outer circle must not be mentioned by the code in the an inner circle. That includes, functions, classes. variables, or any other named software entity.\n\t> * The outer circles are mechanisms. The inner circles are policies.**内环是策略，外环是机制。**\n\n* 数据结构也要遵循依赖原则，因此要经常转变数据结构。\n* 控制流图中，注意`User Case Interactor`的箭头！它就是最内层的，但是它是控制流的Master。可以这样理解，**Controller（如用户操作的UI事件）启动了Interator之后，Interactor主管所有事务，包括调用Data层，Interactor内部处理数据，最后塞给Presentation层。**\n\n> 存疑：\n>\n> * 区分Enterprise Business Rules 与 Application Bussiness Rules\n> * 这里的控制流，是单一的吗？即一个Interactor执行一个动作就一个回调。还是Interactor可以不断给Presentation塞数据？比如有一个需求，5S刷新一次界面。\n\n### 依赖原则与接口设计\n为了满足依赖原则，内核不知道外环的具体实现，因此，必须使用接口设计（未必，可以用其他方式！）：\n\n* 内环Domain是Master的角色，它操控其他层的接口（Data层数据输入的接口和Presentation层数据输出的接口），来实现业务。\n* 为了满足内环的独立性，**接口要设计在Domain那一层。**这种独立性可能是分module的要求，下面会单独讨论是否需要分module设计。\n\n### Clean与性能\nClean构架中把Model完全分离到了Domain与Data层中，这有一个巨大的好处，可以极大可能地避免应用的性能问题。\n我们知道，Android开发中的一大问题是ANR，在主线程进行太多的业务操作，导致应用卡顿。使用Clean时，在设计框架的过程中，**我们在框架中可以强制Domain层在异步线程中运行。**这个设计思想可以**与`AsyncTask`类比**，如同`doInBackground()`方法放入了Domain与Data中，`pre`和`post`则做了Presentation的工作。\n由此，各层设计如下：\n\nlayer        |thread         |interface\n------------ | ------------- | -----------\nPresentation | Main Thread   |\nDomain       | Work Thread   |**异步回调**\nData         |与Domain同线程   |**同步调用**\n\n可以发现Data层使用同步接口，这样的优势是Domain使用Data获取数据的逻辑是否简单，减少了线程同步的操作。\n\n### Clean与MVP\nClean是一种**分层构架**，软件架构模式/思想！MVX更像设计模式。构架是一种静态的形式，Clean构架告诉你需要把业务逻辑从M中单独拿出来，分成BLL和DAL。所以Clean是更高的抽象，MVX更详细的设计，还会告诉你数据如何流动。这样的表述更合理：**Clean构架是在MVP上使用了三层构架！**\n\n![](images/arch_mvp_clean.png)\n\n## 代码设计\nPresentation属于视图层，一般使用MVP，Domain和Data属于Model层，在移动App中应当很薄（很多Demo就是透传了数据。。）这里粗浅的说一下，以后有专门的文章讲Model层设计。\n具体代码看下一篇-- [Android构架系列之二--MVP&&Clean理解与实践之实例分析]()\n\n### Presentation层 -- MVP\n由Clean与MVP的关系，我们可以很容易地设计Presentation层，MVP的设计参考前一篇文章。\n注意Presenter中的**视图逻辑**。\n\t\n> 疑问： \n> \n> * [分页是哪里的逻辑]( https://github.com/android10/Android-CleanArchitecture/issues/94)\n\n### Domain层 -- 命令模式\nDomain层属于Model的BLL，业务逻辑\n> 疑问： \n> \n> * 粒度问题\n> * Domain数据是否需要缓存？\n> * one Call one Callback? one Call many Callback-->notify?\n\n### Data层 -- 数据仓库模式(Repository)\nData层属于Model的DAL\n一个误区：这里的Data是业务的Data，不是我们理解的文件，图片的缓存这些东西。如果他们有业务含义则可以放到Data层中，否则只能算工具类（如Glide）\n> 疑问： \n> \n> * Model的原始数据是否需要缓存？\n\n\n\n### 单独讲讲各层之间的接口\n各层之间的接口都是成对出现的，分为调用接口和回调接口\n\n## 其他问题讨论\n### 是否需要分Module？\n这个问题在[Issues上也有讨论](https://github.com/android10/Android-CleanArchitecture/issues/112#issuecomment-210073233)，first layer,then feature?分析了各种优缺点，可以参考。原来的工程是分Module这样设计的，作者的理由是便于测试和强制的分层，但是随着Android测试工具的发展，这种理由已经变弱，因此作者也开发了相应的合并分支。\n一种折中的方案是：还是分Module，但是Module内部使用功能再分包。\n\n### 数据通知的问题\n由于MVP构架的天然缺陷。数据通知问题需要特殊处理。\n参考这个[Issues](https://github.com/android10/Android-CleanArchitecture/issues/66),总结如下\n#### 使用EventBus\n1. 什么时候可以加入EventBus机制\n> So Event busses can be useful in the case of \"Data layer lets the Presentation layer know a User was updated in a background service to we can show a toast\". But they are not to be used in case of Commands, eg: \"User clicks on a button to update a user\". As said, events indicate that something has happened, not that something should happen.\n\n2. 哪里发布消息，哪里接收消息\n> From the architectural standpoint presented in this repository, an event bus certainly can be implemented, and most probably in the Data Layer. You could have some kind of background service that would poll your Api from time to time. When an update happens, that background service would have a references to the Event Bus ( or Aggregator ) and post a UserUpdatedEvent to it. Any subscribers on the Event Bus would then be notified. Another discussion is where these subscribers should exist, but that depends on the scope of your application. Usually this will be in the Presentation Layer.（理解：事件的结果需要展示的化就是Presentation层接收--绝大部分情况，不需要展示则Domain层接收）\n另一个人say:\nIn general, i can say, that i use event bus only in order to pass events from the data layer to the presentation layer. Events, but not the data\n\n3. 发送的Event数据是什么\n> Something of note is that Events indicate that something has happen, but be careful with what data you pass with the Event. Ideally the Event holds minimal immutable data to inform subscribers. In the case of a UserUpdatedEvent, the Event holds the ID of the user that was updated, but not the User Object itself. If you would do this, the subscriber would consume the Event and use that data (eg, show the new User's name in a Toast) but might skip over a lot of Data or Business logic. The subscriber should use the ID passed by the event to get the new User through a Use Case. This way, you pass by your business rules and any Data implementation that might exist. For example, a business rule states that a user with a long name should verify if this name is correct. But if the subscriber in the Presenter consumes an entire User object and just shows the Toast, the business rules that are applied when getting a User through a Use Case are not enforced. ( keep in mind, i'm just making up silly rules here )\n\n4. 区分Action与Event( do not confuse Events with Actions.)\n> * events：被动接收：Background service -> cloud service -> callback -> push event -> listeners are notified。实践上，events表示已经发生的事情，比如数据已经更新了。\n> * Actions:主动发出到回调：GUI -> domain -> data -> cloud service -> callback -> data -> domain -> GUI。实践上，actions表示要/正在发生的事情。用户点击按钮，触发了行为。\n\n5. Eventbus虽然完全解耦，但是容易失控！\n> they work the same way as GOTO instruction ！就像很多语言中的goto语句。导致最后难以Debug。event spaghetti\n\n#### 使用RxJava\n待补充\n\n## 总结\n本文详细论述了什么是Clean构架，以及讲解了Clean构架的难点，如同MVP的理解，Clean也有各种各样的分析，我试图从一些原始资料出发分析什么是Clean，然而，建议学习时还是看原始资料能更好的理解Clean。最后我想强调的是Clean不是万能的构架，有自身的问题，这需要我们根据业务需求具体问题具体分析。\n下一篇文章讲解具体代码，以[Google构架Demo的clean分支](https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean)来讲解，由于Clean包含了MVP部分，所以MVP的部分一并说明。\n\n\n","source":"_posts/Android构架系列之二-MVP&&Clean理解与实践之Clean.md","raw":"title: Android构架系列之二--MVP&&Clean理解与实践之Clean\ndate: 2016-05-08 15:40:20\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n\n一万个人心中有十万个Clean。对Clean的理解每个人都不相同，网上也有很多很多的实现，我试图从最原始的资料出发，结合自己的理解讲解一下Clean构架。\n首先，要明确的一点是Clean是一种**分层架构**，是一种软件系统架构模式/思想。\n> 其他架构有：事件驱动架构、微内核架构、微服务架构、基于空间的架构。---《软件架构模式》\n\n这与MVP不同，MVP关注UI层（对应Clean中Presentation）的设计，更偏向与代码的设计，而Clean可以理解成一种自上而下的，全面的构架（会考虑性能等因素），更加抽象。\n\n在开始之前，我想强调的一点是，**Clean构架不适用于所有移动应用，它适用的范围是那些Model非常复杂的应用，但是移动应用的设计趋势是薄的Model，在这种情况下Clean略显臃肿。单独使用MVP可能更适应于快速开发的要求。**可以说Clean的复杂性很大一部分是来自于把Model独立抽出的需求，在移动App上，这很可能没有必要。\n\n原始资料如下：\n\n* [原始文章](http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html)\n：Bob大叔关于Clean的文章，适用于很多场景，不限于Android。比较抽象，难以理解，不建议首先学习！\n* Clean构架详细的解析文章，[原文](http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)，[中文翻译](http://zhuanlan.zhihu.com/p/20001838)：Android平台上Clean的一种实现，Github上Star很多的项目，可以直接学习这一篇文章，GitHub有详细的[代码和讲解](https://github.com/android10/Android-CleanArchitecture)，注意作者迭代了两个版本,第一版是没有依赖注入，RxJava那些框架的，相对比较好理解。\n* Clean构架的[GitHub Issue](https://github.com/android10/Android-CleanArchitecture/issues?utf8=%E2%9C%93&q=)：这个**重点推荐**，里面很多问题很有价值。\n\n其他参考文章：\n\n* [国人讲解的Clean框架](http://blog.chengdazhi.com/index.php/101)：如果上面的有困难，建议优先学习这篇文章，构架在在一个工程Module中，代码干净，比较好理解，但是可能对Clean的理解并不透彻。\n* [Android MVP 详解（下）](http://www.jianshu.com/p/0590f530c617)：也是Clean的总结，加入了自己的理解，可以参考。\n\n> 架构是一种高层思想，我这里只是从Demo中学习，其实Clean有无数种实现方式，比如，依赖的解耦可以用接口，也可以用命令等等，这些其实是细节！\n\n## 理解Clean\n![](images/arch_clean.png)\n这张图可是说是理解Clean的核心，第一次学习Clean就看到了这张图，留下了满满的疑惑，甚至被误解了。相关误解看[这个Issue](https://github.com/android10/Android-CleanArchitecture/issues/136)\n> The one you are citing shows how data flow through the layers, not dependencies or relation of the layers between themselves\n\n最重要的： **洋葱图是依赖图，右下角的图片是控制流图**，不要混淆。\n\n### 依赖原则与控制流\n依赖原则和控制流是Clean构架的核心，只有理解了依赖原则和控制流，才能理解Clean为什么这么设计。\n\n* 向内依赖：洋葱图中，内环里的所有项不能了解外环所发生的东西(内环使用接口操作外环，外环可以直接调用内环）。注意：最内层的Entity是Domain层的业务实体。\n\t> * source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle. In particular, the name of something declared in an outer circle must not be mentioned by the code in the an inner circle. That includes, functions, classes. variables, or any other named software entity.\n\t> * The outer circles are mechanisms. The inner circles are policies.**内环是策略，外环是机制。**\n\n* 数据结构也要遵循依赖原则，因此要经常转变数据结构。\n* 控制流图中，注意`User Case Interactor`的箭头！它就是最内层的，但是它是控制流的Master。可以这样理解，**Controller（如用户操作的UI事件）启动了Interator之后，Interactor主管所有事务，包括调用Data层，Interactor内部处理数据，最后塞给Presentation层。**\n\n> 存疑：\n>\n> * 区分Enterprise Business Rules 与 Application Bussiness Rules\n> * 这里的控制流，是单一的吗？即一个Interactor执行一个动作就一个回调。还是Interactor可以不断给Presentation塞数据？比如有一个需求，5S刷新一次界面。\n\n### 依赖原则与接口设计\n为了满足依赖原则，内核不知道外环的具体实现，因此，必须使用接口设计（未必，可以用其他方式！）：\n\n* 内环Domain是Master的角色，它操控其他层的接口（Data层数据输入的接口和Presentation层数据输出的接口），来实现业务。\n* 为了满足内环的独立性，**接口要设计在Domain那一层。**这种独立性可能是分module的要求，下面会单独讨论是否需要分module设计。\n\n### Clean与性能\nClean构架中把Model完全分离到了Domain与Data层中，这有一个巨大的好处，可以极大可能地避免应用的性能问题。\n我们知道，Android开发中的一大问题是ANR，在主线程进行太多的业务操作，导致应用卡顿。使用Clean时，在设计框架的过程中，**我们在框架中可以强制Domain层在异步线程中运行。**这个设计思想可以**与`AsyncTask`类比**，如同`doInBackground()`方法放入了Domain与Data中，`pre`和`post`则做了Presentation的工作。\n由此，各层设计如下：\n\nlayer        |thread         |interface\n------------ | ------------- | -----------\nPresentation | Main Thread   |\nDomain       | Work Thread   |**异步回调**\nData         |与Domain同线程   |**同步调用**\n\n可以发现Data层使用同步接口，这样的优势是Domain使用Data获取数据的逻辑是否简单，减少了线程同步的操作。\n\n### Clean与MVP\nClean是一种**分层构架**，软件架构模式/思想！MVX更像设计模式。构架是一种静态的形式，Clean构架告诉你需要把业务逻辑从M中单独拿出来，分成BLL和DAL。所以Clean是更高的抽象，MVX更详细的设计，还会告诉你数据如何流动。这样的表述更合理：**Clean构架是在MVP上使用了三层构架！**\n\n![](images/arch_mvp_clean.png)\n\n## 代码设计\nPresentation属于视图层，一般使用MVP，Domain和Data属于Model层，在移动App中应当很薄（很多Demo就是透传了数据。。）这里粗浅的说一下，以后有专门的文章讲Model层设计。\n具体代码看下一篇-- [Android构架系列之二--MVP&&Clean理解与实践之实例分析]()\n\n### Presentation层 -- MVP\n由Clean与MVP的关系，我们可以很容易地设计Presentation层，MVP的设计参考前一篇文章。\n注意Presenter中的**视图逻辑**。\n\t\n> 疑问： \n> \n> * [分页是哪里的逻辑]( https://github.com/android10/Android-CleanArchitecture/issues/94)\n\n### Domain层 -- 命令模式\nDomain层属于Model的BLL，业务逻辑\n> 疑问： \n> \n> * 粒度问题\n> * Domain数据是否需要缓存？\n> * one Call one Callback? one Call many Callback-->notify?\n\n### Data层 -- 数据仓库模式(Repository)\nData层属于Model的DAL\n一个误区：这里的Data是业务的Data，不是我们理解的文件，图片的缓存这些东西。如果他们有业务含义则可以放到Data层中，否则只能算工具类（如Glide）\n> 疑问： \n> \n> * Model的原始数据是否需要缓存？\n\n\n\n### 单独讲讲各层之间的接口\n各层之间的接口都是成对出现的，分为调用接口和回调接口\n\n## 其他问题讨论\n### 是否需要分Module？\n这个问题在[Issues上也有讨论](https://github.com/android10/Android-CleanArchitecture/issues/112#issuecomment-210073233)，first layer,then feature?分析了各种优缺点，可以参考。原来的工程是分Module这样设计的，作者的理由是便于测试和强制的分层，但是随着Android测试工具的发展，这种理由已经变弱，因此作者也开发了相应的合并分支。\n一种折中的方案是：还是分Module，但是Module内部使用功能再分包。\n\n### 数据通知的问题\n由于MVP构架的天然缺陷。数据通知问题需要特殊处理。\n参考这个[Issues](https://github.com/android10/Android-CleanArchitecture/issues/66),总结如下\n#### 使用EventBus\n1. 什么时候可以加入EventBus机制\n> So Event busses can be useful in the case of \"Data layer lets the Presentation layer know a User was updated in a background service to we can show a toast\". But they are not to be used in case of Commands, eg: \"User clicks on a button to update a user\". As said, events indicate that something has happened, not that something should happen.\n\n2. 哪里发布消息，哪里接收消息\n> From the architectural standpoint presented in this repository, an event bus certainly can be implemented, and most probably in the Data Layer. You could have some kind of background service that would poll your Api from time to time. When an update happens, that background service would have a references to the Event Bus ( or Aggregator ) and post a UserUpdatedEvent to it. Any subscribers on the Event Bus would then be notified. Another discussion is where these subscribers should exist, but that depends on the scope of your application. Usually this will be in the Presentation Layer.（理解：事件的结果需要展示的化就是Presentation层接收--绝大部分情况，不需要展示则Domain层接收）\n另一个人say:\nIn general, i can say, that i use event bus only in order to pass events from the data layer to the presentation layer. Events, but not the data\n\n3. 发送的Event数据是什么\n> Something of note is that Events indicate that something has happen, but be careful with what data you pass with the Event. Ideally the Event holds minimal immutable data to inform subscribers. In the case of a UserUpdatedEvent, the Event holds the ID of the user that was updated, but not the User Object itself. If you would do this, the subscriber would consume the Event and use that data (eg, show the new User's name in a Toast) but might skip over a lot of Data or Business logic. The subscriber should use the ID passed by the event to get the new User through a Use Case. This way, you pass by your business rules and any Data implementation that might exist. For example, a business rule states that a user with a long name should verify if this name is correct. But if the subscriber in the Presenter consumes an entire User object and just shows the Toast, the business rules that are applied when getting a User through a Use Case are not enforced. ( keep in mind, i'm just making up silly rules here )\n\n4. 区分Action与Event( do not confuse Events with Actions.)\n> * events：被动接收：Background service -> cloud service -> callback -> push event -> listeners are notified。实践上，events表示已经发生的事情，比如数据已经更新了。\n> * Actions:主动发出到回调：GUI -> domain -> data -> cloud service -> callback -> data -> domain -> GUI。实践上，actions表示要/正在发生的事情。用户点击按钮，触发了行为。\n\n5. Eventbus虽然完全解耦，但是容易失控！\n> they work the same way as GOTO instruction ！就像很多语言中的goto语句。导致最后难以Debug。event spaghetti\n\n#### 使用RxJava\n待补充\n\n## 总结\n本文详细论述了什么是Clean构架，以及讲解了Clean构架的难点，如同MVP的理解，Clean也有各种各样的分析，我试图从一些原始资料出发分析什么是Clean，然而，建议学习时还是看原始资料能更好的理解Clean。最后我想强调的是Clean不是万能的构架，有自身的问题，这需要我们根据业务需求具体问题具体分析。\n下一篇文章讲解具体代码，以[Google构架Demo的clean分支](https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean)来讲解，由于Clean包含了MVP部分，所以MVP的部分一并说明。\n\n\n","slug":"Android构架系列之二-MVP&&Clean理解与实践之Clean","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbby0007nac9b0089i20","content":"<p>一万个人心中有十万个Clean。对Clean的理解每个人都不相同，网上也有很多很多的实现，我试图从最原始的资料出发，结合自己的理解讲解一下Clean构架。<br>首先，要明确的一点是Clean是一种<strong>分层架构</strong>，是一种软件系统架构模式/思想。</p>\n<blockquote>\n<p>其他架构有：事件驱动架构、微内核架构、微服务架构、基于空间的架构。—《软件架构模式》</p>\n</blockquote>\n<p>这与MVP不同，MVP关注UI层（对应Clean中Presentation）的设计，更偏向与代码的设计，而Clean可以理解成一种自上而下的，全面的构架（会考虑性能等因素），更加抽象。</p>\n<p>在开始之前，我想强调的一点是，<strong>Clean构架不适用于所有移动应用，它适用的范围是那些Model非常复杂的应用，但是移动应用的设计趋势是薄的Model，在这种情况下Clean略显臃肿。单独使用MVP可能更适应于快速开发的要求。</strong>可以说Clean的复杂性很大一部分是来自于把Model独立抽出的需求，在移动App上，这很可能没有必要。</p>\n<p>原始资料如下：</p>\n<ul>\n<li><a href=\"http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html\" target=\"_blank\" rel=\"external\">原始文章</a><br>：Bob大叔关于Clean的文章，适用于很多场景，不限于Android。比较抽象，难以理解，不建议首先学习！</li>\n<li>Clean构架详细的解析文章，<a href=\"http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/\" target=\"_blank\" rel=\"external\">原文</a>，<a href=\"http://zhuanlan.zhihu.com/p/20001838\" target=\"_blank\" rel=\"external\">中文翻译</a>：Android平台上Clean的一种实现，Github上Star很多的项目，可以直接学习这一篇文章，GitHub有详细的<a href=\"https://github.com/android10/Android-CleanArchitecture\" target=\"_blank\" rel=\"external\">代码和讲解</a>，注意作者迭代了两个版本,第一版是没有依赖注入，RxJava那些框架的，相对比较好理解。</li>\n<li>Clean构架的<a href=\"https://github.com/android10/Android-CleanArchitecture/issues?utf8=%E2%9C%93&amp;q=\" target=\"_blank\" rel=\"external\">GitHub Issue</a>：这个<strong>重点推荐</strong>，里面很多问题很有价值。</li>\n</ul>\n<p>其他参考文章：</p>\n<ul>\n<li><a href=\"http://blog.chengdazhi.com/index.php/101\" target=\"_blank\" rel=\"external\">国人讲解的Clean框架</a>：如果上面的有困难，建议优先学习这篇文章，构架在在一个工程Module中，代码干净，比较好理解，但是可能对Clean的理解并不透彻。</li>\n<li><a href=\"http://www.jianshu.com/p/0590f530c617\" target=\"_blank\" rel=\"external\">Android MVP 详解（下）</a>：也是Clean的总结，加入了自己的理解，可以参考。</li>\n</ul>\n<blockquote>\n<p>架构是一种高层思想，我这里只是从Demo中学习，其实Clean有无数种实现方式，比如，依赖的解耦可以用接口，也可以用命令等等，这些其实是细节！</p>\n</blockquote>\n<h2 id=\"理解Clean\"><a href=\"#理解Clean\" class=\"headerlink\" title=\"理解Clean\"></a>理解Clean</h2><p><img src=\"images/arch_clean.png\" alt=\"\"><br>这张图可是说是理解Clean的核心，第一次学习Clean就看到了这张图，留下了满满的疑惑，甚至被误解了。相关误解看<a href=\"https://github.com/android10/Android-CleanArchitecture/issues/136\" target=\"_blank\" rel=\"external\">这个Issue</a></p>\n<blockquote>\n<p>The one you are citing shows how data flow through the layers, not dependencies or relation of the layers between themselves</p>\n</blockquote>\n<p>最重要的： <strong>洋葱图是依赖图，右下角的图片是控制流图</strong>，不要混淆。</p>\n<h3 id=\"依赖原则与控制流\"><a href=\"#依赖原则与控制流\" class=\"headerlink\" title=\"依赖原则与控制流\"></a>依赖原则与控制流</h3><p>依赖原则和控制流是Clean构架的核心，只有理解了依赖原则和控制流，才能理解Clean为什么这么设计。</p>\n<ul>\n<li><p>向内依赖：洋葱图中，内环里的所有项不能了解外环所发生的东西(内环使用接口操作外环，外环可以直接调用内环）。注意：最内层的Entity是Domain层的业务实体。</p>\n<blockquote>\n<ul>\n<li>source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle. In particular, the name of something declared in an outer circle must not be mentioned by the code in the an inner circle. That includes, functions, classes. variables, or any other named software entity.</li>\n<li>The outer circles are mechanisms. The inner circles are policies.<strong>内环是策略，外环是机制。</strong></li>\n</ul>\n</blockquote>\n</li>\n<li><p>数据结构也要遵循依赖原则，因此要经常转变数据结构。</p>\n</li>\n<li>控制流图中，注意<code>User Case Interactor</code>的箭头！它就是最内层的，但是它是控制流的Master。可以这样理解，<strong>Controller（如用户操作的UI事件）启动了Interator之后，Interactor主管所有事务，包括调用Data层，Interactor内部处理数据，最后塞给Presentation层。</strong></li>\n</ul>\n<blockquote>\n<p>存疑：</p>\n<ul>\n<li>区分Enterprise Business Rules 与 Application Bussiness Rules</li>\n<li>这里的控制流，是单一的吗？即一个Interactor执行一个动作就一个回调。还是Interactor可以不断给Presentation塞数据？比如有一个需求，5S刷新一次界面。</li>\n</ul>\n</blockquote>\n<h3 id=\"依赖原则与接口设计\"><a href=\"#依赖原则与接口设计\" class=\"headerlink\" title=\"依赖原则与接口设计\"></a>依赖原则与接口设计</h3><p>为了满足依赖原则，内核不知道外环的具体实现，因此，必须使用接口设计（未必，可以用其他方式！）：</p>\n<ul>\n<li>内环Domain是Master的角色，它操控其他层的接口（Data层数据输入的接口和Presentation层数据输出的接口），来实现业务。</li>\n<li>为了满足内环的独立性，<strong>接口要设计在Domain那一层。</strong>这种独立性可能是分module的要求，下面会单独讨论是否需要分module设计。</li>\n</ul>\n<h3 id=\"Clean与性能\"><a href=\"#Clean与性能\" class=\"headerlink\" title=\"Clean与性能\"></a>Clean与性能</h3><p>Clean构架中把Model完全分离到了Domain与Data层中，这有一个巨大的好处，可以极大可能地避免应用的性能问题。<br>我们知道，Android开发中的一大问题是ANR，在主线程进行太多的业务操作，导致应用卡顿。使用Clean时，在设计框架的过程中，<strong>我们在框架中可以强制Domain层在异步线程中运行。</strong>这个设计思想可以<strong>与<code>AsyncTask</code>类比</strong>，如同<code>doInBackground()</code>方法放入了Domain与Data中，<code>pre</code>和<code>post</code>则做了Presentation的工作。<br>由此，各层设计如下：</p>\n<table>\n<thead>\n<tr>\n<th>layer</th>\n<th>thread</th>\n<th>interface</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Presentation</td>\n<td>Main Thread</td>\n<td></td>\n</tr>\n<tr>\n<td>Domain</td>\n<td>Work Thread</td>\n<td><strong>异步回调</strong></td>\n</tr>\n<tr>\n<td>Data</td>\n<td>与Domain同线程</td>\n<td><strong>同步调用</strong></td>\n</tr>\n</tbody>\n</table>\n<p>可以发现Data层使用同步接口，这样的优势是Domain使用Data获取数据的逻辑是否简单，减少了线程同步的操作。</p>\n<h3 id=\"Clean与MVP\"><a href=\"#Clean与MVP\" class=\"headerlink\" title=\"Clean与MVP\"></a>Clean与MVP</h3><p>Clean是一种<strong>分层构架</strong>，软件架构模式/思想！MVX更像设计模式。构架是一种静态的形式，Clean构架告诉你需要把业务逻辑从M中单独拿出来，分成BLL和DAL。所以Clean是更高的抽象，MVX更详细的设计，还会告诉你数据如何流动。这样的表述更合理：<strong>Clean构架是在MVP上使用了三层构架！</strong></p>\n<p><img src=\"images/arch_mvp_clean.png\" alt=\"\"></p>\n<h2 id=\"代码设计\"><a href=\"#代码设计\" class=\"headerlink\" title=\"代码设计\"></a>代码设计</h2><p>Presentation属于视图层，一般使用MVP，Domain和Data属于Model层，在移动App中应当很薄（很多Demo就是透传了数据。。）这里粗浅的说一下，以后有专门的文章讲Model层设计。<br>具体代码看下一篇– <a href=\"\">Android构架系列之二–MVP&amp;&amp;Clean理解与实践之实例分析</a></p>\n<h3 id=\"Presentation层-–-MVP\"><a href=\"#Presentation层-–-MVP\" class=\"headerlink\" title=\"Presentation层 – MVP\"></a>Presentation层 – MVP</h3><p>由Clean与MVP的关系，我们可以很容易地设计Presentation层，MVP的设计参考前一篇文章。<br>注意Presenter中的<strong>视图逻辑</strong>。</p>\n<blockquote>\n<p>疑问： </p>\n<ul>\n<li><a href=\"https://github.com/android10/Android-CleanArchitecture/issues/94\" target=\"_blank\" rel=\"external\">分页是哪里的逻辑</a></li>\n</ul>\n</blockquote>\n<h3 id=\"Domain层-–-命令模式\"><a href=\"#Domain层-–-命令模式\" class=\"headerlink\" title=\"Domain层 – 命令模式\"></a>Domain层 – 命令模式</h3><p>Domain层属于Model的BLL，业务逻辑</p>\n<blockquote>\n<p>疑问： </p>\n<ul>\n<li>粒度问题</li>\n<li>Domain数据是否需要缓存？</li>\n<li>one Call one Callback? one Call many Callback–&gt;notify?</li>\n</ul>\n</blockquote>\n<h3 id=\"Data层-–-数据仓库模式-Repository\"><a href=\"#Data层-–-数据仓库模式-Repository\" class=\"headerlink\" title=\"Data层 – 数据仓库模式(Repository)\"></a>Data层 – 数据仓库模式(Repository)</h3><p>Data层属于Model的DAL<br>一个误区：这里的Data是业务的Data，不是我们理解的文件，图片的缓存这些东西。如果他们有业务含义则可以放到Data层中，否则只能算工具类（如Glide）</p>\n<blockquote>\n<p>疑问： </p>\n<ul>\n<li>Model的原始数据是否需要缓存？</li>\n</ul>\n</blockquote>\n<h3 id=\"单独讲讲各层之间的接口\"><a href=\"#单独讲讲各层之间的接口\" class=\"headerlink\" title=\"单独讲讲各层之间的接口\"></a>单独讲讲各层之间的接口</h3><p>各层之间的接口都是成对出现的，分为调用接口和回调接口</p>\n<h2 id=\"其他问题讨论\"><a href=\"#其他问题讨论\" class=\"headerlink\" title=\"其他问题讨论\"></a>其他问题讨论</h2><h3 id=\"是否需要分Module？\"><a href=\"#是否需要分Module？\" class=\"headerlink\" title=\"是否需要分Module？\"></a>是否需要分Module？</h3><p>这个问题在<a href=\"https://github.com/android10/Android-CleanArchitecture/issues/112#issuecomment-210073233\" target=\"_blank\" rel=\"external\">Issues上也有讨论</a>，first layer,then feature?分析了各种优缺点，可以参考。原来的工程是分Module这样设计的，作者的理由是便于测试和强制的分层，但是随着Android测试工具的发展，这种理由已经变弱，因此作者也开发了相应的合并分支。<br>一种折中的方案是：还是分Module，但是Module内部使用功能再分包。</p>\n<h3 id=\"数据通知的问题\"><a href=\"#数据通知的问题\" class=\"headerlink\" title=\"数据通知的问题\"></a>数据通知的问题</h3><p>由于MVP构架的天然缺陷。数据通知问题需要特殊处理。<br>参考这个<a href=\"https://github.com/android10/Android-CleanArchitecture/issues/66\" target=\"_blank\" rel=\"external\">Issues</a>,总结如下</p>\n<h4 id=\"使用EventBus\"><a href=\"#使用EventBus\" class=\"headerlink\" title=\"使用EventBus\"></a>使用EventBus</h4><ol>\n<li><p>什么时候可以加入EventBus机制</p>\n<blockquote>\n<p>So Event busses can be useful in the case of “Data layer lets the Presentation layer know a User was updated in a background service to we can show a toast”. But they are not to be used in case of Commands, eg: “User clicks on a button to update a user”. As said, events indicate that something has happened, not that something should happen.</p>\n</blockquote>\n</li>\n<li><p>哪里发布消息，哪里接收消息</p>\n<blockquote>\n<p>From the architectural standpoint presented in this repository, an event bus certainly can be implemented, and most probably in the Data Layer. You could have some kind of background service that would poll your Api from time to time. When an update happens, that background service would have a references to the Event Bus ( or Aggregator ) and post a UserUpdatedEvent to it. Any subscribers on the Event Bus would then be notified. Another discussion is where these subscribers should exist, but that depends on the scope of your application. Usually this will be in the Presentation Layer.（理解：事件的结果需要展示的化就是Presentation层接收–绝大部分情况，不需要展示则Domain层接收）<br>另一个人say:<br>In general, i can say, that i use event bus only in order to pass events from the data layer to the presentation layer. Events, but not the data</p>\n</blockquote>\n</li>\n<li><p>发送的Event数据是什么</p>\n<blockquote>\n<p>Something of note is that Events indicate that something has happen, but be careful with what data you pass with the Event. Ideally the Event holds minimal immutable data to inform subscribers. In the case of a UserUpdatedEvent, the Event holds the ID of the user that was updated, but not the User Object itself. If you would do this, the subscriber would consume the Event and use that data (eg, show the new User’s name in a Toast) but might skip over a lot of Data or Business logic. The subscriber should use the ID passed by the event to get the new User through a Use Case. This way, you pass by your business rules and any Data implementation that might exist. For example, a business rule states that a user with a long name should verify if this name is correct. But if the subscriber in the Presenter consumes an entire User object and just shows the Toast, the business rules that are applied when getting a User through a Use Case are not enforced. ( keep in mind, i’m just making up silly rules here )</p>\n</blockquote>\n</li>\n<li><p>区分Action与Event( do not confuse Events with Actions.)</p>\n<blockquote>\n<ul>\n<li>events：被动接收：Background service -&gt; cloud service -&gt; callback -&gt; push event -&gt; listeners are notified。实践上，events表示已经发生的事情，比如数据已经更新了。</li>\n<li>Actions:主动发出到回调：GUI -&gt; domain -&gt; data -&gt; cloud service -&gt; callback -&gt; data -&gt; domain -&gt; GUI。实践上，actions表示要/正在发生的事情。用户点击按钮，触发了行为。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>Eventbus虽然完全解耦，但是容易失控！</p>\n<blockquote>\n<p>they work the same way as GOTO instruction ！就像很多语言中的goto语句。导致最后难以Debug。event spaghetti</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"使用RxJava\"><a href=\"#使用RxJava\" class=\"headerlink\" title=\"使用RxJava\"></a>使用RxJava</h4><p>待补充</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文详细论述了什么是Clean构架，以及讲解了Clean构架的难点，如同MVP的理解，Clean也有各种各样的分析，我试图从一些原始资料出发分析什么是Clean，然而，建议学习时还是看原始资料能更好的理解Clean。最后我想强调的是Clean不是万能的构架，有自身的问题，这需要我们根据业务需求具体问题具体分析。<br>下一篇文章讲解具体代码，以<a href=\"https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean\" target=\"_blank\" rel=\"external\">Google构架Demo的clean分支</a>来讲解，由于Clean包含了MVP部分，所以MVP的部分一并说明。</p>\n","excerpt":"","more":"<p>一万个人心中有十万个Clean。对Clean的理解每个人都不相同，网上也有很多很多的实现，我试图从最原始的资料出发，结合自己的理解讲解一下Clean构架。<br>首先，要明确的一点是Clean是一种<strong>分层架构</strong>，是一种软件系统架构模式/思想。</p>\n<blockquote>\n<p>其他架构有：事件驱动架构、微内核架构、微服务架构、基于空间的架构。—《软件架构模式》</p>\n</blockquote>\n<p>这与MVP不同，MVP关注UI层（对应Clean中Presentation）的设计，更偏向与代码的设计，而Clean可以理解成一种自上而下的，全面的构架（会考虑性能等因素），更加抽象。</p>\n<p>在开始之前，我想强调的一点是，<strong>Clean构架不适用于所有移动应用，它适用的范围是那些Model非常复杂的应用，但是移动应用的设计趋势是薄的Model，在这种情况下Clean略显臃肿。单独使用MVP可能更适应于快速开发的要求。</strong>可以说Clean的复杂性很大一部分是来自于把Model独立抽出的需求，在移动App上，这很可能没有必要。</p>\n<p>原始资料如下：</p>\n<ul>\n<li><a href=\"http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html\">原始文章</a><br>：Bob大叔关于Clean的文章，适用于很多场景，不限于Android。比较抽象，难以理解，不建议首先学习！</li>\n<li>Clean构架详细的解析文章，<a href=\"http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/\">原文</a>，<a href=\"http://zhuanlan.zhihu.com/p/20001838\">中文翻译</a>：Android平台上Clean的一种实现，Github上Star很多的项目，可以直接学习这一篇文章，GitHub有详细的<a href=\"https://github.com/android10/Android-CleanArchitecture\">代码和讲解</a>，注意作者迭代了两个版本,第一版是没有依赖注入，RxJava那些框架的，相对比较好理解。</li>\n<li>Clean构架的<a href=\"https://github.com/android10/Android-CleanArchitecture/issues?utf8=%E2%9C%93&amp;q=\">GitHub Issue</a>：这个<strong>重点推荐</strong>，里面很多问题很有价值。</li>\n</ul>\n<p>其他参考文章：</p>\n<ul>\n<li><a href=\"http://blog.chengdazhi.com/index.php/101\">国人讲解的Clean框架</a>：如果上面的有困难，建议优先学习这篇文章，构架在在一个工程Module中，代码干净，比较好理解，但是可能对Clean的理解并不透彻。</li>\n<li><a href=\"http://www.jianshu.com/p/0590f530c617\">Android MVP 详解（下）</a>：也是Clean的总结，加入了自己的理解，可以参考。</li>\n</ul>\n<blockquote>\n<p>架构是一种高层思想，我这里只是从Demo中学习，其实Clean有无数种实现方式，比如，依赖的解耦可以用接口，也可以用命令等等，这些其实是细节！</p>\n</blockquote>\n<h2 id=\"理解Clean\"><a href=\"#理解Clean\" class=\"headerlink\" title=\"理解Clean\"></a>理解Clean</h2><p><img src=\"images/arch_clean.png\" alt=\"\"><br>这张图可是说是理解Clean的核心，第一次学习Clean就看到了这张图，留下了满满的疑惑，甚至被误解了。相关误解看<a href=\"https://github.com/android10/Android-CleanArchitecture/issues/136\">这个Issue</a></p>\n<blockquote>\n<p>The one you are citing shows how data flow through the layers, not dependencies or relation of the layers between themselves</p>\n</blockquote>\n<p>最重要的： <strong>洋葱图是依赖图，右下角的图片是控制流图</strong>，不要混淆。</p>\n<h3 id=\"依赖原则与控制流\"><a href=\"#依赖原则与控制流\" class=\"headerlink\" title=\"依赖原则与控制流\"></a>依赖原则与控制流</h3><p>依赖原则和控制流是Clean构架的核心，只有理解了依赖原则和控制流，才能理解Clean为什么这么设计。</p>\n<ul>\n<li><p>向内依赖：洋葱图中，内环里的所有项不能了解外环所发生的东西(内环使用接口操作外环，外环可以直接调用内环）。注意：最内层的Entity是Domain层的业务实体。</p>\n<blockquote>\n<ul>\n<li>source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle. In particular, the name of something declared in an outer circle must not be mentioned by the code in the an inner circle. That includes, functions, classes. variables, or any other named software entity.</li>\n<li>The outer circles are mechanisms. The inner circles are policies.<strong>内环是策略，外环是机制。</strong></li>\n</ul>\n</blockquote>\n</li>\n<li><p>数据结构也要遵循依赖原则，因此要经常转变数据结构。</p>\n</li>\n<li>控制流图中，注意<code>User Case Interactor</code>的箭头！它就是最内层的，但是它是控制流的Master。可以这样理解，<strong>Controller（如用户操作的UI事件）启动了Interator之后，Interactor主管所有事务，包括调用Data层，Interactor内部处理数据，最后塞给Presentation层。</strong></li>\n</ul>\n<blockquote>\n<p>存疑：</p>\n<ul>\n<li>区分Enterprise Business Rules 与 Application Bussiness Rules</li>\n<li>这里的控制流，是单一的吗？即一个Interactor执行一个动作就一个回调。还是Interactor可以不断给Presentation塞数据？比如有一个需求，5S刷新一次界面。</li>\n</ul>\n</blockquote>\n<h3 id=\"依赖原则与接口设计\"><a href=\"#依赖原则与接口设计\" class=\"headerlink\" title=\"依赖原则与接口设计\"></a>依赖原则与接口设计</h3><p>为了满足依赖原则，内核不知道外环的具体实现，因此，必须使用接口设计（未必，可以用其他方式！）：</p>\n<ul>\n<li>内环Domain是Master的角色，它操控其他层的接口（Data层数据输入的接口和Presentation层数据输出的接口），来实现业务。</li>\n<li>为了满足内环的独立性，<strong>接口要设计在Domain那一层。</strong>这种独立性可能是分module的要求，下面会单独讨论是否需要分module设计。</li>\n</ul>\n<h3 id=\"Clean与性能\"><a href=\"#Clean与性能\" class=\"headerlink\" title=\"Clean与性能\"></a>Clean与性能</h3><p>Clean构架中把Model完全分离到了Domain与Data层中，这有一个巨大的好处，可以极大可能地避免应用的性能问题。<br>我们知道，Android开发中的一大问题是ANR，在主线程进行太多的业务操作，导致应用卡顿。使用Clean时，在设计框架的过程中，<strong>我们在框架中可以强制Domain层在异步线程中运行。</strong>这个设计思想可以<strong>与<code>AsyncTask</code>类比</strong>，如同<code>doInBackground()</code>方法放入了Domain与Data中，<code>pre</code>和<code>post</code>则做了Presentation的工作。<br>由此，各层设计如下：</p>\n<table>\n<thead>\n<tr>\n<th>layer</th>\n<th>thread</th>\n<th>interface</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Presentation</td>\n<td>Main Thread</td>\n<td></td>\n</tr>\n<tr>\n<td>Domain</td>\n<td>Work Thread</td>\n<td><strong>异步回调</strong></td>\n</tr>\n<tr>\n<td>Data</td>\n<td>与Domain同线程</td>\n<td><strong>同步调用</strong></td>\n</tr>\n</tbody>\n</table>\n<p>可以发现Data层使用同步接口，这样的优势是Domain使用Data获取数据的逻辑是否简单，减少了线程同步的操作。</p>\n<h3 id=\"Clean与MVP\"><a href=\"#Clean与MVP\" class=\"headerlink\" title=\"Clean与MVP\"></a>Clean与MVP</h3><p>Clean是一种<strong>分层构架</strong>，软件架构模式/思想！MVX更像设计模式。构架是一种静态的形式，Clean构架告诉你需要把业务逻辑从M中单独拿出来，分成BLL和DAL。所以Clean是更高的抽象，MVX更详细的设计，还会告诉你数据如何流动。这样的表述更合理：<strong>Clean构架是在MVP上使用了三层构架！</strong></p>\n<p><img src=\"images/arch_mvp_clean.png\" alt=\"\"></p>\n<h2 id=\"代码设计\"><a href=\"#代码设计\" class=\"headerlink\" title=\"代码设计\"></a>代码设计</h2><p>Presentation属于视图层，一般使用MVP，Domain和Data属于Model层，在移动App中应当很薄（很多Demo就是透传了数据。。）这里粗浅的说一下，以后有专门的文章讲Model层设计。<br>具体代码看下一篇– <a href=\"\">Android构架系列之二–MVP&amp;&amp;Clean理解与实践之实例分析</a></p>\n<h3 id=\"Presentation层-–-MVP\"><a href=\"#Presentation层-–-MVP\" class=\"headerlink\" title=\"Presentation层 – MVP\"></a>Presentation层 – MVP</h3><p>由Clean与MVP的关系，我们可以很容易地设计Presentation层，MVP的设计参考前一篇文章。<br>注意Presenter中的<strong>视图逻辑</strong>。</p>\n<blockquote>\n<p>疑问： </p>\n<ul>\n<li><a href=\"https://github.com/android10/Android-CleanArchitecture/issues/94\">分页是哪里的逻辑</a></li>\n</ul>\n</blockquote>\n<h3 id=\"Domain层-–-命令模式\"><a href=\"#Domain层-–-命令模式\" class=\"headerlink\" title=\"Domain层 – 命令模式\"></a>Domain层 – 命令模式</h3><p>Domain层属于Model的BLL，业务逻辑</p>\n<blockquote>\n<p>疑问： </p>\n<ul>\n<li>粒度问题</li>\n<li>Domain数据是否需要缓存？</li>\n<li>one Call one Callback? one Call many Callback–&gt;notify?</li>\n</ul>\n</blockquote>\n<h3 id=\"Data层-–-数据仓库模式-Repository\"><a href=\"#Data层-–-数据仓库模式-Repository\" class=\"headerlink\" title=\"Data层 – 数据仓库模式(Repository)\"></a>Data层 – 数据仓库模式(Repository)</h3><p>Data层属于Model的DAL<br>一个误区：这里的Data是业务的Data，不是我们理解的文件，图片的缓存这些东西。如果他们有业务含义则可以放到Data层中，否则只能算工具类（如Glide）</p>\n<blockquote>\n<p>疑问： </p>\n<ul>\n<li>Model的原始数据是否需要缓存？</li>\n</ul>\n</blockquote>\n<h3 id=\"单独讲讲各层之间的接口\"><a href=\"#单独讲讲各层之间的接口\" class=\"headerlink\" title=\"单独讲讲各层之间的接口\"></a>单独讲讲各层之间的接口</h3><p>各层之间的接口都是成对出现的，分为调用接口和回调接口</p>\n<h2 id=\"其他问题讨论\"><a href=\"#其他问题讨论\" class=\"headerlink\" title=\"其他问题讨论\"></a>其他问题讨论</h2><h3 id=\"是否需要分Module？\"><a href=\"#是否需要分Module？\" class=\"headerlink\" title=\"是否需要分Module？\"></a>是否需要分Module？</h3><p>这个问题在<a href=\"https://github.com/android10/Android-CleanArchitecture/issues/112#issuecomment-210073233\">Issues上也有讨论</a>，first layer,then feature?分析了各种优缺点，可以参考。原来的工程是分Module这样设计的，作者的理由是便于测试和强制的分层，但是随着Android测试工具的发展，这种理由已经变弱，因此作者也开发了相应的合并分支。<br>一种折中的方案是：还是分Module，但是Module内部使用功能再分包。</p>\n<h3 id=\"数据通知的问题\"><a href=\"#数据通知的问题\" class=\"headerlink\" title=\"数据通知的问题\"></a>数据通知的问题</h3><p>由于MVP构架的天然缺陷。数据通知问题需要特殊处理。<br>参考这个<a href=\"https://github.com/android10/Android-CleanArchitecture/issues/66\">Issues</a>,总结如下</p>\n<h4 id=\"使用EventBus\"><a href=\"#使用EventBus\" class=\"headerlink\" title=\"使用EventBus\"></a>使用EventBus</h4><ol>\n<li><p>什么时候可以加入EventBus机制</p>\n<blockquote>\n<p>So Event busses can be useful in the case of “Data layer lets the Presentation layer know a User was updated in a background service to we can show a toast”. But they are not to be used in case of Commands, eg: “User clicks on a button to update a user”. As said, events indicate that something has happened, not that something should happen.</p>\n</blockquote>\n</li>\n<li><p>哪里发布消息，哪里接收消息</p>\n<blockquote>\n<p>From the architectural standpoint presented in this repository, an event bus certainly can be implemented, and most probably in the Data Layer. You could have some kind of background service that would poll your Api from time to time. When an update happens, that background service would have a references to the Event Bus ( or Aggregator ) and post a UserUpdatedEvent to it. Any subscribers on the Event Bus would then be notified. Another discussion is where these subscribers should exist, but that depends on the scope of your application. Usually this will be in the Presentation Layer.（理解：事件的结果需要展示的化就是Presentation层接收–绝大部分情况，不需要展示则Domain层接收）<br>另一个人say:<br>In general, i can say, that i use event bus only in order to pass events from the data layer to the presentation layer. Events, but not the data</p>\n</blockquote>\n</li>\n<li><p>发送的Event数据是什么</p>\n<blockquote>\n<p>Something of note is that Events indicate that something has happen, but be careful with what data you pass with the Event. Ideally the Event holds minimal immutable data to inform subscribers. In the case of a UserUpdatedEvent, the Event holds the ID of the user that was updated, but not the User Object itself. If you would do this, the subscriber would consume the Event and use that data (eg, show the new User’s name in a Toast) but might skip over a lot of Data or Business logic. The subscriber should use the ID passed by the event to get the new User through a Use Case. This way, you pass by your business rules and any Data implementation that might exist. For example, a business rule states that a user with a long name should verify if this name is correct. But if the subscriber in the Presenter consumes an entire User object and just shows the Toast, the business rules that are applied when getting a User through a Use Case are not enforced. ( keep in mind, i’m just making up silly rules here )</p>\n</blockquote>\n</li>\n<li><p>区分Action与Event( do not confuse Events with Actions.)</p>\n<blockquote>\n<ul>\n<li>events：被动接收：Background service -&gt; cloud service -&gt; callback -&gt; push event -&gt; listeners are notified。实践上，events表示已经发生的事情，比如数据已经更新了。</li>\n<li>Actions:主动发出到回调：GUI -&gt; domain -&gt; data -&gt; cloud service -&gt; callback -&gt; data -&gt; domain -&gt; GUI。实践上，actions表示要/正在发生的事情。用户点击按钮，触发了行为。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>Eventbus虽然完全解耦，但是容易失控！</p>\n<blockquote>\n<p>they work the same way as GOTO instruction ！就像很多语言中的goto语句。导致最后难以Debug。event spaghetti</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"使用RxJava\"><a href=\"#使用RxJava\" class=\"headerlink\" title=\"使用RxJava\"></a>使用RxJava</h4><p>待补充</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文详细论述了什么是Clean构架，以及讲解了Clean构架的难点，如同MVP的理解，Clean也有各种各样的分析，我试图从一些原始资料出发分析什么是Clean，然而，建议学习时还是看原始资料能更好的理解Clean。最后我想强调的是Clean不是万能的构架，有自身的问题，这需要我们根据业务需求具体问题具体分析。<br>下一篇文章讲解具体代码，以<a href=\"https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean\">Google构架Demo的clean分支</a>来讲解，由于Clean包含了MVP部分，所以MVP的部分一并说明。</p>\n"},{"title":"Android构架系列之三--数据库ORM框架","date":"2016-04-10T13:09:42.000Z","_content":"\n## [数据库方案](https://www.zhihu.com/question/27977160)\n\n* 原生sqlite\n* orm框架\n* ContentProvider+LoaderManager\n* 结合使用\n\n最终选择了DBFlow框架，基于以下几点优势：\n\n* 速度快，没有反射，使用编译时生成相关类。\n* **支持Content Provider**，与schematic库相集成。\n* 流式的sql API，接口友好。\n* Google在Demo中使用，算是官方推荐的库。\n\n下面介绍一下ContentProvider和DBFlow框架\n\n## ContentProvider\n\n### 何时使用\nGoogle建议：http://developer.android.com/intl/zh-cn/guide/topics/providers/content-provider-creating.html\n\n\n### 使用ContentProvider\n* 一个app多个ContentProvider，一个ContentProvider，对应一个数据库，一个数据库中含有n个table（表）\n* 快速生成ContentProvider的工具-[schematic](https://github.com/SimonVT/schematic)，[demo](https://github.com/SimonVT/schematic/blob/master/schematic-samples%2Fsrc%2Fmain%2Fjava%2Fnet%2Fsimonvt%2Fschematic%2Fsample%2Fdatabase%2FNotesProvider.java)\n* 事务操作：创建一个 ContentProviderOperation 数组，然后将相应的操作添加到数组中，最后通过 ContentResolver.applyBatch 实现批量操作。\n\n### 注意点\n* 进程安全，但不是线程安全，query 等方法可以同时被多个线程调用，所以这些方法必须线程安全。也就是不能使用全局变量、静态变量。（如果非要使用，必须加锁）。但是，数据库dbhelp自身会对操作排队，所以不用担心数据库的线程安全。\n* 避免在 onCreate() 中执行长时间操作，只构建DbHelper。。不getdb，这很快。\n* 外部应用访问数据有多重方式，通过路径开发部分内容、临时权限，intent访问等\n\n\n## DBFlow功能介绍\n这个库的基本使用，先学习[官方文档](https://github.com/Raizlabs/DBFlow)，[中文](https://www.gitbook.com/book/3yumenokanata/dbflow-tutorials/details)，不再赘述。\n### 基本使用\n步骤：\n\n1. Application中初始化\n2. 建立DataBase。一般情况下，一个App只有一个DB，然后有多张表。\n3. 根据业务需求建立Table,必须实现Model接口（更多是继承BaseModel类）\n\n实际开发中，可能还需要建立表之间的关联（Relation），在建立Table时，通过`foreignKey`来实现（1对1，1对多，多对多-3.0以上）\n\n其他几个概念:\n\n* 类型转换器：`@Column`只支持基本数据类型/相关封装类/Date，使用自定义的转换器，可以支持自己实现的类。\n* _Table类：DBFlow会自动生成的类，里面的字段是查询条件常用的\n* _Adapter类:\n\n### 流式API\n使用DBFlow掌握了[流式的API](https://github.com/Raizlabs/DBFlow/blob/master/usage/SQLQuery.md)基本掌握了它的使用：\n下面两种使用方式功能相同：\n\n* `SQLite.select().from(someTable).where(conditions).query();`\n* `new Select().from(someTable).where(conditions).query();`\n\n\t其中\n\t* conditions为查询条件，一般为`someTable_Table.name.eq(\"muz\")`，从`_Table`类中找。\n\t* 同样适用于insert update delete。注意：**不用忘了最后都要调用**`query()`。\n\n### 面向对象API\n另外一种使用DBFlow的方式，没有上面那种方式灵活，但是更加友好。\n对于我们使用`@Table`注解的类，可以直接新建一个对象，如下：\n\n```java\nSomeTable oneRecord = new SomeTable();\noneRecord.id=1\noneRecord.load();\n```\n注意：局限性只能查找`@PrimaryKey `属性\n同样的，有update,insert等方法。\n\n### 一些使用要点\n\n* select中`query()`与`queryList()`：前者返回Cursor，后者直接返回对象List，**更安全**,不用close Cursor。\n* 同步与异步：**默认是同步查询**，需要异步加上`async()`和回调`query(listener)`\n* 如果需要多个查询条件，两种方式:\n\t1. 在where后添加and(xxx)或者or(xxx)--**更常用**\n\t2. 使用组合查询条件ConditionGroup\n\n\t```java\nSQLite.select()\n  .from(MyTable.class)\n  .where(MyTable_Table.someColumn.is(\"SomeValue\"))\n  .and(MyTable_Table.anotherColumn.is(\"ThisValue\"));\n// 或者\nSQLite.select()\n   .from(MyTable.class)\n   .where(ConditionGroup.clause()\n   .and(MyTable_Table.someColumn.is(\"SomeValue\")\n   .or(MyTable_Table.anotherColumn.is(\"ThisValue\"));\n```\n\n### 其他的高级功能（有用的）\n#### 数据迁移 - 数据库升级\nDBFlow支持使用`Migration `支持升级数据库`@Database`版本.\n\n* 继承`AlterTableMigration<SomeTable>`，修改SomeTable表操作\n\n\t```java\n@Migration(version = 2, database = AppDatabase.class)\npublic class Migration1 extends AlterTableMigration<TestModel> {\n  @Override\n  public void onPreMigrate() {\n    // 一些数据库操作，如修改表，需要测试！\n    addColumn(Long.class, \"timestamp\");\n  }\n}\n\n* 继承`UpdateTableMigration<SomeTable>`，修改SomeTable表中内容操作\n\n\t```java\n@Migration(version = 2, database = AppDatabase.class)\npublic class Migration1 extends UpdateTableMigration<TestModel> {\n\n    @Override\n    public void onPreMigrate() {\n      // UPDATE TestModel SET deviceType = \"phablet\" WHERE screenSize > 5.7 AND screenSize < 7;\n      set(TestModel_Table.deviceType.is(\"phablet\"))\n        .where(TestModel_Table.screenSize.greaterThan(5.7), TestModel_Table.screenSize.lessThan(7));\n    }\n    ```\n\n扩展功能：\n注意：如果**想要在第一次创建时对数据库进行初始化操作**，只需要使用**`version = 0`**\n\n#### 支持ContentProvider\n支持ContentProvider只有很少的修改。\n\n1. 将有@Database的类添加@ContentProvider\n\t\n\t```\n\t@ContentProvider(authority = TestDatabase.AUTHORITY,\n        database = TestDatabase.class,\n        baseContentUri = TestDatabase.BASE_CONTENT_URI)\n@Database(name = TestDatabase.NAME, version = TestDatabase.VERSION)\npublic class TestDatabase {\n\n    public static final String NAME = \"TestDatabase\";\n\n    public static final int VERSION = \"1\";\n\n    public static final String AUTHORITY = \"com.raizlabs.android.dbflow.test.provider\";\n\n    public static final String BASE_CONTENT_URI = \"content://\";\n}\n\t```\n2. 在Manifest添加provider，注意名称为`类名$Provider`。\n\n\t```xml\n\t<provider\n    android:authorities=\"com.raizlabs.android.dbflow.test.provider\"\n    android:exported=\"true|false\"\n    android:name=\".provider.TestContentProvider$Provider\"/>\n\t```\n3. 至少添加一个 `@TableEndpoint`:在`@Table`类中指定content provider的类名，代码如下，注意`@ContentUri `\n\n\t```java\n\t@TableEndpoint(name = ContentProviderModel.NAME, contentProviderName = \"ContentDatabase\")\n@Table(database = ContentDatabase.class, tableName = ContentProviderModel.NAME)\npublic class ContentProviderModel extends BaseProviderModel<ContentProviderModel> {\n\n    public static final String NAME = \"ContentProviderModel\";\n\n    @ContentUri(path = NAME, type = ContentUri.ContentType.VND_MULTIPLE + NAME)\n    public static final Uri CONTENT_URI = ContentUtils.buildUri(ContentDatabase.AUTHORITY);\n\n    @Column\n    @PrimaryKey(autoincrement = true)\n    long id;\n\n    @Column\n    String notes;\n\n    @Column\n    String title;\n\n    @Override\n    public Uri getDeleteUri() {\n        return TestContentProvider.ContentProviderModel.CONTENT_URI;\n    }\n\n    @Override\n    public Uri getInsertUri() {\n        return TestContentProvider.ContentProviderModel.CONTENT_URI;\n    }\n\n    @Override\n    public Uri getUpdateUri() {\n        return TestContentProvider.ContentProviderModel.CONTENT_URI;\n    }\n\n    @Override\n    public Uri getQueryUri() {\n        return TestContentProvider.ContentProviderModel.CONTENT_URI;\n    }\n}\n\t```\n4. (非必须，会使在Model上的操作使用ContentProvider）修改Table继承的类为下面的一种，如上的代码。**强烈推荐第二个`BaseSyncableProviderModel `****????疑问ContentProvider不写数据库吗**\n\t* BaseProviderModel：Model上的所有操作都是通过ContentProvider\n\t* BaseSyncableProviderModel：与上面相同，**除此之外，还会同步到本地的App数据库，即本地数据库会有相同数据**\n5. 使用，有两种方式\n\t* 通用方式如下：\n\t\n\t\t```java\n\tContentProviderModel contentProviderModel = ...; // some instance\nint count = ContentUtils.update(getContentResolver(), ContentProviderModel.CONTENT_URI, contentProviderModel);\nUri uri = ContentUtils.insert(getContentResolver(), ContentProviderModel.CONTENT_URI, contentProviderModel);\nint count = ContentUtils.delete(getContentResolver(), someContentUri, contentProviderModel);\n\t\t```\n\t* 如果使用了上面步骤4，还可以像下面这样:\n\t\n\t\t```java\n\t\tMyModel model = new MyModel();\nmodel.id = 5;\nmodel.load(); // queries the content provider\nmodel.someProp = \"Hello\"\nmodel.update(false); // runs an update on the CP\nmodel.insert(false); // inserts the data into the CP\n\t\t```\n\n\n#### DBFlow的特殊List\nDBFlow可以直接从数据库获取的数据用以下两种数据结构返回。具体使用查看[文档中代码](https://github.com/Raizlabs/DBFlow/blob/master/usage/TableList.md)\n\n* FlowCursorList：用在大量数据查询与Android中的`BaseAdapter`绑定，不需要一次性加载数据到List中，而是，只加载使用到的（用户看到的）数据。**十分有用！**\n* FlowQueryList：用在List中数据与数据库中的数据同步修改\n\n#### 事务\n[参考官方文档](https://github.com/Raizlabs/DBFlow/blob/master/usage/Transactions.md)\n\n#### 其他功能\n* ModelCache缓存：select操作可以先从内存缓存中读取，需要手动打开\n\t注意：\n\t* FlowCursorList与FlowQueryList使用独立的ModelCache缓存，并不与@Tabel/Model类的缓存通用\n* 支持索引：设置某些列使用索引，加快select速度\n* 触发器：在数据库的某些操作之前或之后自动触发执行的一些动作\n\n### 其他数据库操作常识\n* 不要在循环中操作数据库，而是使用事务\n","source":"_posts/Android构架系列之三-数据库ORM框架.md","raw":"title: Android构架系列之三--数据库ORM框架\ndate: 2016-04-10 21:09:42\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n\n## [数据库方案](https://www.zhihu.com/question/27977160)\n\n* 原生sqlite\n* orm框架\n* ContentProvider+LoaderManager\n* 结合使用\n\n最终选择了DBFlow框架，基于以下几点优势：\n\n* 速度快，没有反射，使用编译时生成相关类。\n* **支持Content Provider**，与schematic库相集成。\n* 流式的sql API，接口友好。\n* Google在Demo中使用，算是官方推荐的库。\n\n下面介绍一下ContentProvider和DBFlow框架\n\n## ContentProvider\n\n### 何时使用\nGoogle建议：http://developer.android.com/intl/zh-cn/guide/topics/providers/content-provider-creating.html\n\n\n### 使用ContentProvider\n* 一个app多个ContentProvider，一个ContentProvider，对应一个数据库，一个数据库中含有n个table（表）\n* 快速生成ContentProvider的工具-[schematic](https://github.com/SimonVT/schematic)，[demo](https://github.com/SimonVT/schematic/blob/master/schematic-samples%2Fsrc%2Fmain%2Fjava%2Fnet%2Fsimonvt%2Fschematic%2Fsample%2Fdatabase%2FNotesProvider.java)\n* 事务操作：创建一个 ContentProviderOperation 数组，然后将相应的操作添加到数组中，最后通过 ContentResolver.applyBatch 实现批量操作。\n\n### 注意点\n* 进程安全，但不是线程安全，query 等方法可以同时被多个线程调用，所以这些方法必须线程安全。也就是不能使用全局变量、静态变量。（如果非要使用，必须加锁）。但是，数据库dbhelp自身会对操作排队，所以不用担心数据库的线程安全。\n* 避免在 onCreate() 中执行长时间操作，只构建DbHelper。。不getdb，这很快。\n* 外部应用访问数据有多重方式，通过路径开发部分内容、临时权限，intent访问等\n\n\n## DBFlow功能介绍\n这个库的基本使用，先学习[官方文档](https://github.com/Raizlabs/DBFlow)，[中文](https://www.gitbook.com/book/3yumenokanata/dbflow-tutorials/details)，不再赘述。\n### 基本使用\n步骤：\n\n1. Application中初始化\n2. 建立DataBase。一般情况下，一个App只有一个DB，然后有多张表。\n3. 根据业务需求建立Table,必须实现Model接口（更多是继承BaseModel类）\n\n实际开发中，可能还需要建立表之间的关联（Relation），在建立Table时，通过`foreignKey`来实现（1对1，1对多，多对多-3.0以上）\n\n其他几个概念:\n\n* 类型转换器：`@Column`只支持基本数据类型/相关封装类/Date，使用自定义的转换器，可以支持自己实现的类。\n* _Table类：DBFlow会自动生成的类，里面的字段是查询条件常用的\n* _Adapter类:\n\n### 流式API\n使用DBFlow掌握了[流式的API](https://github.com/Raizlabs/DBFlow/blob/master/usage/SQLQuery.md)基本掌握了它的使用：\n下面两种使用方式功能相同：\n\n* `SQLite.select().from(someTable).where(conditions).query();`\n* `new Select().from(someTable).where(conditions).query();`\n\n\t其中\n\t* conditions为查询条件，一般为`someTable_Table.name.eq(\"muz\")`，从`_Table`类中找。\n\t* 同样适用于insert update delete。注意：**不用忘了最后都要调用**`query()`。\n\n### 面向对象API\n另外一种使用DBFlow的方式，没有上面那种方式灵活，但是更加友好。\n对于我们使用`@Table`注解的类，可以直接新建一个对象，如下：\n\n```java\nSomeTable oneRecord = new SomeTable();\noneRecord.id=1\noneRecord.load();\n```\n注意：局限性只能查找`@PrimaryKey `属性\n同样的，有update,insert等方法。\n\n### 一些使用要点\n\n* select中`query()`与`queryList()`：前者返回Cursor，后者直接返回对象List，**更安全**,不用close Cursor。\n* 同步与异步：**默认是同步查询**，需要异步加上`async()`和回调`query(listener)`\n* 如果需要多个查询条件，两种方式:\n\t1. 在where后添加and(xxx)或者or(xxx)--**更常用**\n\t2. 使用组合查询条件ConditionGroup\n\n\t```java\nSQLite.select()\n  .from(MyTable.class)\n  .where(MyTable_Table.someColumn.is(\"SomeValue\"))\n  .and(MyTable_Table.anotherColumn.is(\"ThisValue\"));\n// 或者\nSQLite.select()\n   .from(MyTable.class)\n   .where(ConditionGroup.clause()\n   .and(MyTable_Table.someColumn.is(\"SomeValue\")\n   .or(MyTable_Table.anotherColumn.is(\"ThisValue\"));\n```\n\n### 其他的高级功能（有用的）\n#### 数据迁移 - 数据库升级\nDBFlow支持使用`Migration `支持升级数据库`@Database`版本.\n\n* 继承`AlterTableMigration<SomeTable>`，修改SomeTable表操作\n\n\t```java\n@Migration(version = 2, database = AppDatabase.class)\npublic class Migration1 extends AlterTableMigration<TestModel> {\n  @Override\n  public void onPreMigrate() {\n    // 一些数据库操作，如修改表，需要测试！\n    addColumn(Long.class, \"timestamp\");\n  }\n}\n\n* 继承`UpdateTableMigration<SomeTable>`，修改SomeTable表中内容操作\n\n\t```java\n@Migration(version = 2, database = AppDatabase.class)\npublic class Migration1 extends UpdateTableMigration<TestModel> {\n\n    @Override\n    public void onPreMigrate() {\n      // UPDATE TestModel SET deviceType = \"phablet\" WHERE screenSize > 5.7 AND screenSize < 7;\n      set(TestModel_Table.deviceType.is(\"phablet\"))\n        .where(TestModel_Table.screenSize.greaterThan(5.7), TestModel_Table.screenSize.lessThan(7));\n    }\n    ```\n\n扩展功能：\n注意：如果**想要在第一次创建时对数据库进行初始化操作**，只需要使用**`version = 0`**\n\n#### 支持ContentProvider\n支持ContentProvider只有很少的修改。\n\n1. 将有@Database的类添加@ContentProvider\n\t\n\t```\n\t@ContentProvider(authority = TestDatabase.AUTHORITY,\n        database = TestDatabase.class,\n        baseContentUri = TestDatabase.BASE_CONTENT_URI)\n@Database(name = TestDatabase.NAME, version = TestDatabase.VERSION)\npublic class TestDatabase {\n\n    public static final String NAME = \"TestDatabase\";\n\n    public static final int VERSION = \"1\";\n\n    public static final String AUTHORITY = \"com.raizlabs.android.dbflow.test.provider\";\n\n    public static final String BASE_CONTENT_URI = \"content://\";\n}\n\t```\n2. 在Manifest添加provider，注意名称为`类名$Provider`。\n\n\t```xml\n\t<provider\n    android:authorities=\"com.raizlabs.android.dbflow.test.provider\"\n    android:exported=\"true|false\"\n    android:name=\".provider.TestContentProvider$Provider\"/>\n\t```\n3. 至少添加一个 `@TableEndpoint`:在`@Table`类中指定content provider的类名，代码如下，注意`@ContentUri `\n\n\t```java\n\t@TableEndpoint(name = ContentProviderModel.NAME, contentProviderName = \"ContentDatabase\")\n@Table(database = ContentDatabase.class, tableName = ContentProviderModel.NAME)\npublic class ContentProviderModel extends BaseProviderModel<ContentProviderModel> {\n\n    public static final String NAME = \"ContentProviderModel\";\n\n    @ContentUri(path = NAME, type = ContentUri.ContentType.VND_MULTIPLE + NAME)\n    public static final Uri CONTENT_URI = ContentUtils.buildUri(ContentDatabase.AUTHORITY);\n\n    @Column\n    @PrimaryKey(autoincrement = true)\n    long id;\n\n    @Column\n    String notes;\n\n    @Column\n    String title;\n\n    @Override\n    public Uri getDeleteUri() {\n        return TestContentProvider.ContentProviderModel.CONTENT_URI;\n    }\n\n    @Override\n    public Uri getInsertUri() {\n        return TestContentProvider.ContentProviderModel.CONTENT_URI;\n    }\n\n    @Override\n    public Uri getUpdateUri() {\n        return TestContentProvider.ContentProviderModel.CONTENT_URI;\n    }\n\n    @Override\n    public Uri getQueryUri() {\n        return TestContentProvider.ContentProviderModel.CONTENT_URI;\n    }\n}\n\t```\n4. (非必须，会使在Model上的操作使用ContentProvider）修改Table继承的类为下面的一种，如上的代码。**强烈推荐第二个`BaseSyncableProviderModel `****????疑问ContentProvider不写数据库吗**\n\t* BaseProviderModel：Model上的所有操作都是通过ContentProvider\n\t* BaseSyncableProviderModel：与上面相同，**除此之外，还会同步到本地的App数据库，即本地数据库会有相同数据**\n5. 使用，有两种方式\n\t* 通用方式如下：\n\t\n\t\t```java\n\tContentProviderModel contentProviderModel = ...; // some instance\nint count = ContentUtils.update(getContentResolver(), ContentProviderModel.CONTENT_URI, contentProviderModel);\nUri uri = ContentUtils.insert(getContentResolver(), ContentProviderModel.CONTENT_URI, contentProviderModel);\nint count = ContentUtils.delete(getContentResolver(), someContentUri, contentProviderModel);\n\t\t```\n\t* 如果使用了上面步骤4，还可以像下面这样:\n\t\n\t\t```java\n\t\tMyModel model = new MyModel();\nmodel.id = 5;\nmodel.load(); // queries the content provider\nmodel.someProp = \"Hello\"\nmodel.update(false); // runs an update on the CP\nmodel.insert(false); // inserts the data into the CP\n\t\t```\n\n\n#### DBFlow的特殊List\nDBFlow可以直接从数据库获取的数据用以下两种数据结构返回。具体使用查看[文档中代码](https://github.com/Raizlabs/DBFlow/blob/master/usage/TableList.md)\n\n* FlowCursorList：用在大量数据查询与Android中的`BaseAdapter`绑定，不需要一次性加载数据到List中，而是，只加载使用到的（用户看到的）数据。**十分有用！**\n* FlowQueryList：用在List中数据与数据库中的数据同步修改\n\n#### 事务\n[参考官方文档](https://github.com/Raizlabs/DBFlow/blob/master/usage/Transactions.md)\n\n#### 其他功能\n* ModelCache缓存：select操作可以先从内存缓存中读取，需要手动打开\n\t注意：\n\t* FlowCursorList与FlowQueryList使用独立的ModelCache缓存，并不与@Tabel/Model类的缓存通用\n* 支持索引：设置某些列使用索引，加快select速度\n* 触发器：在数据库的某些操作之前或之后自动触发执行的一些动作\n\n### 其他数据库操作常识\n* 不要在循环中操作数据库，而是使用事务\n","slug":"Android构架系列之三-数据库ORM框架","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbc20009nac9f0t0phay","content":"<h2 id=\"数据库方案\"><a href=\"#数据库方案\" class=\"headerlink\" title=\"数据库方案\"></a><a href=\"https://www.zhihu.com/question/27977160\" target=\"_blank\" rel=\"external\">数据库方案</a></h2><ul>\n<li>原生sqlite</li>\n<li>orm框架</li>\n<li>ContentProvider+LoaderManager</li>\n<li>结合使用</li>\n</ul>\n<p>最终选择了DBFlow框架，基于以下几点优势：</p>\n<ul>\n<li>速度快，没有反射，使用编译时生成相关类。</li>\n<li><strong>支持Content Provider</strong>，与schematic库相集成。</li>\n<li>流式的sql API，接口友好。</li>\n<li>Google在Demo中使用，算是官方推荐的库。</li>\n</ul>\n<p>下面介绍一下ContentProvider和DBFlow框架</p>\n<h2 id=\"ContentProvider\"><a href=\"#ContentProvider\" class=\"headerlink\" title=\"ContentProvider\"></a>ContentProvider</h2><h3 id=\"何时使用\"><a href=\"#何时使用\" class=\"headerlink\" title=\"何时使用\"></a>何时使用</h3><p>Google建议：<a href=\"http://developer.android.com/intl/zh-cn/guide/topics/providers/content-provider-creating.html\" target=\"_blank\" rel=\"external\">http://developer.android.com/intl/zh-cn/guide/topics/providers/content-provider-creating.html</a></p>\n<h3 id=\"使用ContentProvider\"><a href=\"#使用ContentProvider\" class=\"headerlink\" title=\"使用ContentProvider\"></a>使用ContentProvider</h3><ul>\n<li>一个app多个ContentProvider，一个ContentProvider，对应一个数据库，一个数据库中含有n个table（表）</li>\n<li>快速生成ContentProvider的工具-<a href=\"https://github.com/SimonVT/schematic\" target=\"_blank\" rel=\"external\">schematic</a>，<a href=\"https://github.com/SimonVT/schematic/blob/master/schematic-samples%2Fsrc%2Fmain%2Fjava%2Fnet%2Fsimonvt%2Fschematic%2Fsample%2Fdatabase%2FNotesProvider.java\" target=\"_blank\" rel=\"external\">demo</a></li>\n<li>事务操作：创建一个 ContentProviderOperation 数组，然后将相应的操作添加到数组中，最后通过 ContentResolver.applyBatch 实现批量操作。</li>\n</ul>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ul>\n<li>进程安全，但不是线程安全，query 等方法可以同时被多个线程调用，所以这些方法必须线程安全。也就是不能使用全局变量、静态变量。（如果非要使用，必须加锁）。但是，数据库dbhelp自身会对操作排队，所以不用担心数据库的线程安全。</li>\n<li>避免在 onCreate() 中执行长时间操作，只构建DbHelper。。不getdb，这很快。</li>\n<li>外部应用访问数据有多重方式，通过路径开发部分内容、临时权限，intent访问等</li>\n</ul>\n<h2 id=\"DBFlow功能介绍\"><a href=\"#DBFlow功能介绍\" class=\"headerlink\" title=\"DBFlow功能介绍\"></a>DBFlow功能介绍</h2><p>这个库的基本使用，先学习<a href=\"https://github.com/Raizlabs/DBFlow\" target=\"_blank\" rel=\"external\">官方文档</a>，<a href=\"https://www.gitbook.com/book/3yumenokanata/dbflow-tutorials/details\" target=\"_blank\" rel=\"external\">中文</a>，不再赘述。</p>\n<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><p>步骤：</p>\n<ol>\n<li>Application中初始化</li>\n<li>建立DataBase。一般情况下，一个App只有一个DB，然后有多张表。</li>\n<li>根据业务需求建立Table,必须实现Model接口（更多是继承BaseModel类）</li>\n</ol>\n<p>实际开发中，可能还需要建立表之间的关联（Relation），在建立Table时，通过<code>foreignKey</code>来实现（1对1，1对多，多对多-3.0以上）</p>\n<p>其他几个概念:</p>\n<ul>\n<li>类型转换器：<code>@Column</code>只支持基本数据类型/相关封装类/Date，使用自定义的转换器，可以支持自己实现的类。</li>\n<li>_Table类：DBFlow会自动生成的类，里面的字段是查询条件常用的</li>\n<li>_Adapter类:</li>\n</ul>\n<h3 id=\"流式API\"><a href=\"#流式API\" class=\"headerlink\" title=\"流式API\"></a>流式API</h3><p>使用DBFlow掌握了<a href=\"https://github.com/Raizlabs/DBFlow/blob/master/usage/SQLQuery.md\" target=\"_blank\" rel=\"external\">流式的API</a>基本掌握了它的使用：<br>下面两种使用方式功能相同：</p>\n<ul>\n<li><code>SQLite.select().from(someTable).where(conditions).query();</code></li>\n<li><p><code>new Select().from(someTable).where(conditions).query();</code></p>\n<p>  其中</p>\n<ul>\n<li>conditions为查询条件，一般为<code>someTable_Table.name.eq(&quot;muz&quot;)</code>，从<code>_Table</code>类中找。</li>\n<li>同样适用于insert update delete。注意：<strong>不用忘了最后都要调用</strong><code>query()</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"面向对象API\"><a href=\"#面向对象API\" class=\"headerlink\" title=\"面向对象API\"></a>面向对象API</h3><p>另外一种使用DBFlow的方式，没有上面那种方式灵活，但是更加友好。<br>对于我们使用<code>@Table</code>注解的类，可以直接新建一个对象，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SomeTable oneRecord = <span class=\"keyword\">new</span> SomeTable();</div><div class=\"line\">oneRecord.id=<span class=\"number\">1</span></div><div class=\"line\">oneRecord.load();</div></pre></td></tr></table></figure>\n<p>注意：局限性只能查找<code>@PrimaryKey</code>属性<br>同样的，有update,insert等方法。</p>\n<h3 id=\"一些使用要点\"><a href=\"#一些使用要点\" class=\"headerlink\" title=\"一些使用要点\"></a>一些使用要点</h3><ul>\n<li>select中<code>query()</code>与<code>queryList()</code>：前者返回Cursor，后者直接返回对象List，<strong>更安全</strong>,不用close Cursor。</li>\n<li>同步与异步：<strong>默认是同步查询</strong>，需要异步加上<code>async()</code>和回调<code>query(listener)</code></li>\n<li><p>如果需要多个查询条件，两种方式:</p>\n<ol>\n<li>在where后添加and(xxx)或者or(xxx)–<strong>更常用</strong></li>\n<li><p>使用组合查询条件ConditionGroup</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">SQLite.select()</div><div class=\"line\">  .from(MyTable.class)</div><div class=\"line\">  .where(MyTable_Table.someColumn.is(<span class=\"string\">\"SomeValue\"</span>))</div><div class=\"line\">  .and(MyTable_Table.anotherColumn.is(<span class=\"string\">\"ThisValue\"</span>));</div><div class=\"line\"><span class=\"comment\">// 或者</span></div><div class=\"line\">SQLite.select()</div><div class=\"line\">   .from(MyTable.class)</div><div class=\"line\">   .where(ConditionGroup.clause()</div><div class=\"line\">   .and(MyTable_Table.someColumn.is(<span class=\"string\">\"SomeValue\"</span>)</div><div class=\"line\">   .or(MyTable_Table.anotherColumn.is(<span class=\"string\">\"ThisValue\"</span>));</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"其他的高级功能（有用的）\"><a href=\"#其他的高级功能（有用的）\" class=\"headerlink\" title=\"其他的高级功能（有用的）\"></a>其他的高级功能（有用的）</h3><h4 id=\"数据迁移-数据库升级\"><a href=\"#数据迁移-数据库升级\" class=\"headerlink\" title=\"数据迁移 - 数据库升级\"></a>数据迁移 - 数据库升级</h4><p>DBFlow支持使用<code>Migration</code>支持升级数据库<code>@Database</code>版本.</p>\n<ul>\n<li><p>继承<code>AlterTableMigration&lt;SomeTable&gt;</code>，修改SomeTable表操作</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Migration</span>(version = <span class=\"number\">2</span>, database = AppDatabase.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Migration1</span> <span class=\"keyword\">extends</span> <span class=\"title\">AlterTableMigration</span>&lt;<span class=\"title\">TestModel</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPreMigrate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 一些数据库操作，如修改表，需要测试！</span></div><div class=\"line\">    addColumn(Long.class, <span class=\"string\">\"timestamp\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">* 继承`UpdateTableMigration&lt;SomeTable&gt;`，修改SomeTable表中内容操作</div><div class=\"line\"></div><div class=\"line\">\t```java</div><div class=\"line\"><span class=\"meta\">@Migration</span>(version = <span class=\"number\">2</span>, database = AppDatabase.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Migration1</span> <span class=\"keyword\">extends</span> <span class=\"title\">UpdateTableMigration</span>&lt;<span class=\"title\">TestModel</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPreMigrate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// UPDATE TestModel SET deviceType = \"phablet\" WHERE screenSize &gt; 5.7 AND screenSize &lt; 7;</span></div><div class=\"line\">      set(TestModel_Table.deviceType.is(<span class=\"string\">\"phablet\"</span>))</div><div class=\"line\">        .where(TestModel_Table.screenSize.greaterThan(<span class=\"number\">5.7</span>), TestModel_Table.screenSize.lessThan(<span class=\"number\">7</span>));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>扩展功能：<br>注意：如果<strong>想要在第一次创建时对数据库进行初始化操作</strong>，只需要使用<strong><code>version = 0</code></strong></p>\n<h4 id=\"支持ContentProvider\"><a href=\"#支持ContentProvider\" class=\"headerlink\" title=\"支持ContentProvider\"></a>支持ContentProvider</h4><p>支持ContentProvider只有很少的修改。</p>\n<ol>\n<li><p>将有@Database的类添加@ContentProvider</p>\n <figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"meta\">@ContentProvider</span>(authority = TestDatabase.AUTHORITY,</div><div class=\"line\">        database = TestDatabase.<span class=\"keyword\">class</span>,</div><div class=\"line\">        baseContentUri = TestDatabase.BASE_CONTENT_URI)</div><div class=\"line\"><span class=\"meta\">@Database</span>(name = TestDatabase.NAME, version = TestDatabase.VERSION)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDatabase</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"TestDatabase\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> VERSION = <span class=\"string\">\"1\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String AUTHORITY = <span class=\"string\">\"com.raizlabs.android.dbflow.test.provider\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BASE_CONTENT_URI = <span class=\"string\">\"content://\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在Manifest添加provider，注意名称为<code>类名$Provider</code>。</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">provider</span></span></div><div class=\"line\">   <span class=\"attr\">android:authorities</span>=<span class=\"string\">\"com.raizlabs.android.dbflow.test.provider\"</span></div><div class=\"line\">   <span class=\"attr\">android:exported</span>=<span class=\"string\">\"true|false\"</span></div><div class=\"line\">   <span class=\"attr\">android:name</span>=<span class=\"string\">\".provider.TestContentProvider$Provider\"</span>/&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>至少添加一个 <code>@TableEndpoint</code>:在<code>@Table</code>类中指定content provider的类名，代码如下，注意<code>@ContentUri</code></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"meta\">@TableEndpoint</span>(name = ContentProviderModel.NAME, contentProviderName = <span class=\"string\">\"ContentDatabase\"</span>)</div><div class=\"line\"><span class=\"meta\">@Table</span>(database = ContentDatabase.class, tableName = ContentProviderModel.NAME)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ContentProviderModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseProviderModel</span>&lt;<span class=\"title\">ContentProviderModel</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"ContentProviderModel\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@ContentUri</span>(path = NAME, type = ContentUri.ContentType.VND_MULTIPLE + NAME)</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri CONTENT_URI = ContentUtils.buildUri(ContentDatabase.AUTHORITY);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Column</span></div><div class=\"line\">    <span class=\"meta\">@PrimaryKey</span>(autoincrement = <span class=\"keyword\">true</span>)</div><div class=\"line\">    <span class=\"keyword\">long</span> id;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Column</span></div><div class=\"line\">    String notes;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Column</span></div><div class=\"line\">    String title;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">getDeleteUri</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> TestContentProvider.ContentProviderModel.CONTENT_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">getInsertUri</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> TestContentProvider.ContentProviderModel.CONTENT_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">getUpdateUri</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> TestContentProvider.ContentProviderModel.CONTENT_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">getQueryUri</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> TestContentProvider.ContentProviderModel.CONTENT_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>(非必须，会使在Model上的操作使用ContentProvider）修改Table继承的类为下面的一种，如上的代码。<strong>强烈推荐第二个<code>BaseSyncableProviderModel</code>**</strong>????疑问ContentProvider不写数据库吗**</p>\n<ul>\n<li>BaseProviderModel：Model上的所有操作都是通过ContentProvider</li>\n<li>BaseSyncableProviderModel：与上面相同，<strong>除此之外，还会同步到本地的App数据库，即本地数据库会有相同数据</strong></li>\n</ul>\n</li>\n<li><p>使用，有两种方式</p>\n<ul>\n<li><p>通用方式如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tContentProviderModel contentProviderModel = ...; <span class=\"comment\">// some instance</span></div><div class=\"line\"><span class=\"keyword\">int</span> count = ContentUtils.update(getContentResolver(), ContentProviderModel.CONTENT_URI, contentProviderModel);</div><div class=\"line\">Uri uri = ContentUtils.insert(getContentResolver(), ContentProviderModel.CONTENT_URI, contentProviderModel);</div><div class=\"line\"><span class=\"keyword\">int</span> count = ContentUtils.delete(getContentResolver(), someContentUri, contentProviderModel);</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果使用了上面步骤4，还可以像下面这样:</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\tMyModel model = <span class=\"keyword\">new</span> MyModel();</div><div class=\"line\">model.id = <span class=\"number\">5</span>;</div><div class=\"line\">model.load(); <span class=\"comment\">// queries the content provider</span></div><div class=\"line\">model.someProp = <span class=\"string\">\"Hello\"</span></div><div class=\"line\">model.update(<span class=\"keyword\">false</span>); <span class=\"comment\">// runs an update on the CP</span></div><div class=\"line\">model.insert(<span class=\"keyword\">false</span>); <span class=\"comment\">// inserts the data into the CP</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"DBFlow的特殊List\"><a href=\"#DBFlow的特殊List\" class=\"headerlink\" title=\"DBFlow的特殊List\"></a>DBFlow的特殊List</h4><p>DBFlow可以直接从数据库获取的数据用以下两种数据结构返回。具体使用查看<a href=\"https://github.com/Raizlabs/DBFlow/blob/master/usage/TableList.md\" target=\"_blank\" rel=\"external\">文档中代码</a></p>\n<ul>\n<li>FlowCursorList：用在大量数据查询与Android中的<code>BaseAdapter</code>绑定，不需要一次性加载数据到List中，而是，只加载使用到的（用户看到的）数据。<strong>十分有用！</strong></li>\n<li>FlowQueryList：用在List中数据与数据库中的数据同步修改</li>\n</ul>\n<h4 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h4><p><a href=\"https://github.com/Raizlabs/DBFlow/blob/master/usage/Transactions.md\" target=\"_blank\" rel=\"external\">参考官方文档</a></p>\n<h4 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h4><ul>\n<li>ModelCache缓存：select操作可以先从内存缓存中读取，需要手动打开<br>  注意：<ul>\n<li>FlowCursorList与FlowQueryList使用独立的ModelCache缓存，并不与@Tabel/Model类的缓存通用</li>\n</ul>\n</li>\n<li>支持索引：设置某些列使用索引，加快select速度</li>\n<li>触发器：在数据库的某些操作之前或之后自动触发执行的一些动作</li>\n</ul>\n<h3 id=\"其他数据库操作常识\"><a href=\"#其他数据库操作常识\" class=\"headerlink\" title=\"其他数据库操作常识\"></a>其他数据库操作常识</h3><ul>\n<li>不要在循环中操作数据库，而是使用事务</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"数据库方案\"><a href=\"#数据库方案\" class=\"headerlink\" title=\"数据库方案\"></a><a href=\"https://www.zhihu.com/question/27977160\">数据库方案</a></h2><ul>\n<li>原生sqlite</li>\n<li>orm框架</li>\n<li>ContentProvider+LoaderManager</li>\n<li>结合使用</li>\n</ul>\n<p>最终选择了DBFlow框架，基于以下几点优势：</p>\n<ul>\n<li>速度快，没有反射，使用编译时生成相关类。</li>\n<li><strong>支持Content Provider</strong>，与schematic库相集成。</li>\n<li>流式的sql API，接口友好。</li>\n<li>Google在Demo中使用，算是官方推荐的库。</li>\n</ul>\n<p>下面介绍一下ContentProvider和DBFlow框架</p>\n<h2 id=\"ContentProvider\"><a href=\"#ContentProvider\" class=\"headerlink\" title=\"ContentProvider\"></a>ContentProvider</h2><h3 id=\"何时使用\"><a href=\"#何时使用\" class=\"headerlink\" title=\"何时使用\"></a>何时使用</h3><p>Google建议：<a href=\"http://developer.android.com/intl/zh-cn/guide/topics/providers/content-provider-creating.html\">http://developer.android.com/intl/zh-cn/guide/topics/providers/content-provider-creating.html</a></p>\n<h3 id=\"使用ContentProvider\"><a href=\"#使用ContentProvider\" class=\"headerlink\" title=\"使用ContentProvider\"></a>使用ContentProvider</h3><ul>\n<li>一个app多个ContentProvider，一个ContentProvider，对应一个数据库，一个数据库中含有n个table（表）</li>\n<li>快速生成ContentProvider的工具-<a href=\"https://github.com/SimonVT/schematic\">schematic</a>，<a href=\"https://github.com/SimonVT/schematic/blob/master/schematic-samples%2Fsrc%2Fmain%2Fjava%2Fnet%2Fsimonvt%2Fschematic%2Fsample%2Fdatabase%2FNotesProvider.java\">demo</a></li>\n<li>事务操作：创建一个 ContentProviderOperation 数组，然后将相应的操作添加到数组中，最后通过 ContentResolver.applyBatch 实现批量操作。</li>\n</ul>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ul>\n<li>进程安全，但不是线程安全，query 等方法可以同时被多个线程调用，所以这些方法必须线程安全。也就是不能使用全局变量、静态变量。（如果非要使用，必须加锁）。但是，数据库dbhelp自身会对操作排队，所以不用担心数据库的线程安全。</li>\n<li>避免在 onCreate() 中执行长时间操作，只构建DbHelper。。不getdb，这很快。</li>\n<li>外部应用访问数据有多重方式，通过路径开发部分内容、临时权限，intent访问等</li>\n</ul>\n<h2 id=\"DBFlow功能介绍\"><a href=\"#DBFlow功能介绍\" class=\"headerlink\" title=\"DBFlow功能介绍\"></a>DBFlow功能介绍</h2><p>这个库的基本使用，先学习<a href=\"https://github.com/Raizlabs/DBFlow\">官方文档</a>，<a href=\"https://www.gitbook.com/book/3yumenokanata/dbflow-tutorials/details\">中文</a>，不再赘述。</p>\n<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><p>步骤：</p>\n<ol>\n<li>Application中初始化</li>\n<li>建立DataBase。一般情况下，一个App只有一个DB，然后有多张表。</li>\n<li>根据业务需求建立Table,必须实现Model接口（更多是继承BaseModel类）</li>\n</ol>\n<p>实际开发中，可能还需要建立表之间的关联（Relation），在建立Table时，通过<code>foreignKey</code>来实现（1对1，1对多，多对多-3.0以上）</p>\n<p>其他几个概念:</p>\n<ul>\n<li>类型转换器：<code>@Column</code>只支持基本数据类型/相关封装类/Date，使用自定义的转换器，可以支持自己实现的类。</li>\n<li>_Table类：DBFlow会自动生成的类，里面的字段是查询条件常用的</li>\n<li>_Adapter类:</li>\n</ul>\n<h3 id=\"流式API\"><a href=\"#流式API\" class=\"headerlink\" title=\"流式API\"></a>流式API</h3><p>使用DBFlow掌握了<a href=\"https://github.com/Raizlabs/DBFlow/blob/master/usage/SQLQuery.md\">流式的API</a>基本掌握了它的使用：<br>下面两种使用方式功能相同：</p>\n<ul>\n<li><code>SQLite.select().from(someTable).where(conditions).query();</code></li>\n<li><p><code>new Select().from(someTable).where(conditions).query();</code></p>\n<p>  其中</p>\n<ul>\n<li>conditions为查询条件，一般为<code>someTable_Table.name.eq(&quot;muz&quot;)</code>，从<code>_Table</code>类中找。</li>\n<li>同样适用于insert update delete。注意：<strong>不用忘了最后都要调用</strong><code>query()</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"面向对象API\"><a href=\"#面向对象API\" class=\"headerlink\" title=\"面向对象API\"></a>面向对象API</h3><p>另外一种使用DBFlow的方式，没有上面那种方式灵活，但是更加友好。<br>对于我们使用<code>@Table</code>注解的类，可以直接新建一个对象，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SomeTable oneRecord = <span class=\"keyword\">new</span> SomeTable();</div><div class=\"line\">oneRecord.id=<span class=\"number\">1</span></div><div class=\"line\">oneRecord.load();</div></pre></td></tr></table></figure>\n<p>注意：局限性只能查找<code>@PrimaryKey</code>属性<br>同样的，有update,insert等方法。</p>\n<h3 id=\"一些使用要点\"><a href=\"#一些使用要点\" class=\"headerlink\" title=\"一些使用要点\"></a>一些使用要点</h3><ul>\n<li>select中<code>query()</code>与<code>queryList()</code>：前者返回Cursor，后者直接返回对象List，<strong>更安全</strong>,不用close Cursor。</li>\n<li>同步与异步：<strong>默认是同步查询</strong>，需要异步加上<code>async()</code>和回调<code>query(listener)</code></li>\n<li><p>如果需要多个查询条件，两种方式:</p>\n<ol>\n<li>在where后添加and(xxx)或者or(xxx)–<strong>更常用</strong></li>\n<li><p>使用组合查询条件ConditionGroup</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">SQLite.select()</div><div class=\"line\">  .from(MyTable.class)</div><div class=\"line\">  .where(MyTable_Table.someColumn.is(<span class=\"string\">\"SomeValue\"</span>))</div><div class=\"line\">  .and(MyTable_Table.anotherColumn.is(<span class=\"string\">\"ThisValue\"</span>));</div><div class=\"line\"><span class=\"comment\">// 或者</span></div><div class=\"line\">SQLite.select()</div><div class=\"line\">   .from(MyTable.class)</div><div class=\"line\">   .where(ConditionGroup.clause()</div><div class=\"line\">   .and(MyTable_Table.someColumn.is(<span class=\"string\">\"SomeValue\"</span>)</div><div class=\"line\">   .or(MyTable_Table.anotherColumn.is(<span class=\"string\">\"ThisValue\"</span>));</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"其他的高级功能（有用的）\"><a href=\"#其他的高级功能（有用的）\" class=\"headerlink\" title=\"其他的高级功能（有用的）\"></a>其他的高级功能（有用的）</h3><h4 id=\"数据迁移-数据库升级\"><a href=\"#数据迁移-数据库升级\" class=\"headerlink\" title=\"数据迁移 - 数据库升级\"></a>数据迁移 - 数据库升级</h4><p>DBFlow支持使用<code>Migration</code>支持升级数据库<code>@Database</code>版本.</p>\n<ul>\n<li><p>继承<code>AlterTableMigration&lt;SomeTable&gt;</code>，修改SomeTable表操作</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Migration</span>(version = <span class=\"number\">2</span>, database = AppDatabase.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Migration1</span> <span class=\"keyword\">extends</span> <span class=\"title\">AlterTableMigration</span>&lt;<span class=\"title\">TestModel</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPreMigrate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 一些数据库操作，如修改表，需要测试！</span></div><div class=\"line\">    addColumn(Long.class, <span class=\"string\">\"timestamp\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">* 继承`UpdateTableMigration&lt;SomeTable&gt;`，修改SomeTable表中内容操作</div><div class=\"line\"></div><div class=\"line\">\t```java</div><div class=\"line\"><span class=\"meta\">@Migration</span>(version = <span class=\"number\">2</span>, database = AppDatabase.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Migration1</span> <span class=\"keyword\">extends</span> <span class=\"title\">UpdateTableMigration</span>&lt;<span class=\"title\">TestModel</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPreMigrate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// UPDATE TestModel SET deviceType = \"phablet\" WHERE screenSize &gt; 5.7 AND screenSize &lt; 7;</span></div><div class=\"line\">      set(TestModel_Table.deviceType.is(<span class=\"string\">\"phablet\"</span>))</div><div class=\"line\">        .where(TestModel_Table.screenSize.greaterThan(<span class=\"number\">5.7</span>), TestModel_Table.screenSize.lessThan(<span class=\"number\">7</span>));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>扩展功能：<br>注意：如果<strong>想要在第一次创建时对数据库进行初始化操作</strong>，只需要使用<strong><code>version = 0</code></strong></p>\n<h4 id=\"支持ContentProvider\"><a href=\"#支持ContentProvider\" class=\"headerlink\" title=\"支持ContentProvider\"></a>支持ContentProvider</h4><p>支持ContentProvider只有很少的修改。</p>\n<ol>\n<li><p>将有@Database的类添加@ContentProvider</p>\n <figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"meta\">@ContentProvider</span>(authority = TestDatabase.AUTHORITY,</div><div class=\"line\">        database = TestDatabase.<span class=\"keyword\">class</span>,</div><div class=\"line\">        baseContentUri = TestDatabase.BASE_CONTENT_URI)</div><div class=\"line\"><span class=\"meta\">@Database</span>(name = TestDatabase.NAME, version = TestDatabase.VERSION)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDatabase</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"TestDatabase\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> VERSION = <span class=\"string\">\"1\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String AUTHORITY = <span class=\"string\">\"com.raizlabs.android.dbflow.test.provider\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BASE_CONTENT_URI = <span class=\"string\">\"content://\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在Manifest添加provider，注意名称为<code>类名$Provider</code>。</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">provider</span></div><div class=\"line\">   <span class=\"attr\">android:authorities</span>=<span class=\"string\">\"com.raizlabs.android.dbflow.test.provider\"</span></div><div class=\"line\">   <span class=\"attr\">android:exported</span>=<span class=\"string\">\"true|false\"</span></div><div class=\"line\">   <span class=\"attr\">android:name</span>=<span class=\"string\">\".provider.TestContentProvider$Provider\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>至少添加一个 <code>@TableEndpoint</code>:在<code>@Table</code>类中指定content provider的类名，代码如下，注意<code>@ContentUri</code></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"meta\">@TableEndpoint</span>(name = ContentProviderModel.NAME, contentProviderName = <span class=\"string\">\"ContentDatabase\"</span>)</div><div class=\"line\"><span class=\"meta\">@Table</span>(database = ContentDatabase.class, tableName = ContentProviderModel.NAME)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ContentProviderModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseProviderModel</span>&lt;<span class=\"title\">ContentProviderModel</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"ContentProviderModel\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@ContentUri</span>(path = NAME, type = ContentUri.ContentType.VND_MULTIPLE + NAME)</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri CONTENT_URI = ContentUtils.buildUri(ContentDatabase.AUTHORITY);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Column</span></div><div class=\"line\">    <span class=\"meta\">@PrimaryKey</span>(autoincrement = <span class=\"keyword\">true</span>)</div><div class=\"line\">    <span class=\"keyword\">long</span> id;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Column</span></div><div class=\"line\">    String notes;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Column</span></div><div class=\"line\">    String title;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">getDeleteUri</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> TestContentProvider.ContentProviderModel.CONTENT_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">getInsertUri</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> TestContentProvider.ContentProviderModel.CONTENT_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">getUpdateUri</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> TestContentProvider.ContentProviderModel.CONTENT_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">getQueryUri</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> TestContentProvider.ContentProviderModel.CONTENT_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>(非必须，会使在Model上的操作使用ContentProvider）修改Table继承的类为下面的一种，如上的代码。<strong>强烈推荐第二个<code>BaseSyncableProviderModel</code>**</strong>????疑问ContentProvider不写数据库吗**</p>\n<ul>\n<li>BaseProviderModel：Model上的所有操作都是通过ContentProvider</li>\n<li>BaseSyncableProviderModel：与上面相同，<strong>除此之外，还会同步到本地的App数据库，即本地数据库会有相同数据</strong></li>\n</ul>\n</li>\n<li><p>使用，有两种方式</p>\n<ul>\n<li><p>通用方式如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tContentProviderModel contentProviderModel = ...; <span class=\"comment\">// some instance</span></div><div class=\"line\"><span class=\"keyword\">int</span> count = ContentUtils.update(getContentResolver(), ContentProviderModel.CONTENT_URI, contentProviderModel);</div><div class=\"line\">Uri uri = ContentUtils.insert(getContentResolver(), ContentProviderModel.CONTENT_URI, contentProviderModel);</div><div class=\"line\"><span class=\"keyword\">int</span> count = ContentUtils.delete(getContentResolver(), someContentUri, contentProviderModel);</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果使用了上面步骤4，还可以像下面这样:</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\tMyModel model = <span class=\"keyword\">new</span> MyModel();</div><div class=\"line\">model.id = <span class=\"number\">5</span>;</div><div class=\"line\">model.load(); <span class=\"comment\">// queries the content provider</span></div><div class=\"line\">model.someProp = <span class=\"string\">\"Hello\"</span></div><div class=\"line\">model.update(<span class=\"keyword\">false</span>); <span class=\"comment\">// runs an update on the CP</span></div><div class=\"line\">model.insert(<span class=\"keyword\">false</span>); <span class=\"comment\">// inserts the data into the CP</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"DBFlow的特殊List\"><a href=\"#DBFlow的特殊List\" class=\"headerlink\" title=\"DBFlow的特殊List\"></a>DBFlow的特殊List</h4><p>DBFlow可以直接从数据库获取的数据用以下两种数据结构返回。具体使用查看<a href=\"https://github.com/Raizlabs/DBFlow/blob/master/usage/TableList.md\">文档中代码</a></p>\n<ul>\n<li>FlowCursorList：用在大量数据查询与Android中的<code>BaseAdapter</code>绑定，不需要一次性加载数据到List中，而是，只加载使用到的（用户看到的）数据。<strong>十分有用！</strong></li>\n<li>FlowQueryList：用在List中数据与数据库中的数据同步修改</li>\n</ul>\n<h4 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h4><p><a href=\"https://github.com/Raizlabs/DBFlow/blob/master/usage/Transactions.md\">参考官方文档</a></p>\n<h4 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h4><ul>\n<li>ModelCache缓存：select操作可以先从内存缓存中读取，需要手动打开<br>  注意：<ul>\n<li>FlowCursorList与FlowQueryList使用独立的ModelCache缓存，并不与@Tabel/Model类的缓存通用</li>\n</ul>\n</li>\n<li>支持索引：设置某些列使用索引，加快select速度</li>\n<li>触发器：在数据库的某些操作之前或之后自动触发执行的一些动作</li>\n</ul>\n<h3 id=\"其他数据库操作常识\"><a href=\"#其他数据库操作常识\" class=\"headerlink\" title=\"其他数据库操作常识\"></a>其他数据库操作常识</h3><ul>\n<li>不要在循环中操作数据库，而是使用事务</li>\n</ul>\n"},{"title":"Android构架系列之二--MVP&&Clean理解与实践之MVP","date":"2016-05-02T12:43:26.000Z","_content":"\n一万个人心中有一万个MVP，对MVP的理解千差万别，似乎也没有一个最权威的Demo来说明什么是MVP，求其是Android平台上（如果有，请告知）。至今最权威的资料可以说是这些：\n\n* [MVP的原始资料](https://msdn.microsoft.com/en-us/library/ff649571.aspx)：微软在.NET中使用的技术，偏向于WEB技术，不一定完全适用于移动开发。\n* [android mvp](http://antonioleiva.com/mvp-android\n) ：github上star很多的关于Android中的MVP例子，入门教程。 \n* [一个mvp框架的实现](https://github.com/konmik/konmik.github.io/wiki/Introduction-to-Model-View-Presenter-on-Android)：一个被引用很多的mvp示例，讲解了MVP的好处，强调了数据恢复的问题。\n* Google的MVP的demo\n\n关于MVP的学习路径，我推荐按照上面的顺序。微软的MVP在.Net中的应用虽然不是Java语言讲解的，但是对MVP设计思想讲解十分清晰，为什么这样设计，有哪些设计的变形，设计带来的好处与劣势都写的十分清晰。后面的几篇文章更倾向于MVP思想在Android平台上的具体应用。另外一篇国内文章[Android MVP 详解（上）](http://www.jianshu.com/p/9a6845b26856)总结很全，可以参考。\n\n## 首先，MVP不是构架模式\n**MVP不是整个软件的构架模式（Architectural Pattern），而仅仅是表现层（Presentation）的构架模式。**叫他设计模式也不是很恰当。\n\n* MVP is a **user interface** architectural pattern.  -- [Wiki](https://en.wikipedia.org/wiki/Model–view–presenter)\n* First thing to clarify is that MVP is not an architectural pattern, it’s only responsible for the presentation layer . -- [mvp-android](http://antonioleiva.com/mvp-android)\n* MVP的命名中P即Presenter，往往翻译『主持者』，我觉得翻译成**『展示者』或者『表现者』**更恰当。\n\n\n## 什么是MVP\n这个问题建议通读微软关于MVP讲解的文章。学习前可以先参考阮一峰先生的[这篇文章](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)。\n之前我的理解：\n\n* M层，即`model`，这里的Model理解成业务层，不仅仅负责数据部分，如网络请求、数据库，获取数据，还有**业务逻辑**。由于轻客户端的设计趋势，Model应当很薄。\n* V层，即`view`，负责数据展示，Android的View或者Fragemnt\n* P层，即`presenter`,**是一切的主宰，是Master角色，它控制Model获取数据处理业务，再控制View的变化。**即它本身不含业务逻辑，会去**调用**业务逻辑(Model)。\n* **核心：M与V不直接交互数据，必须通过P**\n* 具体而言：V实现某个UIController接口，暴露自己实现的UI功能，如显示Progress等，P持有V的接口。V同时也会持有P，他们相互依赖（最好V/P都是通过接口依赖?）。\n\n现在理解，核心角度：**哪里需要重用，哪里需要测试！**。在MVP中，业务逻辑M，展示逻辑P需要测试，而View自身往往不是测试的主要目标，View更多的目标是可以重用。既开发中很多界面具有相似性。\n> 重用：一个View往往用在多个不同的模块中，比如ListView，自定义控件等。而Model与Presenter就不太会重用，开发新的模块往往是新写业务逻辑和展示逻辑，或者直接修改原来的业务逻辑达到目标。因而可测试对他们尤其重要！（使用Clean构架，业务逻辑也可以尽量重用）\n\n为什么这样设计：\n\n* 分离业务逻辑，代码清晰，分离的目的也是方便测试。\n* **测试需要**，这是强制的，MVP的核心思想，分离出业务逻辑方便测试，却是我一直忽略的，接口的设计往往是为测试服务的：\n\t* 测试的目标是：业务逻辑，既Presenter与Model，由于Model很薄，所以Presenter是测试的重点。\n\t* 所以**View层必须是接口设计**，目的是在测试P时，可以用mockView代替真实的View，实现测试与View无关。\n\t* Model中推荐使用Repository模式设计Model中的**数据获取部分**，可以使用Mock数据来测试，在Clean构架尤其明显。\n* **重用/复用需要**，这不是强制的，如果有需要，可以开发可复用的View，那么要求与View绑定的数据也是抽象的，如果View与Presenter绑定，Presenter也必须是抽象的。如果Presenter与Model绑定（可能是ViewModel，或者是在MVP的变种中）那么Model最好也是接口设计。可以参考[此文](https://drakeet.me/mvp-and-thinking-in-android)。\n\n\t> 一个常见的需求：相同的界面，加载不同的数据\n\n### 一些缺陷\n在微软的文档中也提到了MVP的一下缺点，我们可以参考：\n\n1. 最重要的一个问题，MVP是面向前端Web开发的，他们具有Model很薄的特点，即业务逻辑应当尽量都放到Server中，主要的场景都是request and response，且请求是没有状态的（即下一个请求如果需求之前的数据，需要重新请求这些数据）。所以，**在MVP的设计中通知机制被忽略了**，即model无法主动修改Presenter，或者说一个Presenter修改了Model，无法通知另外一个Presenter知晓！解决办法：使用Events机制实现通知，微软推荐的是[Observer设计模式](https://msdn.microsoft.com/en-us/library/ms978753.aspx)\n\n\t> **在移动开发中并不是这样的！**虽然使用场景不多但是还是需要的这种机制的。可以参考文章：[界面之下：还原真实的MV*模式](https://github.com/livoras/blog/issues/11)。\n\t> 参考MVC中的通知方法实现是在M与V之间使用Observer机制，但是MVP，M与V必须解耦（V不能引用M），可以在M与P之间实现Observer，或者M用Event来通知P。\n\n2. Presenter过于繁重，它需要操控很多元素。解决方案：通过设计可以避免，记住，Presenter只操控Model获取结果数据，Clean的设计体现了这一点。\n3. 在哪里创建组合Presenter与View呢？Google的Demo中推荐Activity，而Fragment作为View。其他方案中多在View中构造Presenter。\n\n我个人觉得的一些问题：\n\n* 待补充\n* 虽然理论上应当是薄Model的，但是实际中Model还是有相当部分的代码，P与M过于耦合，Model层如何测试，应当通过接口分离出Model，类似Clean\n\n\n### MVP的两种变体\n了解这两种遍体更能帮助我们清晰MVP中各个部分的职责与关系。**十分有利于实践中我们代码的设计！**本质上也是编程实现层面的问题。\n\n####  Supervising Presenter\n一些逻辑简单的UI操作操作可能不需要使用Presenter来完成，比如更新一个name，同时修改model中一个变量，之间没有复杂的展示逻辑（注意Presenter只管展示逻辑）。我们不需要Presenter参与。同时项目中也有一些的UI逻辑的操作，如显示name，同时刷新并展示用户相关信息，这就需要Presenter参与。\n因此，**为了避免在某些情况下Presenter的\"多余\"，该模式中添加了Model与View的直接通路**，类似于DataBinding。但是，注意对应的使用情景，见下图。\n![](images/arch_mvp_supervising_presenter.png)\n\n#### Passive View\n其实在MVP中View就是被动的了，Presenter是Master，这里的被动View是什么呢？因为，**MVP中的View还是被动的不够完全**。一个简单的程序逻辑如下：\n> View.init()-->Presenter.loadData-->操作View的showData(参数是List)\n\n但是在Passive View中逻辑如下：\n> View的构造函数中构造Presenter并把自己传入其中-->Presenter的构造函数中调用view.init()-->Presenter.loadData-->在presenter中循环调用view.addItem(参数是一个子view)添加数据。\n\n可以看到这里的View完全被动了，更宽泛的说，在普通的MVP中View自己还可以调用一些展示逻辑，如在OnClick中show个Toast，但是在Passive View模式中，View只要吧onclick的event告知Presenter，然后Presenter来根据事件弹出Toast。\n参考文章是[这篇](http://www.cnblogs.com/wucj/archive/2013/05/24/3098153.html)。\n\n### MVP与MVC\n这里的MVP与MVC都是指的是**客户端**的构架！\n> MVP/MVC都是对于有GUI界面而言的。web服务端的GUI界面在Browser中，对服务端而言只是一个接口/模板的存在，**他们所说的MVC**基本上就是客户端的MVP（更确切的说不应当叫MVC，应当叫**Model2构架**，[参考此文](http://blog.turn.tw/?p=1539)），因为它不符合MVC中关于**View必须直接订阅Model**的关系，而MVP/Model2中数据必须经过X中转。\n\n![](images/arch_MVP_and_MVC.jpg)\n一言以蔽之，MVP与MVC都是分层的方法，其中最大的不同就是数据流向。\n\n* MVP:V -> P -> M -> P -> V\n* MVC:1.V向M注册自己(注意：V不能直接修改M）  2.V -> C -> M 3.M通知V\n\n### 那MVVM呢\n[MVVP](https://msdn.microsoft.com/en-us/library/hh848246.aspx)中是讲MVP中的P换成了VM即ViewModel，特点是ViewModel与View会双向绑定，当View变换时，ViewModel会收到Notification，当ViewModel中值被修改时，View会自动显示这个变换（即ViewModel中的内容被映射到View中）\nViewModel即视图Model，职责是负责保存View的属性和状态和更新Model。\nMVVM可以看做MVP的一个实现？吧V与P部分的逻辑写入了框架中，减少了程序员的工作。\n\n## Android中的MVP\n### 为什么要用？\n* 可行性，Android本质上是薄Model的，View与Model直接可以是类似于Request/Reponse之间的关系，保持无状态。因此可以使用MVP。\n* 业务逻辑解耦，代码可读性需要，将业务逻辑放入Model，将视图逻辑放入P，是代码可读性的需要。\n* 测试需要，十分重要的一点，通过MVP各层的接口设计，可以实现测试Mock的使用，方便视图逻辑与业务逻辑的测试。\n\n### 额外的一个好处 -- 后台线程问题解决\n这一点值得单独拿出来说，在Android中有这么一类问题：在配置改变/Activity重启时Activity会重新构建（各种情况参考[一个mvp框架的实现](https://github.com/konmik/konmik.github.io/wiki/Introduction-to-Model-View-Presenter-on-Android)），如果后台线程持有Activity的引用会导致Activity泄露，最常见的代码是，`new Thread(runnable)  `中Runnable是非静态内部类，默认会隐式持有外部的Activity的引用（更不要说我们有时会显示的持有了），不知不觉中内存泄漏了。。\n\n当使用MVP模式开发时，线程操作应当在P中（或者P使用的M中），只要我们**在Activity的`onDestroy()`中，清空Presenter持有的View的引用即可。**或者，**Presenter干脆持有的是View的弱引用**，可以杜绝此类问题。\n\n### 要处理的一个问题 -- Presenter的保持\n同样，Activty的销毁与恢复，引来了另外一个问题，我有时需要：\n\n* 配置改变时，保持Presenter并重新与View绑定。\n* Activity销毁重建（如打开不保留回收）时，保持一些值到Bundle\n\n> 这不是必须的，在大多数情况下，在Activity重建时重新构造一个新的Presenter并重新绑定View，这并没有什么问题。\n\n我们不希望重新构建Presenter，而继续使用之前的，这样的好处是不需要重新启动线程，重头开始一些操作。一些思路如下：\n\n* 最简单：使用xxActivity的静态变量保持Presenter，Activity重建时判空，如果Presenter非空，重新绑定Activity即可。问题是：\n\t* 什么时候清空Presenter？不能在onDestroy中清空，容易泄露Presenter，正确方式参考nucleus框架。\n\t* 一个Activity类只能有一个Presenter（如果你要启动多个相同的Activity只能共享Presenter）\n* [nucleus框架](https://github.com/konmik/nucleus)：本质上和第一个相同，但是解决了上面的问题，他会在一个全局的静态池中保留所有的Presenter，配置改变时，Activity会维护自己持有的Presenter的ID（通过onSaveInstance，解决了上面第二个问题）但是不清空池子中的Presenter。而Activity销毁时会清空池中Presenter，重建时会使用保存的Bundle构建新的Presenter（通过onSaveInstance，Presenter也会有自己的Bundle）。\n\n\t> 注意:在改框架中是通过`Activity##isChangingConfigurations()`来判断是否是配置改变的情况。\n\n* 使用Activity的Fragment setRetainInstance(true)来在**配置改变时**保持Presenter，问题：必须是Fragment的成员变量，**在Activity重建时无法保持Presenter**，需要自己实现类似bundle的功能恢复Presneter。\n* 使用Android Loader机制：本质上setRetainInstance内部就是使用的此方法，使用自定义Loader保持Presenter可以应用在Activity，View任何场合。问题：与上面的类似，在Activity重建时无法保持Presenter。\n\n综上，大部分情况下，可能Presenter并不需要保持，我们无需使用任何手段，只需确保Presenter的逻辑正确。对于有需要的场合（如含有后台线程，频繁转动屏幕引起问题），**个人建议使用Fragment保持机制最为简单可行**（这也是Google Demo的作法）。\n\n### 争论：谁是P\n由于Android中Activity等控件特殊性（如具有生命周期），有很多的MVP实现使用Activity、Fragment、Adapter作为Presenter。Android中其他的View（ViewGroup）作为V，这样的好处是Presenter自带生命周期，使用是否方便。\n但是，个人认为这个方法有可借鉴之处，但是并不好理解，没有单独一个Presenter类更加直观，并不适合实际使用。同样我们参考Google demo中的实现，使用了另外一种方案：**建议使用单独的Presenter类，Fragment作为View，而Activity是构建和结合他们的地方**。（强调必须使用Fragment，即使只有一个页面）。这种方式是可选的，职责清晰，虽然所有的Activity必须有Fragment麻烦了一点，这个代价还是值得的。\n\n## 纯MVP实践--参考Google代码\n并不想贴自己的代码，毕竟没有Google的优雅，尤其是在细节地方，建议大家都参考[google的官方demo](https://github.com/googlesamples/android-architecture)的MVP分支。总结一下：\n\n* View -- Fragment、View 与 xxxContract.View接口\n* Presenter -- xxxPresenter与xxxContract.Presenter接口\n* Model -- xxxRepository，Model的内部实现以后再讲，也是接口分离各个数据来源。\n* Activity -- **组合器**,the overall controller that creates and connects views and presenters.\n* xxxContract -- **契约类**，每个业务都有，里面有View和Presenter一对接口，这种设计逻辑十分清晰，可以借鉴。\n\n## 遗留问题\nlistview Adapter的MVP设计 -- 在疑问解答中说明\nModel的内部实现与缓存设计 -- 单独文章\n\n## 补充\n* [界面之下：还原真实的MV*模式](https://github.com/livoras/blog/issues/11)：我见过的最清晰的描述MVX文章\n\n\t> * MVC中保持了依赖同一块Model的不同View显示数据的实时性和准确性\n\t> * 总结了各个模式的优缺点\n\n## 总结\n至此，MVP的问题基本说明白了，参考了原始资料，加入自己的理解。但是，还是建议以原始资料学习最佳，一万个人心中有一万个MVP，每个人的理解可能均不相同。\n","source":"_posts/Android构架系列之二-MVP&&Clean理解与实践之MVP.md","raw":"title: Android构架系列之二--MVP&&Clean理解与实践之MVP\ndate: 2016-05-02 20:43:26\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n\n一万个人心中有一万个MVP，对MVP的理解千差万别，似乎也没有一个最权威的Demo来说明什么是MVP，求其是Android平台上（如果有，请告知）。至今最权威的资料可以说是这些：\n\n* [MVP的原始资料](https://msdn.microsoft.com/en-us/library/ff649571.aspx)：微软在.NET中使用的技术，偏向于WEB技术，不一定完全适用于移动开发。\n* [android mvp](http://antonioleiva.com/mvp-android\n) ：github上star很多的关于Android中的MVP例子，入门教程。 \n* [一个mvp框架的实现](https://github.com/konmik/konmik.github.io/wiki/Introduction-to-Model-View-Presenter-on-Android)：一个被引用很多的mvp示例，讲解了MVP的好处，强调了数据恢复的问题。\n* Google的MVP的demo\n\n关于MVP的学习路径，我推荐按照上面的顺序。微软的MVP在.Net中的应用虽然不是Java语言讲解的，但是对MVP设计思想讲解十分清晰，为什么这样设计，有哪些设计的变形，设计带来的好处与劣势都写的十分清晰。后面的几篇文章更倾向于MVP思想在Android平台上的具体应用。另外一篇国内文章[Android MVP 详解（上）](http://www.jianshu.com/p/9a6845b26856)总结很全，可以参考。\n\n## 首先，MVP不是构架模式\n**MVP不是整个软件的构架模式（Architectural Pattern），而仅仅是表现层（Presentation）的构架模式。**叫他设计模式也不是很恰当。\n\n* MVP is a **user interface** architectural pattern.  -- [Wiki](https://en.wikipedia.org/wiki/Model–view–presenter)\n* First thing to clarify is that MVP is not an architectural pattern, it’s only responsible for the presentation layer . -- [mvp-android](http://antonioleiva.com/mvp-android)\n* MVP的命名中P即Presenter，往往翻译『主持者』，我觉得翻译成**『展示者』或者『表现者』**更恰当。\n\n\n## 什么是MVP\n这个问题建议通读微软关于MVP讲解的文章。学习前可以先参考阮一峰先生的[这篇文章](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)。\n之前我的理解：\n\n* M层，即`model`，这里的Model理解成业务层，不仅仅负责数据部分，如网络请求、数据库，获取数据，还有**业务逻辑**。由于轻客户端的设计趋势，Model应当很薄。\n* V层，即`view`，负责数据展示，Android的View或者Fragemnt\n* P层，即`presenter`,**是一切的主宰，是Master角色，它控制Model获取数据处理业务，再控制View的变化。**即它本身不含业务逻辑，会去**调用**业务逻辑(Model)。\n* **核心：M与V不直接交互数据，必须通过P**\n* 具体而言：V实现某个UIController接口，暴露自己实现的UI功能，如显示Progress等，P持有V的接口。V同时也会持有P，他们相互依赖（最好V/P都是通过接口依赖?）。\n\n现在理解，核心角度：**哪里需要重用，哪里需要测试！**。在MVP中，业务逻辑M，展示逻辑P需要测试，而View自身往往不是测试的主要目标，View更多的目标是可以重用。既开发中很多界面具有相似性。\n> 重用：一个View往往用在多个不同的模块中，比如ListView，自定义控件等。而Model与Presenter就不太会重用，开发新的模块往往是新写业务逻辑和展示逻辑，或者直接修改原来的业务逻辑达到目标。因而可测试对他们尤其重要！（使用Clean构架，业务逻辑也可以尽量重用）\n\n为什么这样设计：\n\n* 分离业务逻辑，代码清晰，分离的目的也是方便测试。\n* **测试需要**，这是强制的，MVP的核心思想，分离出业务逻辑方便测试，却是我一直忽略的，接口的设计往往是为测试服务的：\n\t* 测试的目标是：业务逻辑，既Presenter与Model，由于Model很薄，所以Presenter是测试的重点。\n\t* 所以**View层必须是接口设计**，目的是在测试P时，可以用mockView代替真实的View，实现测试与View无关。\n\t* Model中推荐使用Repository模式设计Model中的**数据获取部分**，可以使用Mock数据来测试，在Clean构架尤其明显。\n* **重用/复用需要**，这不是强制的，如果有需要，可以开发可复用的View，那么要求与View绑定的数据也是抽象的，如果View与Presenter绑定，Presenter也必须是抽象的。如果Presenter与Model绑定（可能是ViewModel，或者是在MVP的变种中）那么Model最好也是接口设计。可以参考[此文](https://drakeet.me/mvp-and-thinking-in-android)。\n\n\t> 一个常见的需求：相同的界面，加载不同的数据\n\n### 一些缺陷\n在微软的文档中也提到了MVP的一下缺点，我们可以参考：\n\n1. 最重要的一个问题，MVP是面向前端Web开发的，他们具有Model很薄的特点，即业务逻辑应当尽量都放到Server中，主要的场景都是request and response，且请求是没有状态的（即下一个请求如果需求之前的数据，需要重新请求这些数据）。所以，**在MVP的设计中通知机制被忽略了**，即model无法主动修改Presenter，或者说一个Presenter修改了Model，无法通知另外一个Presenter知晓！解决办法：使用Events机制实现通知，微软推荐的是[Observer设计模式](https://msdn.microsoft.com/en-us/library/ms978753.aspx)\n\n\t> **在移动开发中并不是这样的！**虽然使用场景不多但是还是需要的这种机制的。可以参考文章：[界面之下：还原真实的MV*模式](https://github.com/livoras/blog/issues/11)。\n\t> 参考MVC中的通知方法实现是在M与V之间使用Observer机制，但是MVP，M与V必须解耦（V不能引用M），可以在M与P之间实现Observer，或者M用Event来通知P。\n\n2. Presenter过于繁重，它需要操控很多元素。解决方案：通过设计可以避免，记住，Presenter只操控Model获取结果数据，Clean的设计体现了这一点。\n3. 在哪里创建组合Presenter与View呢？Google的Demo中推荐Activity，而Fragment作为View。其他方案中多在View中构造Presenter。\n\n我个人觉得的一些问题：\n\n* 待补充\n* 虽然理论上应当是薄Model的，但是实际中Model还是有相当部分的代码，P与M过于耦合，Model层如何测试，应当通过接口分离出Model，类似Clean\n\n\n### MVP的两种变体\n了解这两种遍体更能帮助我们清晰MVP中各个部分的职责与关系。**十分有利于实践中我们代码的设计！**本质上也是编程实现层面的问题。\n\n####  Supervising Presenter\n一些逻辑简单的UI操作操作可能不需要使用Presenter来完成，比如更新一个name，同时修改model中一个变量，之间没有复杂的展示逻辑（注意Presenter只管展示逻辑）。我们不需要Presenter参与。同时项目中也有一些的UI逻辑的操作，如显示name，同时刷新并展示用户相关信息，这就需要Presenter参与。\n因此，**为了避免在某些情况下Presenter的\"多余\"，该模式中添加了Model与View的直接通路**，类似于DataBinding。但是，注意对应的使用情景，见下图。\n![](images/arch_mvp_supervising_presenter.png)\n\n#### Passive View\n其实在MVP中View就是被动的了，Presenter是Master，这里的被动View是什么呢？因为，**MVP中的View还是被动的不够完全**。一个简单的程序逻辑如下：\n> View.init()-->Presenter.loadData-->操作View的showData(参数是List)\n\n但是在Passive View中逻辑如下：\n> View的构造函数中构造Presenter并把自己传入其中-->Presenter的构造函数中调用view.init()-->Presenter.loadData-->在presenter中循环调用view.addItem(参数是一个子view)添加数据。\n\n可以看到这里的View完全被动了，更宽泛的说，在普通的MVP中View自己还可以调用一些展示逻辑，如在OnClick中show个Toast，但是在Passive View模式中，View只要吧onclick的event告知Presenter，然后Presenter来根据事件弹出Toast。\n参考文章是[这篇](http://www.cnblogs.com/wucj/archive/2013/05/24/3098153.html)。\n\n### MVP与MVC\n这里的MVP与MVC都是指的是**客户端**的构架！\n> MVP/MVC都是对于有GUI界面而言的。web服务端的GUI界面在Browser中，对服务端而言只是一个接口/模板的存在，**他们所说的MVC**基本上就是客户端的MVP（更确切的说不应当叫MVC，应当叫**Model2构架**，[参考此文](http://blog.turn.tw/?p=1539)），因为它不符合MVC中关于**View必须直接订阅Model**的关系，而MVP/Model2中数据必须经过X中转。\n\n![](images/arch_MVP_and_MVC.jpg)\n一言以蔽之，MVP与MVC都是分层的方法，其中最大的不同就是数据流向。\n\n* MVP:V -> P -> M -> P -> V\n* MVC:1.V向M注册自己(注意：V不能直接修改M）  2.V -> C -> M 3.M通知V\n\n### 那MVVM呢\n[MVVP](https://msdn.microsoft.com/en-us/library/hh848246.aspx)中是讲MVP中的P换成了VM即ViewModel，特点是ViewModel与View会双向绑定，当View变换时，ViewModel会收到Notification，当ViewModel中值被修改时，View会自动显示这个变换（即ViewModel中的内容被映射到View中）\nViewModel即视图Model，职责是负责保存View的属性和状态和更新Model。\nMVVM可以看做MVP的一个实现？吧V与P部分的逻辑写入了框架中，减少了程序员的工作。\n\n## Android中的MVP\n### 为什么要用？\n* 可行性，Android本质上是薄Model的，View与Model直接可以是类似于Request/Reponse之间的关系，保持无状态。因此可以使用MVP。\n* 业务逻辑解耦，代码可读性需要，将业务逻辑放入Model，将视图逻辑放入P，是代码可读性的需要。\n* 测试需要，十分重要的一点，通过MVP各层的接口设计，可以实现测试Mock的使用，方便视图逻辑与业务逻辑的测试。\n\n### 额外的一个好处 -- 后台线程问题解决\n这一点值得单独拿出来说，在Android中有这么一类问题：在配置改变/Activity重启时Activity会重新构建（各种情况参考[一个mvp框架的实现](https://github.com/konmik/konmik.github.io/wiki/Introduction-to-Model-View-Presenter-on-Android)），如果后台线程持有Activity的引用会导致Activity泄露，最常见的代码是，`new Thread(runnable)  `中Runnable是非静态内部类，默认会隐式持有外部的Activity的引用（更不要说我们有时会显示的持有了），不知不觉中内存泄漏了。。\n\n当使用MVP模式开发时，线程操作应当在P中（或者P使用的M中），只要我们**在Activity的`onDestroy()`中，清空Presenter持有的View的引用即可。**或者，**Presenter干脆持有的是View的弱引用**，可以杜绝此类问题。\n\n### 要处理的一个问题 -- Presenter的保持\n同样，Activty的销毁与恢复，引来了另外一个问题，我有时需要：\n\n* 配置改变时，保持Presenter并重新与View绑定。\n* Activity销毁重建（如打开不保留回收）时，保持一些值到Bundle\n\n> 这不是必须的，在大多数情况下，在Activity重建时重新构造一个新的Presenter并重新绑定View，这并没有什么问题。\n\n我们不希望重新构建Presenter，而继续使用之前的，这样的好处是不需要重新启动线程，重头开始一些操作。一些思路如下：\n\n* 最简单：使用xxActivity的静态变量保持Presenter，Activity重建时判空，如果Presenter非空，重新绑定Activity即可。问题是：\n\t* 什么时候清空Presenter？不能在onDestroy中清空，容易泄露Presenter，正确方式参考nucleus框架。\n\t* 一个Activity类只能有一个Presenter（如果你要启动多个相同的Activity只能共享Presenter）\n* [nucleus框架](https://github.com/konmik/nucleus)：本质上和第一个相同，但是解决了上面的问题，他会在一个全局的静态池中保留所有的Presenter，配置改变时，Activity会维护自己持有的Presenter的ID（通过onSaveInstance，解决了上面第二个问题）但是不清空池子中的Presenter。而Activity销毁时会清空池中Presenter，重建时会使用保存的Bundle构建新的Presenter（通过onSaveInstance，Presenter也会有自己的Bundle）。\n\n\t> 注意:在改框架中是通过`Activity##isChangingConfigurations()`来判断是否是配置改变的情况。\n\n* 使用Activity的Fragment setRetainInstance(true)来在**配置改变时**保持Presenter，问题：必须是Fragment的成员变量，**在Activity重建时无法保持Presenter**，需要自己实现类似bundle的功能恢复Presneter。\n* 使用Android Loader机制：本质上setRetainInstance内部就是使用的此方法，使用自定义Loader保持Presenter可以应用在Activity，View任何场合。问题：与上面的类似，在Activity重建时无法保持Presenter。\n\n综上，大部分情况下，可能Presenter并不需要保持，我们无需使用任何手段，只需确保Presenter的逻辑正确。对于有需要的场合（如含有后台线程，频繁转动屏幕引起问题），**个人建议使用Fragment保持机制最为简单可行**（这也是Google Demo的作法）。\n\n### 争论：谁是P\n由于Android中Activity等控件特殊性（如具有生命周期），有很多的MVP实现使用Activity、Fragment、Adapter作为Presenter。Android中其他的View（ViewGroup）作为V，这样的好处是Presenter自带生命周期，使用是否方便。\n但是，个人认为这个方法有可借鉴之处，但是并不好理解，没有单独一个Presenter类更加直观，并不适合实际使用。同样我们参考Google demo中的实现，使用了另外一种方案：**建议使用单独的Presenter类，Fragment作为View，而Activity是构建和结合他们的地方**。（强调必须使用Fragment，即使只有一个页面）。这种方式是可选的，职责清晰，虽然所有的Activity必须有Fragment麻烦了一点，这个代价还是值得的。\n\n## 纯MVP实践--参考Google代码\n并不想贴自己的代码，毕竟没有Google的优雅，尤其是在细节地方，建议大家都参考[google的官方demo](https://github.com/googlesamples/android-architecture)的MVP分支。总结一下：\n\n* View -- Fragment、View 与 xxxContract.View接口\n* Presenter -- xxxPresenter与xxxContract.Presenter接口\n* Model -- xxxRepository，Model的内部实现以后再讲，也是接口分离各个数据来源。\n* Activity -- **组合器**,the overall controller that creates and connects views and presenters.\n* xxxContract -- **契约类**，每个业务都有，里面有View和Presenter一对接口，这种设计逻辑十分清晰，可以借鉴。\n\n## 遗留问题\nlistview Adapter的MVP设计 -- 在疑问解答中说明\nModel的内部实现与缓存设计 -- 单独文章\n\n## 补充\n* [界面之下：还原真实的MV*模式](https://github.com/livoras/blog/issues/11)：我见过的最清晰的描述MVX文章\n\n\t> * MVC中保持了依赖同一块Model的不同View显示数据的实时性和准确性\n\t> * 总结了各个模式的优缺点\n\n## 总结\n至此，MVP的问题基本说明白了，参考了原始资料，加入自己的理解。但是，还是建议以原始资料学习最佳，一万个人心中有一万个MVP，每个人的理解可能均不相同。\n","slug":"Android构架系列之二-MVP&&Clean理解与实践之MVP","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbc6000cnac9h3ypy1ed","content":"<p>一万个人心中有一万个MVP，对MVP的理解千差万别，似乎也没有一个最权威的Demo来说明什么是MVP，求其是Android平台上（如果有，请告知）。至今最权威的资料可以说是这些：</p>\n<ul>\n<li><a href=\"https://msdn.microsoft.com/en-us/library/ff649571.aspx\" target=\"_blank\" rel=\"external\">MVP的原始资料</a>：微软在.NET中使用的技术，偏向于WEB技术，不一定完全适用于移动开发。</li>\n<li><a href=\"http://antonioleiva.com/mvp-android\" target=\"_blank\" rel=\"external\">android mvp</a> ：github上star很多的关于Android中的MVP例子，入门教程。 </li>\n<li><a href=\"https://github.com/konmik/konmik.github.io/wiki/Introduction-to-Model-View-Presenter-on-Android\" target=\"_blank\" rel=\"external\">一个mvp框架的实现</a>：一个被引用很多的mvp示例，讲解了MVP的好处，强调了数据恢复的问题。</li>\n<li>Google的MVP的demo</li>\n</ul>\n<p>关于MVP的学习路径，我推荐按照上面的顺序。微软的MVP在.Net中的应用虽然不是Java语言讲解的，但是对MVP设计思想讲解十分清晰，为什么这样设计，有哪些设计的变形，设计带来的好处与劣势都写的十分清晰。后面的几篇文章更倾向于MVP思想在Android平台上的具体应用。另外一篇国内文章<a href=\"http://www.jianshu.com/p/9a6845b26856\" target=\"_blank\" rel=\"external\">Android MVP 详解（上）</a>总结很全，可以参考。</p>\n<h2 id=\"首先，MVP不是构架模式\"><a href=\"#首先，MVP不是构架模式\" class=\"headerlink\" title=\"首先，MVP不是构架模式\"></a>首先，MVP不是构架模式</h2><p><strong>MVP不是整个软件的构架模式（Architectural Pattern），而仅仅是表现层（Presentation）的构架模式。</strong>叫他设计模式也不是很恰当。</p>\n<ul>\n<li>MVP is a <strong>user interface</strong> architectural pattern.  – <a href=\"https://en.wikipedia.org/wiki/Model–view–presenter\" target=\"_blank\" rel=\"external\">Wiki</a></li>\n<li>First thing to clarify is that MVP is not an architectural pattern, it’s only responsible for the presentation layer . – <a href=\"http://antonioleiva.com/mvp-android\" target=\"_blank\" rel=\"external\">mvp-android</a></li>\n<li>MVP的命名中P即Presenter，往往翻译『主持者』，我觉得翻译成<strong>『展示者』或者『表现者』</strong>更恰当。</li>\n</ul>\n<h2 id=\"什么是MVP\"><a href=\"#什么是MVP\" class=\"headerlink\" title=\"什么是MVP\"></a>什么是MVP</h2><p>这个问题建议通读微软关于MVP讲解的文章。学习前可以先参考阮一峰先生的<a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\" target=\"_blank\" rel=\"external\">这篇文章</a>。<br>之前我的理解：</p>\n<ul>\n<li>M层，即<code>model</code>，这里的Model理解成业务层，不仅仅负责数据部分，如网络请求、数据库，获取数据，还有<strong>业务逻辑</strong>。由于轻客户端的设计趋势，Model应当很薄。</li>\n<li>V层，即<code>view</code>，负责数据展示，Android的View或者Fragemnt</li>\n<li>P层，即<code>presenter</code>,<strong>是一切的主宰，是Master角色，它控制Model获取数据处理业务，再控制View的变化。</strong>即它本身不含业务逻辑，会去<strong>调用</strong>业务逻辑(Model)。</li>\n<li><strong>核心：M与V不直接交互数据，必须通过P</strong></li>\n<li>具体而言：V实现某个UIController接口，暴露自己实现的UI功能，如显示Progress等，P持有V的接口。V同时也会持有P，他们相互依赖（最好V/P都是通过接口依赖?）。</li>\n</ul>\n<p>现在理解，核心角度：<strong>哪里需要重用，哪里需要测试！</strong>。在MVP中，业务逻辑M，展示逻辑P需要测试，而View自身往往不是测试的主要目标，View更多的目标是可以重用。既开发中很多界面具有相似性。</p>\n<blockquote>\n<p>重用：一个View往往用在多个不同的模块中，比如ListView，自定义控件等。而Model与Presenter就不太会重用，开发新的模块往往是新写业务逻辑和展示逻辑，或者直接修改原来的业务逻辑达到目标。因而可测试对他们尤其重要！（使用Clean构架，业务逻辑也可以尽量重用）</p>\n</blockquote>\n<p>为什么这样设计：</p>\n<ul>\n<li>分离业务逻辑，代码清晰，分离的目的也是方便测试。</li>\n<li><strong>测试需要</strong>，这是强制的，MVP的核心思想，分离出业务逻辑方便测试，却是我一直忽略的，接口的设计往往是为测试服务的：<ul>\n<li>测试的目标是：业务逻辑，既Presenter与Model，由于Model很薄，所以Presenter是测试的重点。</li>\n<li>所以<strong>View层必须是接口设计</strong>，目的是在测试P时，可以用mockView代替真实的View，实现测试与View无关。</li>\n<li>Model中推荐使用Repository模式设计Model中的<strong>数据获取部分</strong>，可以使用Mock数据来测试，在Clean构架尤其明显。</li>\n</ul>\n</li>\n<li><p><strong>重用/复用需要</strong>，这不是强制的，如果有需要，可以开发可复用的View，那么要求与View绑定的数据也是抽象的，如果View与Presenter绑定，Presenter也必须是抽象的。如果Presenter与Model绑定（可能是ViewModel，或者是在MVP的变种中）那么Model最好也是接口设计。可以参考<a href=\"https://drakeet.me/mvp-and-thinking-in-android\" target=\"_blank\" rel=\"external\">此文</a>。</p>\n<blockquote>\n<p>一个常见的需求：相同的界面，加载不同的数据</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"一些缺陷\"><a href=\"#一些缺陷\" class=\"headerlink\" title=\"一些缺陷\"></a>一些缺陷</h3><p>在微软的文档中也提到了MVP的一下缺点，我们可以参考：</p>\n<ol>\n<li><p>最重要的一个问题，MVP是面向前端Web开发的，他们具有Model很薄的特点，即业务逻辑应当尽量都放到Server中，主要的场景都是request and response，且请求是没有状态的（即下一个请求如果需求之前的数据，需要重新请求这些数据）。所以，<strong>在MVP的设计中通知机制被忽略了</strong>，即model无法主动修改Presenter，或者说一个Presenter修改了Model，无法通知另外一个Presenter知晓！解决办法：使用Events机制实现通知，微软推荐的是<a href=\"https://msdn.microsoft.com/en-us/library/ms978753.aspx\" target=\"_blank\" rel=\"external\">Observer设计模式</a></p>\n<blockquote>\n<p><strong>在移动开发中并不是这样的！</strong>虽然使用场景不多但是还是需要的这种机制的。可以参考文章：<a href=\"https://github.com/livoras/blog/issues/11\" target=\"_blank\" rel=\"external\">界面之下：还原真实的MV*模式</a>。<br>参考MVC中的通知方法实现是在M与V之间使用Observer机制，但是MVP，M与V必须解耦（V不能引用M），可以在M与P之间实现Observer，或者M用Event来通知P。</p>\n</blockquote>\n</li>\n<li><p>Presenter过于繁重，它需要操控很多元素。解决方案：通过设计可以避免，记住，Presenter只操控Model获取结果数据，Clean的设计体现了这一点。</p>\n</li>\n<li>在哪里创建组合Presenter与View呢？Google的Demo中推荐Activity，而Fragment作为View。其他方案中多在View中构造Presenter。</li>\n</ol>\n<p>我个人觉得的一些问题：</p>\n<ul>\n<li>待补充</li>\n<li>虽然理论上应当是薄Model的，但是实际中Model还是有相当部分的代码，P与M过于耦合，Model层如何测试，应当通过接口分离出Model，类似Clean</li>\n</ul>\n<h3 id=\"MVP的两种变体\"><a href=\"#MVP的两种变体\" class=\"headerlink\" title=\"MVP的两种变体\"></a>MVP的两种变体</h3><p>了解这两种遍体更能帮助我们清晰MVP中各个部分的职责与关系。<strong>十分有利于实践中我们代码的设计！</strong>本质上也是编程实现层面的问题。</p>\n<h4 id=\"Supervising-Presenter\"><a href=\"#Supervising-Presenter\" class=\"headerlink\" title=\"Supervising Presenter\"></a>Supervising Presenter</h4><p>一些逻辑简单的UI操作操作可能不需要使用Presenter来完成，比如更新一个name，同时修改model中一个变量，之间没有复杂的展示逻辑（注意Presenter只管展示逻辑）。我们不需要Presenter参与。同时项目中也有一些的UI逻辑的操作，如显示name，同时刷新并展示用户相关信息，这就需要Presenter参与。<br>因此，<strong>为了避免在某些情况下Presenter的”多余”，该模式中添加了Model与View的直接通路</strong>，类似于DataBinding。但是，注意对应的使用情景，见下图。<br><img src=\"images/arch_mvp_supervising_presenter.png\" alt=\"\"></p>\n<h4 id=\"Passive-View\"><a href=\"#Passive-View\" class=\"headerlink\" title=\"Passive View\"></a>Passive View</h4><p>其实在MVP中View就是被动的了，Presenter是Master，这里的被动View是什么呢？因为，<strong>MVP中的View还是被动的不够完全</strong>。一个简单的程序逻辑如下：</p>\n<blockquote>\n<p>View.init()–&gt;Presenter.loadData–&gt;操作View的showData(参数是List)</p>\n</blockquote>\n<p>但是在Passive View中逻辑如下：</p>\n<blockquote>\n<p>View的构造函数中构造Presenter并把自己传入其中–&gt;Presenter的构造函数中调用view.init()–&gt;Presenter.loadData–&gt;在presenter中循环调用view.addItem(参数是一个子view)添加数据。</p>\n</blockquote>\n<p>可以看到这里的View完全被动了，更宽泛的说，在普通的MVP中View自己还可以调用一些展示逻辑，如在OnClick中show个Toast，但是在Passive View模式中，View只要吧onclick的event告知Presenter，然后Presenter来根据事件弹出Toast。<br>参考文章是<a href=\"http://www.cnblogs.com/wucj/archive/2013/05/24/3098153.html\" target=\"_blank\" rel=\"external\">这篇</a>。</p>\n<h3 id=\"MVP与MVC\"><a href=\"#MVP与MVC\" class=\"headerlink\" title=\"MVP与MVC\"></a>MVP与MVC</h3><p>这里的MVP与MVC都是指的是<strong>客户端</strong>的构架！</p>\n<blockquote>\n<p>MVP/MVC都是对于有GUI界面而言的。web服务端的GUI界面在Browser中，对服务端而言只是一个接口/模板的存在，<strong>他们所说的MVC</strong>基本上就是客户端的MVP（更确切的说不应当叫MVC，应当叫<strong>Model2构架</strong>，<a href=\"http://blog.turn.tw/?p=1539\" target=\"_blank\" rel=\"external\">参考此文</a>），因为它不符合MVC中关于<strong>View必须直接订阅Model</strong>的关系，而MVP/Model2中数据必须经过X中转。</p>\n</blockquote>\n<p><img src=\"images/arch_MVP_and_MVC.jpg\" alt=\"\"><br>一言以蔽之，MVP与MVC都是分层的方法，其中最大的不同就是数据流向。</p>\n<ul>\n<li>MVP:V -&gt; P -&gt; M -&gt; P -&gt; V</li>\n<li>MVC:1.V向M注册自己(注意：V不能直接修改M）  2.V -&gt; C -&gt; M 3.M通知V</li>\n</ul>\n<h3 id=\"那MVVM呢\"><a href=\"#那MVVM呢\" class=\"headerlink\" title=\"那MVVM呢\"></a>那MVVM呢</h3><p><a href=\"https://msdn.microsoft.com/en-us/library/hh848246.aspx\" target=\"_blank\" rel=\"external\">MVVP</a>中是讲MVP中的P换成了VM即ViewModel，特点是ViewModel与View会双向绑定，当View变换时，ViewModel会收到Notification，当ViewModel中值被修改时，View会自动显示这个变换（即ViewModel中的内容被映射到View中）<br>ViewModel即视图Model，职责是负责保存View的属性和状态和更新Model。<br>MVVM可以看做MVP的一个实现？吧V与P部分的逻辑写入了框架中，减少了程序员的工作。</p>\n<h2 id=\"Android中的MVP\"><a href=\"#Android中的MVP\" class=\"headerlink\" title=\"Android中的MVP\"></a>Android中的MVP</h2><h3 id=\"为什么要用？\"><a href=\"#为什么要用？\" class=\"headerlink\" title=\"为什么要用？\"></a>为什么要用？</h3><ul>\n<li>可行性，Android本质上是薄Model的，View与Model直接可以是类似于Request/Reponse之间的关系，保持无状态。因此可以使用MVP。</li>\n<li>业务逻辑解耦，代码可读性需要，将业务逻辑放入Model，将视图逻辑放入P，是代码可读性的需要。</li>\n<li>测试需要，十分重要的一点，通过MVP各层的接口设计，可以实现测试Mock的使用，方便视图逻辑与业务逻辑的测试。</li>\n</ul>\n<h3 id=\"额外的一个好处-–-后台线程问题解决\"><a href=\"#额外的一个好处-–-后台线程问题解决\" class=\"headerlink\" title=\"额外的一个好处 – 后台线程问题解决\"></a>额外的一个好处 – 后台线程问题解决</h3><p>这一点值得单独拿出来说，在Android中有这么一类问题：在配置改变/Activity重启时Activity会重新构建（各种情况参考<a href=\"https://github.com/konmik/konmik.github.io/wiki/Introduction-to-Model-View-Presenter-on-Android\" target=\"_blank\" rel=\"external\">一个mvp框架的实现</a>），如果后台线程持有Activity的引用会导致Activity泄露，最常见的代码是，<code>new Thread(runnable)</code>中Runnable是非静态内部类，默认会隐式持有外部的Activity的引用（更不要说我们有时会显示的持有了），不知不觉中内存泄漏了。。</p>\n<p>当使用MVP模式开发时，线程操作应当在P中（或者P使用的M中），只要我们<strong>在Activity的<code>onDestroy()</code>中，清空Presenter持有的View的引用即可。</strong>或者，<strong>Presenter干脆持有的是View的弱引用</strong>，可以杜绝此类问题。</p>\n<h3 id=\"要处理的一个问题-–-Presenter的保持\"><a href=\"#要处理的一个问题-–-Presenter的保持\" class=\"headerlink\" title=\"要处理的一个问题 – Presenter的保持\"></a>要处理的一个问题 – Presenter的保持</h3><p>同样，Activty的销毁与恢复，引来了另外一个问题，我有时需要：</p>\n<ul>\n<li>配置改变时，保持Presenter并重新与View绑定。</li>\n<li>Activity销毁重建（如打开不保留回收）时，保持一些值到Bundle</li>\n</ul>\n<blockquote>\n<p>这不是必须的，在大多数情况下，在Activity重建时重新构造一个新的Presenter并重新绑定View，这并没有什么问题。</p>\n</blockquote>\n<p>我们不希望重新构建Presenter，而继续使用之前的，这样的好处是不需要重新启动线程，重头开始一些操作。一些思路如下：</p>\n<ul>\n<li>最简单：使用xxActivity的静态变量保持Presenter，Activity重建时判空，如果Presenter非空，重新绑定Activity即可。问题是：<ul>\n<li>什么时候清空Presenter？不能在onDestroy中清空，容易泄露Presenter，正确方式参考nucleus框架。</li>\n<li>一个Activity类只能有一个Presenter（如果你要启动多个相同的Activity只能共享Presenter）</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/konmik/nucleus\" target=\"_blank\" rel=\"external\">nucleus框架</a>：本质上和第一个相同，但是解决了上面的问题，他会在一个全局的静态池中保留所有的Presenter，配置改变时，Activity会维护自己持有的Presenter的ID（通过onSaveInstance，解决了上面第二个问题）但是不清空池子中的Presenter。而Activity销毁时会清空池中Presenter，重建时会使用保存的Bundle构建新的Presenter（通过onSaveInstance，Presenter也会有自己的Bundle）。</p>\n<blockquote>\n<p>注意:在改框架中是通过<code>Activity##isChangingConfigurations()</code>来判断是否是配置改变的情况。</p>\n</blockquote>\n</li>\n<li><p>使用Activity的Fragment setRetainInstance(true)来在<strong>配置改变时</strong>保持Presenter，问题：必须是Fragment的成员变量，<strong>在Activity重建时无法保持Presenter</strong>，需要自己实现类似bundle的功能恢复Presneter。</p>\n</li>\n<li>使用Android Loader机制：本质上setRetainInstance内部就是使用的此方法，使用自定义Loader保持Presenter可以应用在Activity，View任何场合。问题：与上面的类似，在Activity重建时无法保持Presenter。</li>\n</ul>\n<p>综上，大部分情况下，可能Presenter并不需要保持，我们无需使用任何手段，只需确保Presenter的逻辑正确。对于有需要的场合（如含有后台线程，频繁转动屏幕引起问题），<strong>个人建议使用Fragment保持机制最为简单可行</strong>（这也是Google Demo的作法）。</p>\n<h3 id=\"争论：谁是P\"><a href=\"#争论：谁是P\" class=\"headerlink\" title=\"争论：谁是P\"></a>争论：谁是P</h3><p>由于Android中Activity等控件特殊性（如具有生命周期），有很多的MVP实现使用Activity、Fragment、Adapter作为Presenter。Android中其他的View（ViewGroup）作为V，这样的好处是Presenter自带生命周期，使用是否方便。<br>但是，个人认为这个方法有可借鉴之处，但是并不好理解，没有单独一个Presenter类更加直观，并不适合实际使用。同样我们参考Google demo中的实现，使用了另外一种方案：<strong>建议使用单独的Presenter类，Fragment作为View，而Activity是构建和结合他们的地方</strong>。（强调必须使用Fragment，即使只有一个页面）。这种方式是可选的，职责清晰，虽然所有的Activity必须有Fragment麻烦了一点，这个代价还是值得的。</p>\n<h2 id=\"纯MVP实践–参考Google代码\"><a href=\"#纯MVP实践–参考Google代码\" class=\"headerlink\" title=\"纯MVP实践–参考Google代码\"></a>纯MVP实践–参考Google代码</h2><p>并不想贴自己的代码，毕竟没有Google的优雅，尤其是在细节地方，建议大家都参考<a href=\"https://github.com/googlesamples/android-architecture\" target=\"_blank\" rel=\"external\">google的官方demo</a>的MVP分支。总结一下：</p>\n<ul>\n<li>View – Fragment、View 与 xxxContract.View接口</li>\n<li>Presenter – xxxPresenter与xxxContract.Presenter接口</li>\n<li>Model – xxxRepository，Model的内部实现以后再讲，也是接口分离各个数据来源。</li>\n<li>Activity – <strong>组合器</strong>,the overall controller that creates and connects views and presenters.</li>\n<li>xxxContract – <strong>契约类</strong>，每个业务都有，里面有View和Presenter一对接口，这种设计逻辑十分清晰，可以借鉴。</li>\n</ul>\n<h2 id=\"遗留问题\"><a href=\"#遗留问题\" class=\"headerlink\" title=\"遗留问题\"></a>遗留问题</h2><p>listview Adapter的MVP设计 – 在疑问解答中说明<br>Model的内部实现与缓存设计 – 单独文章</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><ul>\n<li><p><a href=\"https://github.com/livoras/blog/issues/11\" target=\"_blank\" rel=\"external\">界面之下：还原真实的MV*模式</a>：我见过的最清晰的描述MVX文章</p>\n<blockquote>\n<ul>\n<li>MVC中保持了依赖同一块Model的不同View显示数据的实时性和准确性</li>\n<li>总结了各个模式的优缺点</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，MVP的问题基本说明白了，参考了原始资料，加入自己的理解。但是，还是建议以原始资料学习最佳，一万个人心中有一万个MVP，每个人的理解可能均不相同。</p>\n","excerpt":"","more":"<p>一万个人心中有一万个MVP，对MVP的理解千差万别，似乎也没有一个最权威的Demo来说明什么是MVP，求其是Android平台上（如果有，请告知）。至今最权威的资料可以说是这些：</p>\n<ul>\n<li><a href=\"https://msdn.microsoft.com/en-us/library/ff649571.aspx\">MVP的原始资料</a>：微软在.NET中使用的技术，偏向于WEB技术，不一定完全适用于移动开发。</li>\n<li><a href=\"http://antonioleiva.com/mvp-android\">android mvp</a> ：github上star很多的关于Android中的MVP例子，入门教程。 </li>\n<li><a href=\"https://github.com/konmik/konmik.github.io/wiki/Introduction-to-Model-View-Presenter-on-Android\">一个mvp框架的实现</a>：一个被引用很多的mvp示例，讲解了MVP的好处，强调了数据恢复的问题。</li>\n<li>Google的MVP的demo</li>\n</ul>\n<p>关于MVP的学习路径，我推荐按照上面的顺序。微软的MVP在.Net中的应用虽然不是Java语言讲解的，但是对MVP设计思想讲解十分清晰，为什么这样设计，有哪些设计的变形，设计带来的好处与劣势都写的十分清晰。后面的几篇文章更倾向于MVP思想在Android平台上的具体应用。另外一篇国内文章<a href=\"http://www.jianshu.com/p/9a6845b26856\">Android MVP 详解（上）</a>总结很全，可以参考。</p>\n<h2 id=\"首先，MVP不是构架模式\"><a href=\"#首先，MVP不是构架模式\" class=\"headerlink\" title=\"首先，MVP不是构架模式\"></a>首先，MVP不是构架模式</h2><p><strong>MVP不是整个软件的构架模式（Architectural Pattern），而仅仅是表现层（Presentation）的构架模式。</strong>叫他设计模式也不是很恰当。</p>\n<ul>\n<li>MVP is a <strong>user interface</strong> architectural pattern.  – <a href=\"https://en.wikipedia.org/wiki/Model–view–presenter\">Wiki</a></li>\n<li>First thing to clarify is that MVP is not an architectural pattern, it’s only responsible for the presentation layer . – <a href=\"http://antonioleiva.com/mvp-android\">mvp-android</a></li>\n<li>MVP的命名中P即Presenter，往往翻译『主持者』，我觉得翻译成<strong>『展示者』或者『表现者』</strong>更恰当。</li>\n</ul>\n<h2 id=\"什么是MVP\"><a href=\"#什么是MVP\" class=\"headerlink\" title=\"什么是MVP\"></a>什么是MVP</h2><p>这个问题建议通读微软关于MVP讲解的文章。学习前可以先参考阮一峰先生的<a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\">这篇文章</a>。<br>之前我的理解：</p>\n<ul>\n<li>M层，即<code>model</code>，这里的Model理解成业务层，不仅仅负责数据部分，如网络请求、数据库，获取数据，还有<strong>业务逻辑</strong>。由于轻客户端的设计趋势，Model应当很薄。</li>\n<li>V层，即<code>view</code>，负责数据展示，Android的View或者Fragemnt</li>\n<li>P层，即<code>presenter</code>,<strong>是一切的主宰，是Master角色，它控制Model获取数据处理业务，再控制View的变化。</strong>即它本身不含业务逻辑，会去<strong>调用</strong>业务逻辑(Model)。</li>\n<li><strong>核心：M与V不直接交互数据，必须通过P</strong></li>\n<li>具体而言：V实现某个UIController接口，暴露自己实现的UI功能，如显示Progress等，P持有V的接口。V同时也会持有P，他们相互依赖（最好V/P都是通过接口依赖?）。</li>\n</ul>\n<p>现在理解，核心角度：<strong>哪里需要重用，哪里需要测试！</strong>。在MVP中，业务逻辑M，展示逻辑P需要测试，而View自身往往不是测试的主要目标，View更多的目标是可以重用。既开发中很多界面具有相似性。</p>\n<blockquote>\n<p>重用：一个View往往用在多个不同的模块中，比如ListView，自定义控件等。而Model与Presenter就不太会重用，开发新的模块往往是新写业务逻辑和展示逻辑，或者直接修改原来的业务逻辑达到目标。因而可测试对他们尤其重要！（使用Clean构架，业务逻辑也可以尽量重用）</p>\n</blockquote>\n<p>为什么这样设计：</p>\n<ul>\n<li>分离业务逻辑，代码清晰，分离的目的也是方便测试。</li>\n<li><strong>测试需要</strong>，这是强制的，MVP的核心思想，分离出业务逻辑方便测试，却是我一直忽略的，接口的设计往往是为测试服务的：<ul>\n<li>测试的目标是：业务逻辑，既Presenter与Model，由于Model很薄，所以Presenter是测试的重点。</li>\n<li>所以<strong>View层必须是接口设计</strong>，目的是在测试P时，可以用mockView代替真实的View，实现测试与View无关。</li>\n<li>Model中推荐使用Repository模式设计Model中的<strong>数据获取部分</strong>，可以使用Mock数据来测试，在Clean构架尤其明显。</li>\n</ul>\n</li>\n<li><p><strong>重用/复用需要</strong>，这不是强制的，如果有需要，可以开发可复用的View，那么要求与View绑定的数据也是抽象的，如果View与Presenter绑定，Presenter也必须是抽象的。如果Presenter与Model绑定（可能是ViewModel，或者是在MVP的变种中）那么Model最好也是接口设计。可以参考<a href=\"https://drakeet.me/mvp-and-thinking-in-android\">此文</a>。</p>\n<blockquote>\n<p>一个常见的需求：相同的界面，加载不同的数据</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"一些缺陷\"><a href=\"#一些缺陷\" class=\"headerlink\" title=\"一些缺陷\"></a>一些缺陷</h3><p>在微软的文档中也提到了MVP的一下缺点，我们可以参考：</p>\n<ol>\n<li><p>最重要的一个问题，MVP是面向前端Web开发的，他们具有Model很薄的特点，即业务逻辑应当尽量都放到Server中，主要的场景都是request and response，且请求是没有状态的（即下一个请求如果需求之前的数据，需要重新请求这些数据）。所以，<strong>在MVP的设计中通知机制被忽略了</strong>，即model无法主动修改Presenter，或者说一个Presenter修改了Model，无法通知另外一个Presenter知晓！解决办法：使用Events机制实现通知，微软推荐的是<a href=\"https://msdn.microsoft.com/en-us/library/ms978753.aspx\">Observer设计模式</a></p>\n<blockquote>\n<p><strong>在移动开发中并不是这样的！</strong>虽然使用场景不多但是还是需要的这种机制的。可以参考文章：<a href=\"https://github.com/livoras/blog/issues/11\">界面之下：还原真实的MV*模式</a>。<br>参考MVC中的通知方法实现是在M与V之间使用Observer机制，但是MVP，M与V必须解耦（V不能引用M），可以在M与P之间实现Observer，或者M用Event来通知P。</p>\n</blockquote>\n</li>\n<li><p>Presenter过于繁重，它需要操控很多元素。解决方案：通过设计可以避免，记住，Presenter只操控Model获取结果数据，Clean的设计体现了这一点。</p>\n</li>\n<li>在哪里创建组合Presenter与View呢？Google的Demo中推荐Activity，而Fragment作为View。其他方案中多在View中构造Presenter。</li>\n</ol>\n<p>我个人觉得的一些问题：</p>\n<ul>\n<li>待补充</li>\n<li>虽然理论上应当是薄Model的，但是实际中Model还是有相当部分的代码，P与M过于耦合，Model层如何测试，应当通过接口分离出Model，类似Clean</li>\n</ul>\n<h3 id=\"MVP的两种变体\"><a href=\"#MVP的两种变体\" class=\"headerlink\" title=\"MVP的两种变体\"></a>MVP的两种变体</h3><p>了解这两种遍体更能帮助我们清晰MVP中各个部分的职责与关系。<strong>十分有利于实践中我们代码的设计！</strong>本质上也是编程实现层面的问题。</p>\n<h4 id=\"Supervising-Presenter\"><a href=\"#Supervising-Presenter\" class=\"headerlink\" title=\"Supervising Presenter\"></a>Supervising Presenter</h4><p>一些逻辑简单的UI操作操作可能不需要使用Presenter来完成，比如更新一个name，同时修改model中一个变量，之间没有复杂的展示逻辑（注意Presenter只管展示逻辑）。我们不需要Presenter参与。同时项目中也有一些的UI逻辑的操作，如显示name，同时刷新并展示用户相关信息，这就需要Presenter参与。<br>因此，<strong>为了避免在某些情况下Presenter的”多余”，该模式中添加了Model与View的直接通路</strong>，类似于DataBinding。但是，注意对应的使用情景，见下图。<br><img src=\"images/arch_mvp_supervising_presenter.png\" alt=\"\"></p>\n<h4 id=\"Passive-View\"><a href=\"#Passive-View\" class=\"headerlink\" title=\"Passive View\"></a>Passive View</h4><p>其实在MVP中View就是被动的了，Presenter是Master，这里的被动View是什么呢？因为，<strong>MVP中的View还是被动的不够完全</strong>。一个简单的程序逻辑如下：</p>\n<blockquote>\n<p>View.init()–&gt;Presenter.loadData–&gt;操作View的showData(参数是List)</p>\n</blockquote>\n<p>但是在Passive View中逻辑如下：</p>\n<blockquote>\n<p>View的构造函数中构造Presenter并把自己传入其中–&gt;Presenter的构造函数中调用view.init()–&gt;Presenter.loadData–&gt;在presenter中循环调用view.addItem(参数是一个子view)添加数据。</p>\n</blockquote>\n<p>可以看到这里的View完全被动了，更宽泛的说，在普通的MVP中View自己还可以调用一些展示逻辑，如在OnClick中show个Toast，但是在Passive View模式中，View只要吧onclick的event告知Presenter，然后Presenter来根据事件弹出Toast。<br>参考文章是<a href=\"http://www.cnblogs.com/wucj/archive/2013/05/24/3098153.html\">这篇</a>。</p>\n<h3 id=\"MVP与MVC\"><a href=\"#MVP与MVC\" class=\"headerlink\" title=\"MVP与MVC\"></a>MVP与MVC</h3><p>这里的MVP与MVC都是指的是<strong>客户端</strong>的构架！</p>\n<blockquote>\n<p>MVP/MVC都是对于有GUI界面而言的。web服务端的GUI界面在Browser中，对服务端而言只是一个接口/模板的存在，<strong>他们所说的MVC</strong>基本上就是客户端的MVP（更确切的说不应当叫MVC，应当叫<strong>Model2构架</strong>，<a href=\"http://blog.turn.tw/?p=1539\">参考此文</a>），因为它不符合MVC中关于<strong>View必须直接订阅Model</strong>的关系，而MVP/Model2中数据必须经过X中转。</p>\n</blockquote>\n<p><img src=\"images/arch_MVP_and_MVC.jpg\" alt=\"\"><br>一言以蔽之，MVP与MVC都是分层的方法，其中最大的不同就是数据流向。</p>\n<ul>\n<li>MVP:V -&gt; P -&gt; M -&gt; P -&gt; V</li>\n<li>MVC:1.V向M注册自己(注意：V不能直接修改M）  2.V -&gt; C -&gt; M 3.M通知V</li>\n</ul>\n<h3 id=\"那MVVM呢\"><a href=\"#那MVVM呢\" class=\"headerlink\" title=\"那MVVM呢\"></a>那MVVM呢</h3><p><a href=\"https://msdn.microsoft.com/en-us/library/hh848246.aspx\">MVVP</a>中是讲MVP中的P换成了VM即ViewModel，特点是ViewModel与View会双向绑定，当View变换时，ViewModel会收到Notification，当ViewModel中值被修改时，View会自动显示这个变换（即ViewModel中的内容被映射到View中）<br>ViewModel即视图Model，职责是负责保存View的属性和状态和更新Model。<br>MVVM可以看做MVP的一个实现？吧V与P部分的逻辑写入了框架中，减少了程序员的工作。</p>\n<h2 id=\"Android中的MVP\"><a href=\"#Android中的MVP\" class=\"headerlink\" title=\"Android中的MVP\"></a>Android中的MVP</h2><h3 id=\"为什么要用？\"><a href=\"#为什么要用？\" class=\"headerlink\" title=\"为什么要用？\"></a>为什么要用？</h3><ul>\n<li>可行性，Android本质上是薄Model的，View与Model直接可以是类似于Request/Reponse之间的关系，保持无状态。因此可以使用MVP。</li>\n<li>业务逻辑解耦，代码可读性需要，将业务逻辑放入Model，将视图逻辑放入P，是代码可读性的需要。</li>\n<li>测试需要，十分重要的一点，通过MVP各层的接口设计，可以实现测试Mock的使用，方便视图逻辑与业务逻辑的测试。</li>\n</ul>\n<h3 id=\"额外的一个好处-–-后台线程问题解决\"><a href=\"#额外的一个好处-–-后台线程问题解决\" class=\"headerlink\" title=\"额外的一个好处 – 后台线程问题解决\"></a>额外的一个好处 – 后台线程问题解决</h3><p>这一点值得单独拿出来说，在Android中有这么一类问题：在配置改变/Activity重启时Activity会重新构建（各种情况参考<a href=\"https://github.com/konmik/konmik.github.io/wiki/Introduction-to-Model-View-Presenter-on-Android\">一个mvp框架的实现</a>），如果后台线程持有Activity的引用会导致Activity泄露，最常见的代码是，<code>new Thread(runnable)</code>中Runnable是非静态内部类，默认会隐式持有外部的Activity的引用（更不要说我们有时会显示的持有了），不知不觉中内存泄漏了。。</p>\n<p>当使用MVP模式开发时，线程操作应当在P中（或者P使用的M中），只要我们<strong>在Activity的<code>onDestroy()</code>中，清空Presenter持有的View的引用即可。</strong>或者，<strong>Presenter干脆持有的是View的弱引用</strong>，可以杜绝此类问题。</p>\n<h3 id=\"要处理的一个问题-–-Presenter的保持\"><a href=\"#要处理的一个问题-–-Presenter的保持\" class=\"headerlink\" title=\"要处理的一个问题 – Presenter的保持\"></a>要处理的一个问题 – Presenter的保持</h3><p>同样，Activty的销毁与恢复，引来了另外一个问题，我有时需要：</p>\n<ul>\n<li>配置改变时，保持Presenter并重新与View绑定。</li>\n<li>Activity销毁重建（如打开不保留回收）时，保持一些值到Bundle</li>\n</ul>\n<blockquote>\n<p>这不是必须的，在大多数情况下，在Activity重建时重新构造一个新的Presenter并重新绑定View，这并没有什么问题。</p>\n</blockquote>\n<p>我们不希望重新构建Presenter，而继续使用之前的，这样的好处是不需要重新启动线程，重头开始一些操作。一些思路如下：</p>\n<ul>\n<li>最简单：使用xxActivity的静态变量保持Presenter，Activity重建时判空，如果Presenter非空，重新绑定Activity即可。问题是：<ul>\n<li>什么时候清空Presenter？不能在onDestroy中清空，容易泄露Presenter，正确方式参考nucleus框架。</li>\n<li>一个Activity类只能有一个Presenter（如果你要启动多个相同的Activity只能共享Presenter）</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/konmik/nucleus\">nucleus框架</a>：本质上和第一个相同，但是解决了上面的问题，他会在一个全局的静态池中保留所有的Presenter，配置改变时，Activity会维护自己持有的Presenter的ID（通过onSaveInstance，解决了上面第二个问题）但是不清空池子中的Presenter。而Activity销毁时会清空池中Presenter，重建时会使用保存的Bundle构建新的Presenter（通过onSaveInstance，Presenter也会有自己的Bundle）。</p>\n<blockquote>\n<p>注意:在改框架中是通过<code>Activity##isChangingConfigurations()</code>来判断是否是配置改变的情况。</p>\n</blockquote>\n</li>\n<li><p>使用Activity的Fragment setRetainInstance(true)来在<strong>配置改变时</strong>保持Presenter，问题：必须是Fragment的成员变量，<strong>在Activity重建时无法保持Presenter</strong>，需要自己实现类似bundle的功能恢复Presneter。</p>\n</li>\n<li>使用Android Loader机制：本质上setRetainInstance内部就是使用的此方法，使用自定义Loader保持Presenter可以应用在Activity，View任何场合。问题：与上面的类似，在Activity重建时无法保持Presenter。</li>\n</ul>\n<p>综上，大部分情况下，可能Presenter并不需要保持，我们无需使用任何手段，只需确保Presenter的逻辑正确。对于有需要的场合（如含有后台线程，频繁转动屏幕引起问题），<strong>个人建议使用Fragment保持机制最为简单可行</strong>（这也是Google Demo的作法）。</p>\n<h3 id=\"争论：谁是P\"><a href=\"#争论：谁是P\" class=\"headerlink\" title=\"争论：谁是P\"></a>争论：谁是P</h3><p>由于Android中Activity等控件特殊性（如具有生命周期），有很多的MVP实现使用Activity、Fragment、Adapter作为Presenter。Android中其他的View（ViewGroup）作为V，这样的好处是Presenter自带生命周期，使用是否方便。<br>但是，个人认为这个方法有可借鉴之处，但是并不好理解，没有单独一个Presenter类更加直观，并不适合实际使用。同样我们参考Google demo中的实现，使用了另外一种方案：<strong>建议使用单独的Presenter类，Fragment作为View，而Activity是构建和结合他们的地方</strong>。（强调必须使用Fragment，即使只有一个页面）。这种方式是可选的，职责清晰，虽然所有的Activity必须有Fragment麻烦了一点，这个代价还是值得的。</p>\n<h2 id=\"纯MVP实践–参考Google代码\"><a href=\"#纯MVP实践–参考Google代码\" class=\"headerlink\" title=\"纯MVP实践–参考Google代码\"></a>纯MVP实践–参考Google代码</h2><p>并不想贴自己的代码，毕竟没有Google的优雅，尤其是在细节地方，建议大家都参考<a href=\"https://github.com/googlesamples/android-architecture\">google的官方demo</a>的MVP分支。总结一下：</p>\n<ul>\n<li>View – Fragment、View 与 xxxContract.View接口</li>\n<li>Presenter – xxxPresenter与xxxContract.Presenter接口</li>\n<li>Model – xxxRepository，Model的内部实现以后再讲，也是接口分离各个数据来源。</li>\n<li>Activity – <strong>组合器</strong>,the overall controller that creates and connects views and presenters.</li>\n<li>xxxContract – <strong>契约类</strong>，每个业务都有，里面有View和Presenter一对接口，这种设计逻辑十分清晰，可以借鉴。</li>\n</ul>\n<h2 id=\"遗留问题\"><a href=\"#遗留问题\" class=\"headerlink\" title=\"遗留问题\"></a>遗留问题</h2><p>listview Adapter的MVP设计 – 在疑问解答中说明<br>Model的内部实现与缓存设计 – 单独文章</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><ul>\n<li><p><a href=\"https://github.com/livoras/blog/issues/11\">界面之下：还原真实的MV*模式</a>：我见过的最清晰的描述MVX文章</p>\n<blockquote>\n<ul>\n<li>MVC中保持了依赖同一块Model的不同View显示数据的实时性和准确性</li>\n<li>总结了各个模式的优缺点</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，MVP的问题基本说明白了，参考了原始资料，加入自己的理解。但是，还是建议以原始资料学习最佳，一万个人心中有一万个MVP，每个人的理解可能均不相同。</p>\n"},{"title":"Android构架系列之二--MVP&&Clean理解与实践之问题解答与总结","date":"2016-06-11T07:41:52.000Z","_content":"Android框架系列之二持续了两个月，本文是这个系列的一个小结，解答开篇提出的一些问题的思考与结论。\n\n\n## MVP相关\n### Clean与MVP的关系是什么？\n区别：\n\n* 从概念上说：Clean是三层构架（一种系统构架）的一种具体表现形式，是一种设计原则。MVP则是一种设计模式，用来连接M与V的方式。\n* 从使用范围来说：Clean使用于整个系统，其业务层（Model）十分复杂。MVP倾向于**薄Model的表现层**构架（客户端，展示层）。\n* 从抽象层次上说：Clean更抽象一些，MVP更加具体。\n\n联系：Clean构架是在MVP上使用了三层构架！\n\n### MVP中V层接口的设计原则是什么？\n首先，要明确接口设计的目的：\n\n* 复用\n* 测试\n\n对于MVP中V层接口，它的目的具体而言是：**方便View的复用，方便Presentor的mock测试**。总而言之，方便View的行为切换。\n因此，很明显View接口的设计必须：\n\n1. 如果View要被复用，思考View对外暴露的操作是否方便被不同的Presenter使用。PS：理解什么是View的复用，参考其他问题。\n2. 原子操作 VS 组合操作？如果是是Passive View的模式则暴露的接口尽量是原子操作（如显示list的一个item），组合逻辑放入Presentor中。否则，还是按照功能暴露接口（如显示一个List的所有item）。**推荐后者。**\n3. 。。。。。参考 MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)\n\n###  MVP中V与P的对应关系？1：1，n：1，1：n？？\n* 独立的View（不是一个组合，如ViewGroup）：原则上View：Presnter==1：1\n* 对于组合View（ViewGroup），如果ViewGroup内部控件比较简单，则View持有一个Presenter即可，如果内部是复杂的多个自定义控件，而且可以分块（分块原则是：每块之间关联尽量少，最好没有关联！），则View可以持有多个Presenter。\n* 不建议View：Presenter是n：1，既一个Presenter持有多个View接口。这种情况，可以重构View为一个暴露接口，如果View很复杂，可以参考上面一条。\n\n### MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\n* 一般而言，不是！View内部可以很复杂，但是对外接口要尽量简单。\n* 对于Passive View的MVP而言，对外接口可能是原子化的，View内部的逻辑这尽量简单\n* 对于Soc的MVP，即使有一些修改Model的操作都可以不经过Presenter。\n\n### MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)\n这个问题本质上是View接口的设计问题，MVP中P需要主动去V中区数据会导致View接口中方法数过多，V主动把数据给P，导致Presenter的方法的参数过多。建议\n\n* 尽量是通过参数传递给Presenter，Presenter的逻辑比较简单\n* 但是一写View的通用状态（整体状态）可以暴露在View中作为接口\n\n\t> 在Google demo中，Fragment的View接口有isActive()表示是否UI可见。这个是有必要的，因为model返回后不用它来判断是否需要显示结果。\n\t\n* PassiveView中可能获取状态的接口比较多一些，待讨论。\n\n### 其他问题\n1. Presenter需要设计接口吗？\n\t核心：View是否要被复用，如**一种常见的需求：相同的界面，加载不同的数据。**\n\t* 一般情况View不会被重用，Presenter接口没有必要，一个Presenter一般就用在一个地方，Presenter也不用mock来测试，直接测试Presenter本身就好。\n\t* 除非遇到这种情况：**Presenter的行为需要切换**，如有默认行为和自定义行为，或者相同的界面，加载不同的数据。\n\t\n\t> 但是Google demo中为Presenter设置了接口，和View集中在Contract类中，除了比较清晰以外，这个例子没有发现什么优势。\n\t\n2. View怎么复用？\n\tView可以绑定不同的Presenter。因为View与Presenter耦合（双向绑定），如果需要解耦Presenter，**如果View需要被复用，Presenter必须使用接口，那么View可以被不同的Presenter使用**。但是，**一般情况下，我们没有View被复用的需要，更需要的是View可被测试（Mock）。**\n\t\n3. Presenter怎么复用？\n\tPresenter可以用绑定不同的View。因为MVP中View的接口是强制的，所以Presenter与View是解耦的。**可以切换不同的View，这个对于测试Presenter时，View的Mock是必须的**。至于其他的需求这没有什么了。\n\n\n## Clean相关\n\n### Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\n这些接口的目的是Domain层（具体是UseCase）可以被复用，且可以被测试。\n因此，最简单的方式是UseCase必须持有Presentation接口与Repository接口。UseCase自身未必需要是接口。思考：UseCase自身是接口作用是什么？\n\n但是，参考Google Demo：\n\n* UseCase没有持有Presentation，以给它返回值，而是通过命令模式，传递在Domain层定义好的实体(xxxResponse)，实现解耦。（解耦的另一种思路，同样Clean的RxJava版本也是）\n* 令人意外的是UseCase持有Repository，没有通过接口：\n\t* 为了测试Domain，Repository内部有接口可以实现Mock。\n\t* 对于复用，猜测这样的原因是：把Domain和Repository看做一个整体的Model，我只要Model整体可以被复用即可。\n\n###  可否把Clean构架理解成一种AsyncTask？\n可以，相当于把AsyncTask分层了，doInBackground放入了Model(Domain+Repository)。但是不仅仅是AsyncTask，Clean的核心是Model的可测试性，UseCase可以测试。AsyncTask也是耦合很严重的。而且不推荐使用AsyncTask。\n\n### Domain中的UseCase是什么？它重吗？\n这个很难理解，Google认为对于移动应用Model很轻\n\n### 一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\n一件事，一个execute，执行一个任务，一个request一个reponse。\n必须是业务逻辑。\n\n我之前理解UseCase也叫Interactor，因此，一个用户操作触发的事情就是一个UseCase。实际中这不合适（Google Demo也不是这样干的，而是划分了更小，尽量复用UseCase来组合）\n\n\n### 多个UseCase如何组合\nGoolge的Demo中是在Presentation的Presentor嵌套调用。\n需要优化：\n\n* Rxjava流式调用\n* 新的UseCase组合其他多个UseCase\n\n### 后台线程的事件与UseCase如何通讯？\n由于Clean构架是MVP的改进，也存在同样的问题。这个问题是可解决的，使用EventBus通知Presention去调用Domain即可（为什么，参考MVP一文）\n\n### Domain的UseCase，需要默认在非UI线程中运行吗？\n建议是：最好在非UI中运行，但是对外可配置。\n\n### MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\n* 理解什么是Presenter，就不会有这个问题了，除非View是单例。。\n\n\t> 如果有单例需求，思考是不是Presenter用错地方了，那是Controller，Helper那些干的事情。\n* Domain -- 非单例，通过注入由外部构建加入到Presenter\n\n\t> Domain层缓存问题\n* Repository -- 单例\n\n\n###  *内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？*\n\n这个问题存疑，现在先解答一部分\n\n* Repository的原始数据缓存在某些情况（为了性能，很多情况都必要）下是必要的。\n* Domain层缓存在复杂计算的情况下也是需要的，但是设计是一个问题，我暂时使用的是一个UseCase引用了一个管理缓存的UseCase（管理缓存UseCase内部有个全局静态的缓存池）\n\n### Domain的UseCase是否需要缓存设计？\n我们应当设计薄Model的应用，**如果需要Domain缓存，应当思考你的Model是不是有点厚了**\n\n###  Presenter是否需要缓存的设计？还是仅仅是数据引用？\n\n没有缓存设计，仅仅是数据引用，这个引用放在View中也没有问题。（如Adapter中）\n\n### Clean中Presentation层与Domain层的UseCase职责分别是什么？\n还是理解Presentation的Presentor是展示器，负责展示相关的操作，而UseCase则是业务操作。一个例子：分页加载数据。\n\n* UseCase中出数据加载，去重合并，根据传入的页码返回数据\n* Presentor负责记录当前展示的页码和显示到了哪一条（一般是个id）\n\n### *一些Presentation层的Adapter，如何优雅的与Presenter结合*\n暂时的方法是，Adapter传入了Presentor的引用。\n另一种思路，没有实践：\nViewHolder---View\nAdapter--- Presentor\n在Adapter中调用UseCase\n\n### Data层的理解，什么才是data，图片是吗？\nData层属于Model，因此，Data是业务数据，不是没有业务含义的图片，文件。这些文件图片可以在工具类中直接使用即可。\n\n### DBFlow可以启用他的缓存实现原始数据的缓存吗？\n理论上可以，没有实践。\n\n## 其他\n\n### *Model层，如何设计*\n指的是MVP中的Model，或者Clean中的Domain+Data\n这个问题需要专门的专题讨论，autoValue等思想是否可以借鉴。\n\n### *Cache如何设计合适，如何与原始数据同步？是否有最佳实践？*\n这个问题很大，初步的探索类似于Google中HashMap+dirty处理的方式，是否有完善框架还没有调研。\n\n## 总结\n写这个专题真的很吃力，一方面自己的能力有限，实践也不多，对于设计 的驾驭能力显然还不够。其次，自己对于这方面的理解也比较肤浅，好的构建的也有限（甚至不能定义什么是足够好的构架）。这是一个要经常回头思考的问题。\n这个系列都没有给出一个构架的实例，有这么几个原因：首先，构架必须是服务于业务的，不同业务选择的构架迥然不同，（例如Model层问题）。其次，自己的代码没有Google官方的示例优雅，尤其是参入了一些曲解之后可能会误导他人，从学习的角度还是入手原始资料较好，即使是开始一个新的项目，也建议以此为蓝本作修改来适应具体的需求。\n后续，几个需要补充的问题，Model层设计和Cache设计会有专题来讲，希望在有深入的理解之后再继续讨论这个问题。","source":"_posts/Android构架系列之二-MVP&&Clean理解与实践之问题解答与总结.md","raw":"title: Android构架系列之二--MVP&&Clean理解与实践之问题解答与总结\ndate: 2016-06-11 15:41:52\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\nAndroid框架系列之二持续了两个月，本文是这个系列的一个小结，解答开篇提出的一些问题的思考与结论。\n\n\n## MVP相关\n### Clean与MVP的关系是什么？\n区别：\n\n* 从概念上说：Clean是三层构架（一种系统构架）的一种具体表现形式，是一种设计原则。MVP则是一种设计模式，用来连接M与V的方式。\n* 从使用范围来说：Clean使用于整个系统，其业务层（Model）十分复杂。MVP倾向于**薄Model的表现层**构架（客户端，展示层）。\n* 从抽象层次上说：Clean更抽象一些，MVP更加具体。\n\n联系：Clean构架是在MVP上使用了三层构架！\n\n### MVP中V层接口的设计原则是什么？\n首先，要明确接口设计的目的：\n\n* 复用\n* 测试\n\n对于MVP中V层接口，它的目的具体而言是：**方便View的复用，方便Presentor的mock测试**。总而言之，方便View的行为切换。\n因此，很明显View接口的设计必须：\n\n1. 如果View要被复用，思考View对外暴露的操作是否方便被不同的Presenter使用。PS：理解什么是View的复用，参考其他问题。\n2. 原子操作 VS 组合操作？如果是是Passive View的模式则暴露的接口尽量是原子操作（如显示list的一个item），组合逻辑放入Presentor中。否则，还是按照功能暴露接口（如显示一个List的所有item）。**推荐后者。**\n3. 。。。。。参考 MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)\n\n###  MVP中V与P的对应关系？1：1，n：1，1：n？？\n* 独立的View（不是一个组合，如ViewGroup）：原则上View：Presnter==1：1\n* 对于组合View（ViewGroup），如果ViewGroup内部控件比较简单，则View持有一个Presenter即可，如果内部是复杂的多个自定义控件，而且可以分块（分块原则是：每块之间关联尽量少，最好没有关联！），则View可以持有多个Presenter。\n* 不建议View：Presenter是n：1，既一个Presenter持有多个View接口。这种情况，可以重构View为一个暴露接口，如果View很复杂，可以参考上面一条。\n\n### MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\n* 一般而言，不是！View内部可以很复杂，但是对外接口要尽量简单。\n* 对于Passive View的MVP而言，对外接口可能是原子化的，View内部的逻辑这尽量简单\n* 对于Soc的MVP，即使有一些修改Model的操作都可以不经过Presenter。\n\n### MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)\n这个问题本质上是View接口的设计问题，MVP中P需要主动去V中区数据会导致View接口中方法数过多，V主动把数据给P，导致Presenter的方法的参数过多。建议\n\n* 尽量是通过参数传递给Presenter，Presenter的逻辑比较简单\n* 但是一写View的通用状态（整体状态）可以暴露在View中作为接口\n\n\t> 在Google demo中，Fragment的View接口有isActive()表示是否UI可见。这个是有必要的，因为model返回后不用它来判断是否需要显示结果。\n\t\n* PassiveView中可能获取状态的接口比较多一些，待讨论。\n\n### 其他问题\n1. Presenter需要设计接口吗？\n\t核心：View是否要被复用，如**一种常见的需求：相同的界面，加载不同的数据。**\n\t* 一般情况View不会被重用，Presenter接口没有必要，一个Presenter一般就用在一个地方，Presenter也不用mock来测试，直接测试Presenter本身就好。\n\t* 除非遇到这种情况：**Presenter的行为需要切换**，如有默认行为和自定义行为，或者相同的界面，加载不同的数据。\n\t\n\t> 但是Google demo中为Presenter设置了接口，和View集中在Contract类中，除了比较清晰以外，这个例子没有发现什么优势。\n\t\n2. View怎么复用？\n\tView可以绑定不同的Presenter。因为View与Presenter耦合（双向绑定），如果需要解耦Presenter，**如果View需要被复用，Presenter必须使用接口，那么View可以被不同的Presenter使用**。但是，**一般情况下，我们没有View被复用的需要，更需要的是View可被测试（Mock）。**\n\t\n3. Presenter怎么复用？\n\tPresenter可以用绑定不同的View。因为MVP中View的接口是强制的，所以Presenter与View是解耦的。**可以切换不同的View，这个对于测试Presenter时，View的Mock是必须的**。至于其他的需求这没有什么了。\n\n\n## Clean相关\n\n### Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\n这些接口的目的是Domain层（具体是UseCase）可以被复用，且可以被测试。\n因此，最简单的方式是UseCase必须持有Presentation接口与Repository接口。UseCase自身未必需要是接口。思考：UseCase自身是接口作用是什么？\n\n但是，参考Google Demo：\n\n* UseCase没有持有Presentation，以给它返回值，而是通过命令模式，传递在Domain层定义好的实体(xxxResponse)，实现解耦。（解耦的另一种思路，同样Clean的RxJava版本也是）\n* 令人意外的是UseCase持有Repository，没有通过接口：\n\t* 为了测试Domain，Repository内部有接口可以实现Mock。\n\t* 对于复用，猜测这样的原因是：把Domain和Repository看做一个整体的Model，我只要Model整体可以被复用即可。\n\n###  可否把Clean构架理解成一种AsyncTask？\n可以，相当于把AsyncTask分层了，doInBackground放入了Model(Domain+Repository)。但是不仅仅是AsyncTask，Clean的核心是Model的可测试性，UseCase可以测试。AsyncTask也是耦合很严重的。而且不推荐使用AsyncTask。\n\n### Domain中的UseCase是什么？它重吗？\n这个很难理解，Google认为对于移动应用Model很轻\n\n### 一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\n一件事，一个execute，执行一个任务，一个request一个reponse。\n必须是业务逻辑。\n\n我之前理解UseCase也叫Interactor，因此，一个用户操作触发的事情就是一个UseCase。实际中这不合适（Google Demo也不是这样干的，而是划分了更小，尽量复用UseCase来组合）\n\n\n### 多个UseCase如何组合\nGoolge的Demo中是在Presentation的Presentor嵌套调用。\n需要优化：\n\n* Rxjava流式调用\n* 新的UseCase组合其他多个UseCase\n\n### 后台线程的事件与UseCase如何通讯？\n由于Clean构架是MVP的改进，也存在同样的问题。这个问题是可解决的，使用EventBus通知Presention去调用Domain即可（为什么，参考MVP一文）\n\n### Domain的UseCase，需要默认在非UI线程中运行吗？\n建议是：最好在非UI中运行，但是对外可配置。\n\n### MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\n* 理解什么是Presenter，就不会有这个问题了，除非View是单例。。\n\n\t> 如果有单例需求，思考是不是Presenter用错地方了，那是Controller，Helper那些干的事情。\n* Domain -- 非单例，通过注入由外部构建加入到Presenter\n\n\t> Domain层缓存问题\n* Repository -- 单例\n\n\n###  *内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？*\n\n这个问题存疑，现在先解答一部分\n\n* Repository的原始数据缓存在某些情况（为了性能，很多情况都必要）下是必要的。\n* Domain层缓存在复杂计算的情况下也是需要的，但是设计是一个问题，我暂时使用的是一个UseCase引用了一个管理缓存的UseCase（管理缓存UseCase内部有个全局静态的缓存池）\n\n### Domain的UseCase是否需要缓存设计？\n我们应当设计薄Model的应用，**如果需要Domain缓存，应当思考你的Model是不是有点厚了**\n\n###  Presenter是否需要缓存的设计？还是仅仅是数据引用？\n\n没有缓存设计，仅仅是数据引用，这个引用放在View中也没有问题。（如Adapter中）\n\n### Clean中Presentation层与Domain层的UseCase职责分别是什么？\n还是理解Presentation的Presentor是展示器，负责展示相关的操作，而UseCase则是业务操作。一个例子：分页加载数据。\n\n* UseCase中出数据加载，去重合并，根据传入的页码返回数据\n* Presentor负责记录当前展示的页码和显示到了哪一条（一般是个id）\n\n### *一些Presentation层的Adapter，如何优雅的与Presenter结合*\n暂时的方法是，Adapter传入了Presentor的引用。\n另一种思路，没有实践：\nViewHolder---View\nAdapter--- Presentor\n在Adapter中调用UseCase\n\n### Data层的理解，什么才是data，图片是吗？\nData层属于Model，因此，Data是业务数据，不是没有业务含义的图片，文件。这些文件图片可以在工具类中直接使用即可。\n\n### DBFlow可以启用他的缓存实现原始数据的缓存吗？\n理论上可以，没有实践。\n\n## 其他\n\n### *Model层，如何设计*\n指的是MVP中的Model，或者Clean中的Domain+Data\n这个问题需要专门的专题讨论，autoValue等思想是否可以借鉴。\n\n### *Cache如何设计合适，如何与原始数据同步？是否有最佳实践？*\n这个问题很大，初步的探索类似于Google中HashMap+dirty处理的方式，是否有完善框架还没有调研。\n\n## 总结\n写这个专题真的很吃力，一方面自己的能力有限，实践也不多，对于设计 的驾驭能力显然还不够。其次，自己对于这方面的理解也比较肤浅，好的构建的也有限（甚至不能定义什么是足够好的构架）。这是一个要经常回头思考的问题。\n这个系列都没有给出一个构架的实例，有这么几个原因：首先，构架必须是服务于业务的，不同业务选择的构架迥然不同，（例如Model层问题）。其次，自己的代码没有Google官方的示例优雅，尤其是参入了一些曲解之后可能会误导他人，从学习的角度还是入手原始资料较好，即使是开始一个新的项目，也建议以此为蓝本作修改来适应具体的需求。\n后续，几个需要补充的问题，Model层设计和Cache设计会有专题来讲，希望在有深入的理解之后再继续讨论这个问题。","slug":"Android构架系列之二-MVP&&Clean理解与实践之问题解答与总结","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbc9000fnac9fs45vdoc","content":"<p>Android框架系列之二持续了两个月，本文是这个系列的一个小结，解答开篇提出的一些问题的思考与结论。</p>\n<h2 id=\"MVP相关\"><a href=\"#MVP相关\" class=\"headerlink\" title=\"MVP相关\"></a>MVP相关</h2><h3 id=\"Clean与MVP的关系是什么？\"><a href=\"#Clean与MVP的关系是什么？\" class=\"headerlink\" title=\"Clean与MVP的关系是什么？\"></a>Clean与MVP的关系是什么？</h3><p>区别：</p>\n<ul>\n<li>从概念上说：Clean是三层构架（一种系统构架）的一种具体表现形式，是一种设计原则。MVP则是一种设计模式，用来连接M与V的方式。</li>\n<li>从使用范围来说：Clean使用于整个系统，其业务层（Model）十分复杂。MVP倾向于<strong>薄Model的表现层</strong>构架（客户端，展示层）。</li>\n<li>从抽象层次上说：Clean更抽象一些，MVP更加具体。</li>\n</ul>\n<p>联系：Clean构架是在MVP上使用了三层构架！</p>\n<h3 id=\"MVP中V层接口的设计原则是什么？\"><a href=\"#MVP中V层接口的设计原则是什么？\" class=\"headerlink\" title=\"MVP中V层接口的设计原则是什么？\"></a>MVP中V层接口的设计原则是什么？</h3><p>首先，要明确接口设计的目的：</p>\n<ul>\n<li>复用</li>\n<li>测试</li>\n</ul>\n<p>对于MVP中V层接口，它的目的具体而言是：<strong>方便View的复用，方便Presentor的mock测试</strong>。总而言之，方便View的行为切换。<br>因此，很明显View接口的设计必须：</p>\n<ol>\n<li>如果View要被复用，思考View对外暴露的操作是否方便被不同的Presenter使用。PS：理解什么是View的复用，参考其他问题。</li>\n<li>原子操作 VS 组合操作？如果是是Passive View的模式则暴露的接口尽量是原子操作（如显示list的一个item），组合逻辑放入Presentor中。否则，还是按照功能暴露接口（如显示一个List的所有item）。<strong>推荐后者。</strong></li>\n<li>。。。。。参考 MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)</li>\n</ol>\n<h3 id=\"MVP中V与P的对应关系？1：1，n：1，1：n？？\"><a href=\"#MVP中V与P的对应关系？1：1，n：1，1：n？？\" class=\"headerlink\" title=\"MVP中V与P的对应关系？1：1，n：1，1：n？？\"></a>MVP中V与P的对应关系？1：1，n：1，1：n？？</h3><ul>\n<li>独立的View（不是一个组合，如ViewGroup）：原则上View：Presnter==1：1</li>\n<li>对于组合View（ViewGroup），如果ViewGroup内部控件比较简单，则View持有一个Presenter即可，如果内部是复杂的多个自定义控件，而且可以分块（分块原则是：每块之间关联尽量少，最好没有关联！），则View可以持有多个Presenter。</li>\n<li>不建议View：Presenter是n：1，既一个Presenter持有多个View接口。这种情况，可以重构View为一个暴露接口，如果View很复杂，可以参考上面一条。</li>\n</ul>\n<h3 id=\"MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\"><a href=\"#MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\" class=\"headerlink\" title=\"MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\"></a>MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。</h3><ul>\n<li>一般而言，不是！View内部可以很复杂，但是对外接口要尽量简单。</li>\n<li>对于Passive View的MVP而言，对外接口可能是原子化的，View内部的逻辑这尽量简单</li>\n<li>对于Soc的MVP，即使有一些修改Model的操作都可以不经过Presenter。</li>\n</ul>\n<h3 id=\"MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC\"><a href=\"#MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC\" class=\"headerlink\" title=\"MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)\"></a>MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)</h3><p>这个问题本质上是View接口的设计问题，MVP中P需要主动去V中区数据会导致View接口中方法数过多，V主动把数据给P，导致Presenter的方法的参数过多。建议</p>\n<ul>\n<li>尽量是通过参数传递给Presenter，Presenter的逻辑比较简单</li>\n<li><p>但是一写View的通用状态（整体状态）可以暴露在View中作为接口</p>\n<blockquote>\n<p>在Google demo中，Fragment的View接口有isActive()表示是否UI可见。这个是有必要的，因为model返回后不用它来判断是否需要显示结果。</p>\n</blockquote>\n</li>\n<li><p>PassiveView中可能获取状态的接口比较多一些，待讨论。</p>\n</li>\n</ul>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><ol>\n<li><p>Presenter需要设计接口吗？<br> 核心：View是否要被复用，如<strong>一种常见的需求：相同的界面，加载不同的数据。</strong></p>\n<ul>\n<li>一般情况View不会被重用，Presenter接口没有必要，一个Presenter一般就用在一个地方，Presenter也不用mock来测试，直接测试Presenter本身就好。</li>\n<li><p>除非遇到这种情况：<strong>Presenter的行为需要切换</strong>，如有默认行为和自定义行为，或者相同的界面，加载不同的数据。</p>\n<blockquote>\n<p>但是Google demo中为Presenter设置了接口，和View集中在Contract类中，除了比较清晰以外，这个例子没有发现什么优势。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>View怎么复用？<br> View可以绑定不同的Presenter。因为View与Presenter耦合（双向绑定），如果需要解耦Presenter，<strong>如果View需要被复用，Presenter必须使用接口，那么View可以被不同的Presenter使用</strong>。但是，<strong>一般情况下，我们没有View被复用的需要，更需要的是View可被测试（Mock）。</strong></p>\n</li>\n<li><p>Presenter怎么复用？<br> Presenter可以用绑定不同的View。因为MVP中View的接口是强制的，所以Presenter与View是解耦的。<strong>可以切换不同的View，这个对于测试Presenter时，View的Mock是必须的</strong>。至于其他的需求这没有什么了。</p>\n</li>\n</ol>\n<h2 id=\"Clean相关\"><a href=\"#Clean相关\" class=\"headerlink\" title=\"Clean相关\"></a>Clean相关</h2><h3 id=\"Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\"><a href=\"#Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\" class=\"headerlink\" title=\"Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\"></a>Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？</h3><p>这些接口的目的是Domain层（具体是UseCase）可以被复用，且可以被测试。<br>因此，最简单的方式是UseCase必须持有Presentation接口与Repository接口。UseCase自身未必需要是接口。思考：UseCase自身是接口作用是什么？</p>\n<p>但是，参考Google Demo：</p>\n<ul>\n<li>UseCase没有持有Presentation，以给它返回值，而是通过命令模式，传递在Domain层定义好的实体(xxxResponse)，实现解耦。（解耦的另一种思路，同样Clean的RxJava版本也是）</li>\n<li>令人意外的是UseCase持有Repository，没有通过接口：<ul>\n<li>为了测试Domain，Repository内部有接口可以实现Mock。</li>\n<li>对于复用，猜测这样的原因是：把Domain和Repository看做一个整体的Model，我只要Model整体可以被复用即可。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"可否把Clean构架理解成一种AsyncTask？\"><a href=\"#可否把Clean构架理解成一种AsyncTask？\" class=\"headerlink\" title=\"可否把Clean构架理解成一种AsyncTask？\"></a>可否把Clean构架理解成一种AsyncTask？</h3><p>可以，相当于把AsyncTask分层了，doInBackground放入了Model(Domain+Repository)。但是不仅仅是AsyncTask，Clean的核心是Model的可测试性，UseCase可以测试。AsyncTask也是耦合很严重的。而且不推荐使用AsyncTask。</p>\n<h3 id=\"Domain中的UseCase是什么？它重吗？\"><a href=\"#Domain中的UseCase是什么？它重吗？\" class=\"headerlink\" title=\"Domain中的UseCase是什么？它重吗？\"></a>Domain中的UseCase是什么？它重吗？</h3><p>这个很难理解，Google认为对于移动应用Model很轻</p>\n<h3 id=\"一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\"><a href=\"#一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\" class=\"headerlink\" title=\"一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\"></a>一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？</h3><p>一件事，一个execute，执行一个任务，一个request一个reponse。<br>必须是业务逻辑。</p>\n<p>我之前理解UseCase也叫Interactor，因此，一个用户操作触发的事情就是一个UseCase。实际中这不合适（Google Demo也不是这样干的，而是划分了更小，尽量复用UseCase来组合）</p>\n<h3 id=\"多个UseCase如何组合\"><a href=\"#多个UseCase如何组合\" class=\"headerlink\" title=\"多个UseCase如何组合\"></a>多个UseCase如何组合</h3><p>Goolge的Demo中是在Presentation的Presentor嵌套调用。<br>需要优化：</p>\n<ul>\n<li>Rxjava流式调用</li>\n<li>新的UseCase组合其他多个UseCase</li>\n</ul>\n<h3 id=\"后台线程的事件与UseCase如何通讯？\"><a href=\"#后台线程的事件与UseCase如何通讯？\" class=\"headerlink\" title=\"后台线程的事件与UseCase如何通讯？\"></a>后台线程的事件与UseCase如何通讯？</h3><p>由于Clean构架是MVP的改进，也存在同样的问题。这个问题是可解决的，使用EventBus通知Presention去调用Domain即可（为什么，参考MVP一文）</p>\n<h3 id=\"Domain的UseCase，需要默认在非UI线程中运行吗？\"><a href=\"#Domain的UseCase，需要默认在非UI线程中运行吗？\" class=\"headerlink\" title=\"Domain的UseCase，需要默认在非UI线程中运行吗？\"></a>Domain的UseCase，需要默认在非UI线程中运行吗？</h3><p>建议是：最好在非UI中运行，但是对外可配置。</p>\n<h3 id=\"MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\"><a href=\"#MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\" class=\"headerlink\" title=\"MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\"></a>MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？</h3><ul>\n<li><p>理解什么是Presenter，就不会有这个问题了，除非View是单例。。</p>\n<blockquote>\n<p>如果有单例需求，思考是不是Presenter用错地方了，那是Controller，Helper那些干的事情。</p>\n</blockquote>\n</li>\n<li><p>Domain – 非单例，通过注入由外部构建加入到Presenter</p>\n<blockquote>\n<p>Domain层缓存问题</p>\n</blockquote>\n</li>\n<li>Repository – 单例</li>\n</ul>\n<h3 id=\"内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？\"><a href=\"#内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？\" class=\"headerlink\" title=\"内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？\"></a><em>内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？</em></h3><p>这个问题存疑，现在先解答一部分</p>\n<ul>\n<li>Repository的原始数据缓存在某些情况（为了性能，很多情况都必要）下是必要的。</li>\n<li>Domain层缓存在复杂计算的情况下也是需要的，但是设计是一个问题，我暂时使用的是一个UseCase引用了一个管理缓存的UseCase（管理缓存UseCase内部有个全局静态的缓存池）</li>\n</ul>\n<h3 id=\"Domain的UseCase是否需要缓存设计？\"><a href=\"#Domain的UseCase是否需要缓存设计？\" class=\"headerlink\" title=\"Domain的UseCase是否需要缓存设计？\"></a>Domain的UseCase是否需要缓存设计？</h3><p>我们应当设计薄Model的应用，<strong>如果需要Domain缓存，应当思考你的Model是不是有点厚了</strong></p>\n<h3 id=\"Presenter是否需要缓存的设计？还是仅仅是数据引用？\"><a href=\"#Presenter是否需要缓存的设计？还是仅仅是数据引用？\" class=\"headerlink\" title=\"Presenter是否需要缓存的设计？还是仅仅是数据引用？\"></a>Presenter是否需要缓存的设计？还是仅仅是数据引用？</h3><p>没有缓存设计，仅仅是数据引用，这个引用放在View中也没有问题。（如Adapter中）</p>\n<h3 id=\"Clean中Presentation层与Domain层的UseCase职责分别是什么？\"><a href=\"#Clean中Presentation层与Domain层的UseCase职责分别是什么？\" class=\"headerlink\" title=\"Clean中Presentation层与Domain层的UseCase职责分别是什么？\"></a>Clean中Presentation层与Domain层的UseCase职责分别是什么？</h3><p>还是理解Presentation的Presentor是展示器，负责展示相关的操作，而UseCase则是业务操作。一个例子：分页加载数据。</p>\n<ul>\n<li>UseCase中出数据加载，去重合并，根据传入的页码返回数据</li>\n<li>Presentor负责记录当前展示的页码和显示到了哪一条（一般是个id）</li>\n</ul>\n<h3 id=\"一些Presentation层的Adapter，如何优雅的与Presenter结合\"><a href=\"#一些Presentation层的Adapter，如何优雅的与Presenter结合\" class=\"headerlink\" title=\"一些Presentation层的Adapter，如何优雅的与Presenter结合\"></a><em>一些Presentation层的Adapter，如何优雅的与Presenter结合</em></h3><p>暂时的方法是，Adapter传入了Presentor的引用。<br>另一种思路，没有实践：<br>ViewHolder—View<br>Adapter— Presentor<br>在Adapter中调用UseCase</p>\n<h3 id=\"Data层的理解，什么才是data，图片是吗？\"><a href=\"#Data层的理解，什么才是data，图片是吗？\" class=\"headerlink\" title=\"Data层的理解，什么才是data，图片是吗？\"></a>Data层的理解，什么才是data，图片是吗？</h3><p>Data层属于Model，因此，Data是业务数据，不是没有业务含义的图片，文件。这些文件图片可以在工具类中直接使用即可。</p>\n<h3 id=\"DBFlow可以启用他的缓存实现原始数据的缓存吗？\"><a href=\"#DBFlow可以启用他的缓存实现原始数据的缓存吗？\" class=\"headerlink\" title=\"DBFlow可以启用他的缓存实现原始数据的缓存吗？\"></a>DBFlow可以启用他的缓存实现原始数据的缓存吗？</h3><p>理论上可以，没有实践。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"Model层，如何设计\"><a href=\"#Model层，如何设计\" class=\"headerlink\" title=\"Model层，如何设计\"></a><em>Model层，如何设计</em></h3><p>指的是MVP中的Model，或者Clean中的Domain+Data<br>这个问题需要专门的专题讨论，autoValue等思想是否可以借鉴。</p>\n<h3 id=\"Cache如何设计合适，如何与原始数据同步？是否有最佳实践？\"><a href=\"#Cache如何设计合适，如何与原始数据同步？是否有最佳实践？\" class=\"headerlink\" title=\"Cache如何设计合适，如何与原始数据同步？是否有最佳实践？\"></a><em>Cache如何设计合适，如何与原始数据同步？是否有最佳实践？</em></h3><p>这个问题很大，初步的探索类似于Google中HashMap+dirty处理的方式，是否有完善框架还没有调研。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>写这个专题真的很吃力，一方面自己的能力有限，实践也不多，对于设计 的驾驭能力显然还不够。其次，自己对于这方面的理解也比较肤浅，好的构建的也有限（甚至不能定义什么是足够好的构架）。这是一个要经常回头思考的问题。<br>这个系列都没有给出一个构架的实例，有这么几个原因：首先，构架必须是服务于业务的，不同业务选择的构架迥然不同，（例如Model层问题）。其次，自己的代码没有Google官方的示例优雅，尤其是参入了一些曲解之后可能会误导他人，从学习的角度还是入手原始资料较好，即使是开始一个新的项目，也建议以此为蓝本作修改来适应具体的需求。<br>后续，几个需要补充的问题，Model层设计和Cache设计会有专题来讲，希望在有深入的理解之后再继续讨论这个问题。</p>\n","excerpt":"","more":"<p>Android框架系列之二持续了两个月，本文是这个系列的一个小结，解答开篇提出的一些问题的思考与结论。</p>\n<h2 id=\"MVP相关\"><a href=\"#MVP相关\" class=\"headerlink\" title=\"MVP相关\"></a>MVP相关</h2><h3 id=\"Clean与MVP的关系是什么？\"><a href=\"#Clean与MVP的关系是什么？\" class=\"headerlink\" title=\"Clean与MVP的关系是什么？\"></a>Clean与MVP的关系是什么？</h3><p>区别：</p>\n<ul>\n<li>从概念上说：Clean是三层构架（一种系统构架）的一种具体表现形式，是一种设计原则。MVP则是一种设计模式，用来连接M与V的方式。</li>\n<li>从使用范围来说：Clean使用于整个系统，其业务层（Model）十分复杂。MVP倾向于<strong>薄Model的表现层</strong>构架（客户端，展示层）。</li>\n<li>从抽象层次上说：Clean更抽象一些，MVP更加具体。</li>\n</ul>\n<p>联系：Clean构架是在MVP上使用了三层构架！</p>\n<h3 id=\"MVP中V层接口的设计原则是什么？\"><a href=\"#MVP中V层接口的设计原则是什么？\" class=\"headerlink\" title=\"MVP中V层接口的设计原则是什么？\"></a>MVP中V层接口的设计原则是什么？</h3><p>首先，要明确接口设计的目的：</p>\n<ul>\n<li>复用</li>\n<li>测试</li>\n</ul>\n<p>对于MVP中V层接口，它的目的具体而言是：<strong>方便View的复用，方便Presentor的mock测试</strong>。总而言之，方便View的行为切换。<br>因此，很明显View接口的设计必须：</p>\n<ol>\n<li>如果View要被复用，思考View对外暴露的操作是否方便被不同的Presenter使用。PS：理解什么是View的复用，参考其他问题。</li>\n<li>原子操作 VS 组合操作？如果是是Passive View的模式则暴露的接口尽量是原子操作（如显示list的一个item），组合逻辑放入Presentor中。否则，还是按照功能暴露接口（如显示一个List的所有item）。<strong>推荐后者。</strong></li>\n<li>。。。。。参考 MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)</li>\n</ol>\n<h3 id=\"MVP中V与P的对应关系？1：1，n：1，1：n？？\"><a href=\"#MVP中V与P的对应关系？1：1，n：1，1：n？？\" class=\"headerlink\" title=\"MVP中V与P的对应关系？1：1，n：1，1：n？？\"></a>MVP中V与P的对应关系？1：1，n：1，1：n？？</h3><ul>\n<li>独立的View（不是一个组合，如ViewGroup）：原则上View：Presnter==1：1</li>\n<li>对于组合View（ViewGroup），如果ViewGroup内部控件比较简单，则View持有一个Presenter即可，如果内部是复杂的多个自定义控件，而且可以分块（分块原则是：每块之间关联尽量少，最好没有关联！），则View可以持有多个Presenter。</li>\n<li>不建议View：Presenter是n：1，既一个Presenter持有多个View接口。这种情况，可以重构View为一个暴露接口，如果View很复杂，可以参考上面一条。</li>\n</ul>\n<h3 id=\"MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\"><a href=\"#MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\" class=\"headerlink\" title=\"MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\"></a>MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。</h3><ul>\n<li>一般而言，不是！View内部可以很复杂，但是对外接口要尽量简单。</li>\n<li>对于Passive View的MVP而言，对外接口可能是原子化的，View内部的逻辑这尽量简单</li>\n<li>对于Soc的MVP，即使有一些修改Model的操作都可以不经过Presenter。</li>\n</ul>\n<h3 id=\"MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC\"><a href=\"#MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC\" class=\"headerlink\" title=\"MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)\"></a>MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)</h3><p>这个问题本质上是View接口的设计问题，MVP中P需要主动去V中区数据会导致View接口中方法数过多，V主动把数据给P，导致Presenter的方法的参数过多。建议</p>\n<ul>\n<li>尽量是通过参数传递给Presenter，Presenter的逻辑比较简单</li>\n<li><p>但是一写View的通用状态（整体状态）可以暴露在View中作为接口</p>\n<blockquote>\n<p>在Google demo中，Fragment的View接口有isActive()表示是否UI可见。这个是有必要的，因为model返回后不用它来判断是否需要显示结果。</p>\n</blockquote>\n</li>\n<li><p>PassiveView中可能获取状态的接口比较多一些，待讨论。</p>\n</li>\n</ul>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><ol>\n<li><p>Presenter需要设计接口吗？<br> 核心：View是否要被复用，如<strong>一种常见的需求：相同的界面，加载不同的数据。</strong></p>\n<ul>\n<li>一般情况View不会被重用，Presenter接口没有必要，一个Presenter一般就用在一个地方，Presenter也不用mock来测试，直接测试Presenter本身就好。</li>\n<li><p>除非遇到这种情况：<strong>Presenter的行为需要切换</strong>，如有默认行为和自定义行为，或者相同的界面，加载不同的数据。</p>\n<blockquote>\n<p>但是Google demo中为Presenter设置了接口，和View集中在Contract类中，除了比较清晰以外，这个例子没有发现什么优势。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>View怎么复用？<br> View可以绑定不同的Presenter。因为View与Presenter耦合（双向绑定），如果需要解耦Presenter，<strong>如果View需要被复用，Presenter必须使用接口，那么View可以被不同的Presenter使用</strong>。但是，<strong>一般情况下，我们没有View被复用的需要，更需要的是View可被测试（Mock）。</strong></p>\n</li>\n<li><p>Presenter怎么复用？<br> Presenter可以用绑定不同的View。因为MVP中View的接口是强制的，所以Presenter与View是解耦的。<strong>可以切换不同的View，这个对于测试Presenter时，View的Mock是必须的</strong>。至于其他的需求这没有什么了。</p>\n</li>\n</ol>\n<h2 id=\"Clean相关\"><a href=\"#Clean相关\" class=\"headerlink\" title=\"Clean相关\"></a>Clean相关</h2><h3 id=\"Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\"><a href=\"#Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\" class=\"headerlink\" title=\"Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\"></a>Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？</h3><p>这些接口的目的是Domain层（具体是UseCase）可以被复用，且可以被测试。<br>因此，最简单的方式是UseCase必须持有Presentation接口与Repository接口。UseCase自身未必需要是接口。思考：UseCase自身是接口作用是什么？</p>\n<p>但是，参考Google Demo：</p>\n<ul>\n<li>UseCase没有持有Presentation，以给它返回值，而是通过命令模式，传递在Domain层定义好的实体(xxxResponse)，实现解耦。（解耦的另一种思路，同样Clean的RxJava版本也是）</li>\n<li>令人意外的是UseCase持有Repository，没有通过接口：<ul>\n<li>为了测试Domain，Repository内部有接口可以实现Mock。</li>\n<li>对于复用，猜测这样的原因是：把Domain和Repository看做一个整体的Model，我只要Model整体可以被复用即可。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"可否把Clean构架理解成一种AsyncTask？\"><a href=\"#可否把Clean构架理解成一种AsyncTask？\" class=\"headerlink\" title=\"可否把Clean构架理解成一种AsyncTask？\"></a>可否把Clean构架理解成一种AsyncTask？</h3><p>可以，相当于把AsyncTask分层了，doInBackground放入了Model(Domain+Repository)。但是不仅仅是AsyncTask，Clean的核心是Model的可测试性，UseCase可以测试。AsyncTask也是耦合很严重的。而且不推荐使用AsyncTask。</p>\n<h3 id=\"Domain中的UseCase是什么？它重吗？\"><a href=\"#Domain中的UseCase是什么？它重吗？\" class=\"headerlink\" title=\"Domain中的UseCase是什么？它重吗？\"></a>Domain中的UseCase是什么？它重吗？</h3><p>这个很难理解，Google认为对于移动应用Model很轻</p>\n<h3 id=\"一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\"><a href=\"#一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\" class=\"headerlink\" title=\"一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\"></a>一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？</h3><p>一件事，一个execute，执行一个任务，一个request一个reponse。<br>必须是业务逻辑。</p>\n<p>我之前理解UseCase也叫Interactor，因此，一个用户操作触发的事情就是一个UseCase。实际中这不合适（Google Demo也不是这样干的，而是划分了更小，尽量复用UseCase来组合）</p>\n<h3 id=\"多个UseCase如何组合\"><a href=\"#多个UseCase如何组合\" class=\"headerlink\" title=\"多个UseCase如何组合\"></a>多个UseCase如何组合</h3><p>Goolge的Demo中是在Presentation的Presentor嵌套调用。<br>需要优化：</p>\n<ul>\n<li>Rxjava流式调用</li>\n<li>新的UseCase组合其他多个UseCase</li>\n</ul>\n<h3 id=\"后台线程的事件与UseCase如何通讯？\"><a href=\"#后台线程的事件与UseCase如何通讯？\" class=\"headerlink\" title=\"后台线程的事件与UseCase如何通讯？\"></a>后台线程的事件与UseCase如何通讯？</h3><p>由于Clean构架是MVP的改进，也存在同样的问题。这个问题是可解决的，使用EventBus通知Presention去调用Domain即可（为什么，参考MVP一文）</p>\n<h3 id=\"Domain的UseCase，需要默认在非UI线程中运行吗？\"><a href=\"#Domain的UseCase，需要默认在非UI线程中运行吗？\" class=\"headerlink\" title=\"Domain的UseCase，需要默认在非UI线程中运行吗？\"></a>Domain的UseCase，需要默认在非UI线程中运行吗？</h3><p>建议是：最好在非UI中运行，但是对外可配置。</p>\n<h3 id=\"MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\"><a href=\"#MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\" class=\"headerlink\" title=\"MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\"></a>MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？</h3><ul>\n<li><p>理解什么是Presenter，就不会有这个问题了，除非View是单例。。</p>\n<blockquote>\n<p>如果有单例需求，思考是不是Presenter用错地方了，那是Controller，Helper那些干的事情。</p>\n</blockquote>\n</li>\n<li><p>Domain – 非单例，通过注入由外部构建加入到Presenter</p>\n<blockquote>\n<p>Domain层缓存问题</p>\n</blockquote>\n</li>\n<li>Repository – 单例</li>\n</ul>\n<h3 id=\"内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？\"><a href=\"#内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？\" class=\"headerlink\" title=\"内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？\"></a><em>内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？</em></h3><p>这个问题存疑，现在先解答一部分</p>\n<ul>\n<li>Repository的原始数据缓存在某些情况（为了性能，很多情况都必要）下是必要的。</li>\n<li>Domain层缓存在复杂计算的情况下也是需要的，但是设计是一个问题，我暂时使用的是一个UseCase引用了一个管理缓存的UseCase（管理缓存UseCase内部有个全局静态的缓存池）</li>\n</ul>\n<h3 id=\"Domain的UseCase是否需要缓存设计？\"><a href=\"#Domain的UseCase是否需要缓存设计？\" class=\"headerlink\" title=\"Domain的UseCase是否需要缓存设计？\"></a>Domain的UseCase是否需要缓存设计？</h3><p>我们应当设计薄Model的应用，<strong>如果需要Domain缓存，应当思考你的Model是不是有点厚了</strong></p>\n<h3 id=\"Presenter是否需要缓存的设计？还是仅仅是数据引用？\"><a href=\"#Presenter是否需要缓存的设计？还是仅仅是数据引用？\" class=\"headerlink\" title=\"Presenter是否需要缓存的设计？还是仅仅是数据引用？\"></a>Presenter是否需要缓存的设计？还是仅仅是数据引用？</h3><p>没有缓存设计，仅仅是数据引用，这个引用放在View中也没有问题。（如Adapter中）</p>\n<h3 id=\"Clean中Presentation层与Domain层的UseCase职责分别是什么？\"><a href=\"#Clean中Presentation层与Domain层的UseCase职责分别是什么？\" class=\"headerlink\" title=\"Clean中Presentation层与Domain层的UseCase职责分别是什么？\"></a>Clean中Presentation层与Domain层的UseCase职责分别是什么？</h3><p>还是理解Presentation的Presentor是展示器，负责展示相关的操作，而UseCase则是业务操作。一个例子：分页加载数据。</p>\n<ul>\n<li>UseCase中出数据加载，去重合并，根据传入的页码返回数据</li>\n<li>Presentor负责记录当前展示的页码和显示到了哪一条（一般是个id）</li>\n</ul>\n<h3 id=\"一些Presentation层的Adapter，如何优雅的与Presenter结合\"><a href=\"#一些Presentation层的Adapter，如何优雅的与Presenter结合\" class=\"headerlink\" title=\"一些Presentation层的Adapter，如何优雅的与Presenter结合\"></a><em>一些Presentation层的Adapter，如何优雅的与Presenter结合</em></h3><p>暂时的方法是，Adapter传入了Presentor的引用。<br>另一种思路，没有实践：<br>ViewHolder—View<br>Adapter— Presentor<br>在Adapter中调用UseCase</p>\n<h3 id=\"Data层的理解，什么才是data，图片是吗？\"><a href=\"#Data层的理解，什么才是data，图片是吗？\" class=\"headerlink\" title=\"Data层的理解，什么才是data，图片是吗？\"></a>Data层的理解，什么才是data，图片是吗？</h3><p>Data层属于Model，因此，Data是业务数据，不是没有业务含义的图片，文件。这些文件图片可以在工具类中直接使用即可。</p>\n<h3 id=\"DBFlow可以启用他的缓存实现原始数据的缓存吗？\"><a href=\"#DBFlow可以启用他的缓存实现原始数据的缓存吗？\" class=\"headerlink\" title=\"DBFlow可以启用他的缓存实现原始数据的缓存吗？\"></a>DBFlow可以启用他的缓存实现原始数据的缓存吗？</h3><p>理论上可以，没有实践。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"Model层，如何设计\"><a href=\"#Model层，如何设计\" class=\"headerlink\" title=\"Model层，如何设计\"></a><em>Model层，如何设计</em></h3><p>指的是MVP中的Model，或者Clean中的Domain+Data<br>这个问题需要专门的专题讨论，autoValue等思想是否可以借鉴。</p>\n<h3 id=\"Cache如何设计合适，如何与原始数据同步？是否有最佳实践？\"><a href=\"#Cache如何设计合适，如何与原始数据同步？是否有最佳实践？\" class=\"headerlink\" title=\"Cache如何设计合适，如何与原始数据同步？是否有最佳实践？\"></a><em>Cache如何设计合适，如何与原始数据同步？是否有最佳实践？</em></h3><p>这个问题很大，初步的探索类似于Google中HashMap+dirty处理的方式，是否有完善框架还没有调研。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>写这个专题真的很吃力，一方面自己的能力有限，实践也不多，对于设计 的驾驭能力显然还不够。其次，自己对于这方面的理解也比较肤浅，好的构建的也有限（甚至不能定义什么是足够好的构架）。这是一个要经常回头思考的问题。<br>这个系列都没有给出一个构架的实例，有这么几个原因：首先，构架必须是服务于业务的，不同业务选择的构架迥然不同，（例如Model层问题）。其次，自己的代码没有Google官方的示例优雅，尤其是参入了一些曲解之后可能会误导他人，从学习的角度还是入手原始资料较好，即使是开始一个新的项目，也建议以此为蓝本作修改来适应具体的需求。<br>后续，几个需要补充的问题，Model层设计和Cache设计会有专题来讲，希望在有深入的理解之后再继续讨论这个问题。</p>\n"},{"title":"Android构架系列之二--MVP&&Clean理解与实践之实例分析","date":"2016-05-15T08:45:33.000Z","_content":"前面我们分析了MVP与Clean，本文试图以[Google构架Demo的Clean分支](https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean)为样本来分析一下具体的代码实现。由于Clean包含了MVP部分，所以MVP的部分一并说明。\n需要强调的是这并不是Clean构架的唯一实现方式，但是其思想可以借鉴。\n\n## 总体结构\n<img src=\"https://github.com/googlesamples/android-architecture/wiki/images/mvp-clean.png\" alt=\"Diagram\"/>\n分为三部分：\n\n* 展现(Presentation)层: 核心是**MVP** ，做UI控制。\n* 领域(Domain)层: 核心是**UseCase** 这一层是所有的业务逻辑，这一层的类都叫做`xxxUseCase`或者`xxxInteractor`（在这个Demo中都是UseCase的子类，命名都是以业务相关的动名词的形式，如GetTasks），代表了在Presentation层开发者可以执行的所有Action。\n* 数据(Data)层: 核心是**Repository**，是使用数据仓库模式。\n\n\n## 展现(Presentation)层--MVP\n由以下几部分组成\n\n1. Activity: **组合View(Fragemnt)与Presenter**，Activity不是View！Activity的`OnCreate`中完成3件事情。\n\t* 构建View，这里都是Fragment。\n\t* **生成所有Presenter用到的的UseCase**，UseCase用的UseCaseHandler,Repository：目的是方便修改注入，用Provider的方式代替注入框架，全部在Activity中注入完成，如果使用Dagger等注入框架，这里不必要。\n\t> 请对比学习\n\t\n\t* 生成Presenter并**双向绑定**：注意参数：注入刚才的View，和用到的所有UserCase.\n\t* **Presenter的状态恢复**，在Activity重建时，都是重新构建Presenter，并且只恢复Presenter中某些数据的状态。（这一步可选，只恢复使用的数据，大部分情况下并没有恢复数据，重新构建Presenter。这里的实现简单粗暴，也可以用Fragment来保持Presenter，关于Presenter的恢复问题MVP一节中有讨论）\n\t\n\tActivity的OnCreate中代码如下\n\t\n\t```java\n\t// 生成View\n        TasksFragment tasksFragment =\n                (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);\n        if (tasksFragment == null) {\n            // Create the fragment\n            tasksFragment = TasksFragment.newInstance();\n            ActivityUtils.addFragmentToActivity(\n                    getSupportFragmentManager(), tasksFragment, R.id.contentFrame);\n        }\n\t```\n\n\t```java\n\t// 生成Presenter，注意参数传入了上面生成的View和用到的UseCase\n\t// 注意：在Presenter的构造函数内部会调用View的setPresenter实现双向绑定\n\t   mTasksPresenter = new TasksPresenter(\n                Injection.provideUseCaseHandler(),\n                tasksFragment,\n                Injection.provideGetTasks(getApplicationContext()),\n                Injection.provideCompleteTasks(getApplicationContext()),\n                Injection.provideActivateTask(getApplicationContext()),\n                Injection.provideClearCompleteTasks(getApplicationContext())\n                );\n\t```\n\t```java\n\t// Presenter状态恢复\n        if (savedInstanceState != null) {\n            TasksFilterType currentFiltering =\n                    (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY);\n            mTasksPresenter.setFiltering(currentFiltering);\n        }\n\t```\n2. Fragment：代表View，与其他的View作用相同\n\n\t```java\npublic class TasksFragment extends Fragment implements TasksContract.View {\n    public TasksFragment() {\n        // Requires empty public constructor\n    }\n\n    public static TasksFragment newInstance() {\n    \t// 构建Fragment的最佳实践，可以setArgument等\n        return new TasksFragment();\n    }\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mListAdapter = new TasksAdapter(new ArrayList<Task>(0), mItemListener);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // Presenter一般都会实现以下通用的方法\n        mPresenter.start();\n    }\n\n\t// 双向绑定时，给Presenter使用的\n    @Override\n    public void setPresenter(@NonNull TasksContract.Presenter presenter) {\n        mPresenter = checkNotNull(presenter);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n    \t // 一些回调交给Presenter处理\n        mPresenter.result(requestCode, resultCode);\n    }\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View root = inflater.inflate(R.layout.addtask_frag, container, false);\n        // 这个看情况，界面中有无需要保持的数据（如一些用户输入的信息）。\n        // 由于这里没有使用Fragemnt来保持Presenter，这个也可以不加\n        // setRetainInstance(true);\n        return root;\n    }\n    \n    // 其他的View接口的方法实现，给Presenter使用\n    @Override\n    public void showTasksList() {\n        getActivity().setResult(Activity.RESULT_OK);\n        getActivity().finish();\n    }\n}\n\t```\n\n\t从上述代码中，我们可以得到几点信息：\n\t\n\t* 在View的生命周期中调用对应的Presenter方法。\n\t* **View与Presenter的绑定时机**：这里的View(Fragment)比较被动，通过在Presenter的构造函数中调用View接口的setPresnter方法注入Presenter，实现双向绑定。\t\n\t* Fragment没有履行Presenter保持的职责，他只负责保持界面的数据（如果有必要，参考`AddEditTaskFragment.java`）。\n\t\n\t\t> 之所以这样，一部分原因是由Activity来管理数据恢复这些事情，职责清晰。\n\n3. Presenter类\n特点如下\n\t* 实现了xxxContract.Presenter接口，包括该接口的父接口BasePresenter中定义的生命周期映射（只有`void start()`方法一般在View的`onResume()`中调用）。\n\t* 暴露了的接口要明确。大部分暴露的接口都是View使用的操作（由用户行为触发）与Activity用到的功能（数据保持恢复型操作）。**如何定义，定义什么接口具体查看Contract**\n\t* 构造函数中与Fragment绑定，setPresenter\n\t* 一个Presenter中**含有多个UseCase**\n\t* 一个对外接口可以单独运行一个UseCase或者**组合运行多个UseCase，嵌套调用。**\n\t* 可能有`public void result(int requestCode, int resultCode)`接口，映射了Fragment(不是Activity）的onActivityResult方法，处理回调。\n\t* 额外的还有数据获取与恢复接口给Activity调用\n\t* 接口中对View传来的**原始数据**进行处理。如判空等，在Presenter中，如果是null，直接调用View告知用户。而不是把这些值向下传入Domain层。**原则：异常输入越早处理约好**\n\n\t```java\n\tpublic class TaskDetailPresenter implements TaskDetailContract.Presenter {\n\n    private final TaskDetailContract.View mTaskDetailView;\n    private final UseCaseHandler mUseCaseHandler;\n    // 含有多个UseCase\n    private final GetTask mGetTask;\n    private final CompleteTask mCompleteTask;\n    private final ActivateTask mActivateTask;\n    private final DeleteTask mDeleteTask;\n\n    @Nullable\n    private String mTaskId;\n\n    public TaskDetailPresenter(@NonNull UseCaseHandler useCaseHandler,\n            @Nullable String taskId,\n            @NonNull TaskDetailContract.View taskDetailView,\n            @NonNull GetTask getTask,\n            @NonNull CompleteTask completeTask,\n            @NonNull ActivateTask activateTask,\n            @NonNull DeleteTask deleteTask) {\n        mTaskId = taskId;\n        // 这些判空也是尽早发现问题的思想\n        mUseCaseHandler = checkNotNull(useCaseHandler, \"useCaseHandler cannot be null!\");\n        mTaskDetailView = checkNotNull(taskDetailView, \"taskDetailView cannot be null!\");\n        mGetTask = checkNotNull(getTask, \"getTask cannot be null!\");\n        mCompleteTask = checkNotNull(completeTask, \"completeTask cannot be null!\");\n        mActivateTask = checkNotNull(activateTask, \"activateTask cannot be null!\");\n        mDeleteTask = checkNotNull(deleteTask, \"deleteTask cannot be null!\");\n        mTaskDetailView.setPresenter(this);\n    }\n\n    // 抽象了一下，几乎所有的Presenter都有启动的那一刻，启动后可能是获取数据（绝大多数），或者其他操作。\n    @Override\n    public void start() {\n        openTask();\n    }\n    // 这个很有意思，把Fragment的onActivityResult的值直接传递到Presenter中处理\n    @Override\n    public void result(int requestCode, int resultCode) {\n        // If a task was successfully added, show snackbar\n        if (AddEditTaskActivity.REQUEST_ADD_TASK == requestCode\n                && Activity.RESULT_OK == resultCode) {\n            mTasksView.showSuccessfullySavedMessage();\n        }\n    }\n\n    private void openTask() {\n    // 这里是输入的异常处理，越早越好，不要向下传再抛回来\n        if (mTaskId == null || mTaskId.isEmpty()) {\n            mTaskDetailView.showMissingTask();\n            return;\n        }\n\n        mTaskDetailView.setLoadingIndicator(true);\n\n        mUseCaseHandler.execute(mGetTask, new GetTask.RequestValues(mTaskId),\n                new UseCase.UseCaseCallback<GetTask.ResponseValue>() {\n                    @Override\n                    public void onSuccess(GetTask.ResponseValue response) {\n                        Task task = response.getTask();\n\n                        // The view may not be able to handle UI updates anymore\n                        if (!mTaskDetailView.isActive()) {\n                            return;\n                        }\n                        mTaskDetailView.setLoadingIndicator(false);\n                        if (null == task) {\n                            mTaskDetailView.showMissingTask();\n                        } else {\n                            showTask(task);\n                        }\n                    }\n\n                    @Override\n                    public void onError() {\n                        // The view may not be able to handle UI updates anymore\n                        if (!mTaskDetailView.isActive()) {\n                            return;\n                        }\n                        mTaskDetailView.showMissingTask();\n                    }\n                });\n    }\n\n    // 这些暴露的接口都是以用户动作触发为单位的！\n    @Override\n    public void editTask() {\n    // 这里是输入的异常处理，越早越好，不要向下传再抛回来\n        if (mTaskId == null || mTaskId.isEmpty()) {\n            mTaskDetailView.showMissingTask();\n            return;\n        }\n        mTaskDetailView.showEditTask(mTaskId);\n    }\n\n    @Override\n    public void deleteTask() {\n        mUseCaseHandler.execute(mDeleteTask, new DeleteTask.RequestValues(mTaskId),\n                new UseCase.UseCaseCallback<DeleteTask.ResponseValue>() {\n                    @Override\n                    public void onSuccess(DeleteTask.ResponseValue response) {\n                        mTaskDetailView.showTaskDeleted();\n                    }\n\n                    @Override\n                    public void onError() {\n                        // Show error, log, etc.\n                    }\n                });\n    }\n// 这些暴露的接口都是以用户动作触发为单位的！\n    @Override\n    public void completeTask() {\n        if (mTaskId == null || mTaskId.isEmpty()) {\n            mTaskDetailView.showMissingTask();\n            return;\n        }\n\n        mUseCaseHandler.execute(mCompleteTask, new CompleteTask.RequestValues(mTaskId),\n                new UseCase.UseCaseCallback<CompleteTask.ResponseValue>() {\n                    @Override\n                    public void onSuccess(CompleteTask.ResponseValue response) {\n                        mTaskDetailView.showTaskMarkedComplete();\n                    }\n\n                    @Override\n                    public void onError() {\n                        // Show error, log, etc.\n                    }\n                });\n    }\n// 这些暴露的接口都是以用户动作触发为单位的！\n    @Override\n    public void activateTask() {\n        if (mTaskId == null || mTaskId.isEmpty()) {\n            mTaskDetailView.showMissingTask();\n            return;\n        }\n        mUseCaseHandler.execute(mActivateTask, new ActivateTask.RequestValues(mTaskId),\n                new UseCase.UseCaseCallback<ActivateTask.ResponseValue>() {\n                    @Override\n                    public void onSuccess(ActivateTask.ResponseValue response) {\n                        mTaskDetailView.showTaskMarkedActive();\n                    }\n\n                    @Override\n                    public void onError() {\n                        // Show error, log, etc.\n                    }\n                });\n    }\n\n    private void showTask(Task task) {\n        String title = task.getTitle();\n        String description = task.getDescription();\n\n        if (title != null && title.isEmpty()) {\n            mTaskDetailView.hideTitle();\n        } else {\n            mTaskDetailView.showTitle(title);\n        }\n\n        if (description != null && description.isEmpty()) {\n            mTaskDetailView.hideDescription();\n        } else {\n            mTaskDetailView.showDescription(description);\n        }\n        mTaskDetailView.showCompletionStatus(task.isCompleted());\n    }\n    \n    // 这两个方法比较特别，是Avtivity保存与恢复数据使用的，不是用户操作\n    @Override\n    public void setFiltering(TasksFilterType requestType) {\n        mCurrentFiltering = requestType;\n    }\n\n    @Override\n    public TasksFilterType getFiltering() {\n        return mCurrentFiltering;\n    }\n}\n\n\t```\n\n\n\n4. Contract--接口定义\n   这个类是demo的特色，把一个业务的**展现层与领域层之间的接口**归类到一个类中十分清晰\n\t* View层的操作（往往由用户触发）\n\t\t* 编辑\n\t\t* 添加\n\t\t* 删除\n\t\t* 点击\n\t\t* 下拉。。。\n\t* View的生命周期映射、抽象\n\t\t* onResume -- `void start()`\n\t\t* onPause \n\t\t* onDestroy。。。\n\t\t* **`void result(int requestCode, int resultCode);`**\n\t* 数据存储恢复（这个demo是Activity使用）\n\t\t*  onSaveInstance -- `void setFiltering(TasksFilterType requestType);`\n\t\t*  onRestoreInstance -- `TasksFilterType getFiltering();`\n\n```java\npublic interface AddEditTaskContract {\n// view层接口,从extends BaseView<Presenter> 就看出来依赖\n    interface View extends BaseView<Presenter> {\n\n        void showEmptyTaskError();\n\n        void showTasksList();\n\n        void setTitle(String title);\n\n        void setDescription(String description);\n\n        boolean isActive();\n    }\n// presenter接口\n    interface Presenter extends BasePresenter {\n\n        void saveTask(String title, String description);\n\n        void populateTask();\n    }\n}\n\n```\n\n## 领域(Domain)层--UseCase\n调用领域层的代码都是在展现层的Presenter类中。\n\n### UseCase的外部特点：\n\n* 独立性，可复用，一个业务定义的UseCase可以被其他业务单独使用\n\n> 实例：`TaskDetailPresenter`与`TasksPresenter `都使用了`CompleteTask `\n\n* 命名直观，表示其功能\n* **一个UseCase外而言只执行一个任务**，既一个request一个reponse，没有多个方法暴露\n* Presentation层的调用者使用[命令模式]()执行UseCase\n\t* 单独运行一个UseCase\n\t* 组合运行多个UseCase：嵌套调用\n\n\n* 使用命令模式 一个执行器参考`UseCaseHandler`，参数是UseCase（命令），Request（输入参数）与Response（输出结果）。**UseCaseHandler也是在Activty中构造传入Presenter的。**\n* **注意传参的方式**，Request与Response都是定义在UseCase中的内部类，用它们来包裹传递的值，不是使用`new xxxUseCase(param1,param2).execute(callback)`的样式，或者`new xxxUseCase().execute(param1,param2,callback)`\n\n\n\n实例代码如下\n\t\n```java\n\tpublic void clearCompletedTasks() {\n        mUseCaseHandler.execute(mClearCompleteTasks, new ClearCompleteTasks.RequestValues(),\n                new UseCase.UseCaseCallback<ClearCompleteTasks.ResponseValue>() {\n                    @Override\n                    public void onSuccess(ClearCompleteTasks.ResponseValue response) {\n                        mTasksView.showCompletedTasksCleared();\n                        loadTasks(false, false);\n                    }\n\n                    @Override\n                    public void onError() {\n                        mTasksView.showLoadingTasksError();\n                    }\n                });\n    }\n```\n\n### UseCase的内部实现\n* **UseCase内部没有调用其他UseCase，组合由Presenter完成**，UseCase之间不可以互相调用？？？\n\n> demo中是这样的，实际开发中有这个需求吗？还是合理划分UseCase就可以了？，尤其是一个UseCase只有执行一个execute，如果一个复杂的UseCase有多个可以复用的任务组成，难道逻辑放到Presenter中？虽然理论上移动端不应该有如此复杂的业务逻辑。展示逻辑（如分页）在Presenter中没有问题。\n\n* UseCase内部的`executeUseCase()`覆写，实现真正的业务逻辑。\n* 内部类定义Request与Reponse，包裹传递的实体。\n* **没有在UseCase内的变量缓存数据**\n* 执行器executeUseCase默认在在非UI线程执行UseCase，但是CallBack会回到UI线程，参考`UseCaseHandler.java`\n\n```java\n// UseCase泛型参数就是命令模式的几个参数\npublic class GetTasks extends UseCase<GetTasks.RequestValues, GetTasks.ResponseValue> {\n\n\t// 注意：无变量缓存\n    private final TasksRepository mTasksRepository;\n\n    private final FilterFactory mFilterFactory;\n\n\t\n    public GetTasks(@NonNull TasksRepository tasksRepository, @NonNull FilterFactory filterFactory) {\n        mTasksRepository = checkNotNull(tasksRepository, \"tasksRepository cannot be null!\");\n        mFilterFactory = checkNotNull(filterFactory, \"filterFactory cannot be null!\");\n    }\n\n    @Override\n    protected void executeUseCase(final RequestValues values) {\n        if (values.isForceUpdate()) {\n            mTasksRepository.refreshTasks();\n        }\n\n        mTasksRepository.getTasks(new TasksDataSource.LoadTasksCallback() {\n            @Override\n            public void onTasksLoaded(List<Task> tasks) {\n            // 纯的业务逻辑，每一次都从数据仓库重新获取过滤\n                TasksFilterType currentFiltering = values.getCurrentFiltering();\n                TaskFilter taskFilter = mFilterFactory.create(currentFiltering);\n\n                List<Task> tasksFiltered = taskFilter.filter(tasks);\n                ResponseValue responseValue = new ResponseValue(tasksFiltered);\n                // 这种通知方式getUseCaseCallback的被封装了\n                getUseCaseCallback().onSuccess(responseValue);\n            }\n\n            @Override\n            public void onDataNotAvailable() {\n             // 这种通知方式getUseCaseCallback的被封装了\n                getUseCaseCallback().onError();\n            }\n        });\n\n    }\n\t// 注意这两个类UseCase.RequestValues与UseCase.ResponseValue是空的接口，子类设计也是比较自由的\n    public static final class RequestValues implements UseCase.RequestValues {\n\n        private final TasksFilterType mCurrentFiltering;\n        private final boolean mForceUpdate;\n\n        public RequestValues(boolean forceUpdate, @NonNull TasksFilterType currentFiltering) {\n            mForceUpdate = forceUpdate;\n            mCurrentFiltering = checkNotNull(currentFiltering, \"currentFiltering cannot be null!\");\n        }\n\n        public boolean isForceUpdate() {\n            return mForceUpdate;\n        }\n\n        public TasksFilterType getCurrentFiltering() {\n            return mCurrentFiltering;\n        }\n    }\n\n    public static final class ResponseValue implements UseCase.ResponseValue {\n\n        private final List<Task> mTasks;\n\n        public ResponseValue(@NonNull List<Task> tasks) {\n            mTasks = checkNotNull(tasks, \"tasks cannot be null!\");\n        }\n\n        public List<Task> getTasks() {\n            return mTasks;\n        }\n    }\n}\n\n```\n\n## 数据(Data)层--Repository模式\n领域层从数据仓库获取接口，\n### Repository的外部特点\n* 领域层直接持有数据层的类`TasksRepository`而非`TasksDataSource`接口。\n\n> 虽然持有TasksRepository，不影响测试（本质上它就是个门面，如果测试在注入时替换内部Source就行，参考下面代码），但是很奇怪。我觉得持有TasksDataSource没有问题，可能是TasksRepository语意更清晰。\n\n* 单例设计，很好理解\n* **有同步方法，也有异步方法**。但是没必要用异步的，同步即可。TasksDataSource中有一些异步的Callback接口，README中都说了没有必要。。。\n\n* 接口中的方法定义与存储的数据相关，如添加一个todo任务，删除一个todo任务，获取所有的todo任务\n\n### Repository的内部实现\n* **内部有缓存**，单仅仅是原始数据缓存，使用HashMap实现，比较简单。\n* Repository模式类似与装饰模式，`TasksRepository`暴露的接口只负责获取到数据，而不论数据的来源是哪里（可能是内存，网络，数据库）\n* `TasksRepository`的内部设计会引用多个来源TasksDataSource，他们也都实现了`TasksRepository`接口。如果需要测试，直接用fake的TasksDataSource替代真实的source即可。\n\n```java\n// 注意接口设计TasksDataSource与下面mTasksRemoteDataSource等相同\npublic class TasksRepository implements TasksDataSource {\n\n    private static TasksRepository INSTANCE = null;\n\n    private final TasksDataSource mTasksRemoteDataSource;\n\n    private final TasksDataSource mTasksLocalDataSource;\n\n    // 缓存\n    Map<String, Task> mCachedTasks;\n\t// 缓存 数据脏了\n    boolean mCacheIsDirty = false;\n\n    // Prevent direct instantiation.\n    private TasksRepository(@NonNull TasksDataSource tasksRemoteDataSource,\n                            @NonNull TasksDataSource tasksLocalDataSource) {\n        mTasksRemoteDataSource = checkNotNull(tasksRemoteDataSource);\n        mTasksLocalDataSource = checkNotNull(tasksLocalDataSource);\n    }\n\n\t// 这里有些特殊：getInstance的参数是source，RemoteDataSource与LocalDataSource可以替换成fake的source\n\t// 注意：缓存是内置的，没有用外面的\n    public static TasksRepository getInstance(TasksDataSource tasksRemoteDataSource,\n                                              TasksDataSource tasksLocalDataSource) {\n        if (INSTANCE == null) {\n            INSTANCE = new TasksRepository(tasksRemoteDataSource, tasksLocalDataSource);\n        }\n        return INSTANCE;\n    }\n\n\n    public static void destroyInstance() {\n        INSTANCE = null;\n    }\n\n\n\t// 数据获取逻辑，可能是从任何地方获取的数据\n    @Override\n    public void getTasks(@NonNull final LoadTasksCallback callback) {\n        checkNotNull(callback);\n\n        // Respond immediately with cache if available and not dirty\n        if (mCachedTasks != null && !mCacheIsDirty) {\n            callback.onTasksLoaded(new ArrayList<>(mCachedTasks.values()));\n            return;\n        }\n\n        if (mCacheIsDirty) {\n            // If the cache is dirty we need to fetch new data from the network.\n            getTasksFromRemoteDataSource(callback);\n        } else {\n            // Query the local storage if available. If not, query the network.\n            mTasksLocalDataSource.getTasks(new LoadTasksCallback() {\n                @Override\n                public void onTasksLoaded(List<Task> tasks) {\n                    refreshCache(tasks);\n                    callback.onTasksLoaded(new ArrayList<>(mCachedTasks.values()));\n                }\n\n                @Override\n                public void onDataNotAvailable() {\n                    getTasksFromRemoteDataSource(callback);\n                }\n            });\n        }\n    }\n\n    @Override\n    public void saveTask(@NonNull Task task) {\n        checkNotNull(task);\n        mTasksRemoteDataSource.saveTask(task);\n        mTasksLocalDataSource.saveTask(task);\n\n        // Do in memory cache update to keep the app UI up to date\n        if (mCachedTasks == null) {\n            mCachedTasks = new LinkedHashMap<>();\n        }\n        mCachedTasks.put(task.getId(), task);\n    }\n}\n```\n\n## 数据实体\n三层的数据Entity与Clean原文中不同\n特点：\n\n * 公用，**三层通用了一个数据Model**--Task。减少了Clean构架的三层数据模型之间的转换\n\n## 总结\n仅仅讨论Demo的不完善的地方：\n\n* 没有考虑P层的Presenter的保持\n* Domain层没有负责的业务逻辑，没有多UseCase相互调用的例子\n* Domain数据处理简单没有性能问题。没有缓存\n* 没有Notify机制的示例。都是一个request一个reponse的简单请求。\n\n优点：\n\n* Activty与Fragment职责明确\n* Contract设计\n* 轻客户端思想，Domain尽量简单（与上面对应，哈哈）\n* UseCase的简单设计思想，使得UseCese可以在其他模块复用（参考GetTasks用例）\n* Domain的命令模式，设计可以参考\n* 数据仓库的设计（缓存和多Source思想）\n\n\n争论：\n\n* StatisticsPresenter中的统计逻辑位置是否有问题？在主线程？为什么不用一个UseCase？","source":"_posts/Android构架系列之二-MVP&&Clean理解与实践之实例分析.md","raw":"title: Android构架系列之二--MVP&&Clean理解与实践之实例分析\ndate: 2016-05-15 16:45:33\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n前面我们分析了MVP与Clean，本文试图以[Google构架Demo的Clean分支](https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean)为样本来分析一下具体的代码实现。由于Clean包含了MVP部分，所以MVP的部分一并说明。\n需要强调的是这并不是Clean构架的唯一实现方式，但是其思想可以借鉴。\n\n## 总体结构\n<img src=\"https://github.com/googlesamples/android-architecture/wiki/images/mvp-clean.png\" alt=\"Diagram\"/>\n分为三部分：\n\n* 展现(Presentation)层: 核心是**MVP** ，做UI控制。\n* 领域(Domain)层: 核心是**UseCase** 这一层是所有的业务逻辑，这一层的类都叫做`xxxUseCase`或者`xxxInteractor`（在这个Demo中都是UseCase的子类，命名都是以业务相关的动名词的形式，如GetTasks），代表了在Presentation层开发者可以执行的所有Action。\n* 数据(Data)层: 核心是**Repository**，是使用数据仓库模式。\n\n\n## 展现(Presentation)层--MVP\n由以下几部分组成\n\n1. Activity: **组合View(Fragemnt)与Presenter**，Activity不是View！Activity的`OnCreate`中完成3件事情。\n\t* 构建View，这里都是Fragment。\n\t* **生成所有Presenter用到的的UseCase**，UseCase用的UseCaseHandler,Repository：目的是方便修改注入，用Provider的方式代替注入框架，全部在Activity中注入完成，如果使用Dagger等注入框架，这里不必要。\n\t> 请对比学习\n\t\n\t* 生成Presenter并**双向绑定**：注意参数：注入刚才的View，和用到的所有UserCase.\n\t* **Presenter的状态恢复**，在Activity重建时，都是重新构建Presenter，并且只恢复Presenter中某些数据的状态。（这一步可选，只恢复使用的数据，大部分情况下并没有恢复数据，重新构建Presenter。这里的实现简单粗暴，也可以用Fragment来保持Presenter，关于Presenter的恢复问题MVP一节中有讨论）\n\t\n\tActivity的OnCreate中代码如下\n\t\n\t```java\n\t// 生成View\n        TasksFragment tasksFragment =\n                (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);\n        if (tasksFragment == null) {\n            // Create the fragment\n            tasksFragment = TasksFragment.newInstance();\n            ActivityUtils.addFragmentToActivity(\n                    getSupportFragmentManager(), tasksFragment, R.id.contentFrame);\n        }\n\t```\n\n\t```java\n\t// 生成Presenter，注意参数传入了上面生成的View和用到的UseCase\n\t// 注意：在Presenter的构造函数内部会调用View的setPresenter实现双向绑定\n\t   mTasksPresenter = new TasksPresenter(\n                Injection.provideUseCaseHandler(),\n                tasksFragment,\n                Injection.provideGetTasks(getApplicationContext()),\n                Injection.provideCompleteTasks(getApplicationContext()),\n                Injection.provideActivateTask(getApplicationContext()),\n                Injection.provideClearCompleteTasks(getApplicationContext())\n                );\n\t```\n\t```java\n\t// Presenter状态恢复\n        if (savedInstanceState != null) {\n            TasksFilterType currentFiltering =\n                    (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY);\n            mTasksPresenter.setFiltering(currentFiltering);\n        }\n\t```\n2. Fragment：代表View，与其他的View作用相同\n\n\t```java\npublic class TasksFragment extends Fragment implements TasksContract.View {\n    public TasksFragment() {\n        // Requires empty public constructor\n    }\n\n    public static TasksFragment newInstance() {\n    \t// 构建Fragment的最佳实践，可以setArgument等\n        return new TasksFragment();\n    }\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mListAdapter = new TasksAdapter(new ArrayList<Task>(0), mItemListener);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // Presenter一般都会实现以下通用的方法\n        mPresenter.start();\n    }\n\n\t// 双向绑定时，给Presenter使用的\n    @Override\n    public void setPresenter(@NonNull TasksContract.Presenter presenter) {\n        mPresenter = checkNotNull(presenter);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n    \t // 一些回调交给Presenter处理\n        mPresenter.result(requestCode, resultCode);\n    }\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View root = inflater.inflate(R.layout.addtask_frag, container, false);\n        // 这个看情况，界面中有无需要保持的数据（如一些用户输入的信息）。\n        // 由于这里没有使用Fragemnt来保持Presenter，这个也可以不加\n        // setRetainInstance(true);\n        return root;\n    }\n    \n    // 其他的View接口的方法实现，给Presenter使用\n    @Override\n    public void showTasksList() {\n        getActivity().setResult(Activity.RESULT_OK);\n        getActivity().finish();\n    }\n}\n\t```\n\n\t从上述代码中，我们可以得到几点信息：\n\t\n\t* 在View的生命周期中调用对应的Presenter方法。\n\t* **View与Presenter的绑定时机**：这里的View(Fragment)比较被动，通过在Presenter的构造函数中调用View接口的setPresnter方法注入Presenter，实现双向绑定。\t\n\t* Fragment没有履行Presenter保持的职责，他只负责保持界面的数据（如果有必要，参考`AddEditTaskFragment.java`）。\n\t\n\t\t> 之所以这样，一部分原因是由Activity来管理数据恢复这些事情，职责清晰。\n\n3. Presenter类\n特点如下\n\t* 实现了xxxContract.Presenter接口，包括该接口的父接口BasePresenter中定义的生命周期映射（只有`void start()`方法一般在View的`onResume()`中调用）。\n\t* 暴露了的接口要明确。大部分暴露的接口都是View使用的操作（由用户行为触发）与Activity用到的功能（数据保持恢复型操作）。**如何定义，定义什么接口具体查看Contract**\n\t* 构造函数中与Fragment绑定，setPresenter\n\t* 一个Presenter中**含有多个UseCase**\n\t* 一个对外接口可以单独运行一个UseCase或者**组合运行多个UseCase，嵌套调用。**\n\t* 可能有`public void result(int requestCode, int resultCode)`接口，映射了Fragment(不是Activity）的onActivityResult方法，处理回调。\n\t* 额外的还有数据获取与恢复接口给Activity调用\n\t* 接口中对View传来的**原始数据**进行处理。如判空等，在Presenter中，如果是null，直接调用View告知用户。而不是把这些值向下传入Domain层。**原则：异常输入越早处理约好**\n\n\t```java\n\tpublic class TaskDetailPresenter implements TaskDetailContract.Presenter {\n\n    private final TaskDetailContract.View mTaskDetailView;\n    private final UseCaseHandler mUseCaseHandler;\n    // 含有多个UseCase\n    private final GetTask mGetTask;\n    private final CompleteTask mCompleteTask;\n    private final ActivateTask mActivateTask;\n    private final DeleteTask mDeleteTask;\n\n    @Nullable\n    private String mTaskId;\n\n    public TaskDetailPresenter(@NonNull UseCaseHandler useCaseHandler,\n            @Nullable String taskId,\n            @NonNull TaskDetailContract.View taskDetailView,\n            @NonNull GetTask getTask,\n            @NonNull CompleteTask completeTask,\n            @NonNull ActivateTask activateTask,\n            @NonNull DeleteTask deleteTask) {\n        mTaskId = taskId;\n        // 这些判空也是尽早发现问题的思想\n        mUseCaseHandler = checkNotNull(useCaseHandler, \"useCaseHandler cannot be null!\");\n        mTaskDetailView = checkNotNull(taskDetailView, \"taskDetailView cannot be null!\");\n        mGetTask = checkNotNull(getTask, \"getTask cannot be null!\");\n        mCompleteTask = checkNotNull(completeTask, \"completeTask cannot be null!\");\n        mActivateTask = checkNotNull(activateTask, \"activateTask cannot be null!\");\n        mDeleteTask = checkNotNull(deleteTask, \"deleteTask cannot be null!\");\n        mTaskDetailView.setPresenter(this);\n    }\n\n    // 抽象了一下，几乎所有的Presenter都有启动的那一刻，启动后可能是获取数据（绝大多数），或者其他操作。\n    @Override\n    public void start() {\n        openTask();\n    }\n    // 这个很有意思，把Fragment的onActivityResult的值直接传递到Presenter中处理\n    @Override\n    public void result(int requestCode, int resultCode) {\n        // If a task was successfully added, show snackbar\n        if (AddEditTaskActivity.REQUEST_ADD_TASK == requestCode\n                && Activity.RESULT_OK == resultCode) {\n            mTasksView.showSuccessfullySavedMessage();\n        }\n    }\n\n    private void openTask() {\n    // 这里是输入的异常处理，越早越好，不要向下传再抛回来\n        if (mTaskId == null || mTaskId.isEmpty()) {\n            mTaskDetailView.showMissingTask();\n            return;\n        }\n\n        mTaskDetailView.setLoadingIndicator(true);\n\n        mUseCaseHandler.execute(mGetTask, new GetTask.RequestValues(mTaskId),\n                new UseCase.UseCaseCallback<GetTask.ResponseValue>() {\n                    @Override\n                    public void onSuccess(GetTask.ResponseValue response) {\n                        Task task = response.getTask();\n\n                        // The view may not be able to handle UI updates anymore\n                        if (!mTaskDetailView.isActive()) {\n                            return;\n                        }\n                        mTaskDetailView.setLoadingIndicator(false);\n                        if (null == task) {\n                            mTaskDetailView.showMissingTask();\n                        } else {\n                            showTask(task);\n                        }\n                    }\n\n                    @Override\n                    public void onError() {\n                        // The view may not be able to handle UI updates anymore\n                        if (!mTaskDetailView.isActive()) {\n                            return;\n                        }\n                        mTaskDetailView.showMissingTask();\n                    }\n                });\n    }\n\n    // 这些暴露的接口都是以用户动作触发为单位的！\n    @Override\n    public void editTask() {\n    // 这里是输入的异常处理，越早越好，不要向下传再抛回来\n        if (mTaskId == null || mTaskId.isEmpty()) {\n            mTaskDetailView.showMissingTask();\n            return;\n        }\n        mTaskDetailView.showEditTask(mTaskId);\n    }\n\n    @Override\n    public void deleteTask() {\n        mUseCaseHandler.execute(mDeleteTask, new DeleteTask.RequestValues(mTaskId),\n                new UseCase.UseCaseCallback<DeleteTask.ResponseValue>() {\n                    @Override\n                    public void onSuccess(DeleteTask.ResponseValue response) {\n                        mTaskDetailView.showTaskDeleted();\n                    }\n\n                    @Override\n                    public void onError() {\n                        // Show error, log, etc.\n                    }\n                });\n    }\n// 这些暴露的接口都是以用户动作触发为单位的！\n    @Override\n    public void completeTask() {\n        if (mTaskId == null || mTaskId.isEmpty()) {\n            mTaskDetailView.showMissingTask();\n            return;\n        }\n\n        mUseCaseHandler.execute(mCompleteTask, new CompleteTask.RequestValues(mTaskId),\n                new UseCase.UseCaseCallback<CompleteTask.ResponseValue>() {\n                    @Override\n                    public void onSuccess(CompleteTask.ResponseValue response) {\n                        mTaskDetailView.showTaskMarkedComplete();\n                    }\n\n                    @Override\n                    public void onError() {\n                        // Show error, log, etc.\n                    }\n                });\n    }\n// 这些暴露的接口都是以用户动作触发为单位的！\n    @Override\n    public void activateTask() {\n        if (mTaskId == null || mTaskId.isEmpty()) {\n            mTaskDetailView.showMissingTask();\n            return;\n        }\n        mUseCaseHandler.execute(mActivateTask, new ActivateTask.RequestValues(mTaskId),\n                new UseCase.UseCaseCallback<ActivateTask.ResponseValue>() {\n                    @Override\n                    public void onSuccess(ActivateTask.ResponseValue response) {\n                        mTaskDetailView.showTaskMarkedActive();\n                    }\n\n                    @Override\n                    public void onError() {\n                        // Show error, log, etc.\n                    }\n                });\n    }\n\n    private void showTask(Task task) {\n        String title = task.getTitle();\n        String description = task.getDescription();\n\n        if (title != null && title.isEmpty()) {\n            mTaskDetailView.hideTitle();\n        } else {\n            mTaskDetailView.showTitle(title);\n        }\n\n        if (description != null && description.isEmpty()) {\n            mTaskDetailView.hideDescription();\n        } else {\n            mTaskDetailView.showDescription(description);\n        }\n        mTaskDetailView.showCompletionStatus(task.isCompleted());\n    }\n    \n    // 这两个方法比较特别，是Avtivity保存与恢复数据使用的，不是用户操作\n    @Override\n    public void setFiltering(TasksFilterType requestType) {\n        mCurrentFiltering = requestType;\n    }\n\n    @Override\n    public TasksFilterType getFiltering() {\n        return mCurrentFiltering;\n    }\n}\n\n\t```\n\n\n\n4. Contract--接口定义\n   这个类是demo的特色，把一个业务的**展现层与领域层之间的接口**归类到一个类中十分清晰\n\t* View层的操作（往往由用户触发）\n\t\t* 编辑\n\t\t* 添加\n\t\t* 删除\n\t\t* 点击\n\t\t* 下拉。。。\n\t* View的生命周期映射、抽象\n\t\t* onResume -- `void start()`\n\t\t* onPause \n\t\t* onDestroy。。。\n\t\t* **`void result(int requestCode, int resultCode);`**\n\t* 数据存储恢复（这个demo是Activity使用）\n\t\t*  onSaveInstance -- `void setFiltering(TasksFilterType requestType);`\n\t\t*  onRestoreInstance -- `TasksFilterType getFiltering();`\n\n```java\npublic interface AddEditTaskContract {\n// view层接口,从extends BaseView<Presenter> 就看出来依赖\n    interface View extends BaseView<Presenter> {\n\n        void showEmptyTaskError();\n\n        void showTasksList();\n\n        void setTitle(String title);\n\n        void setDescription(String description);\n\n        boolean isActive();\n    }\n// presenter接口\n    interface Presenter extends BasePresenter {\n\n        void saveTask(String title, String description);\n\n        void populateTask();\n    }\n}\n\n```\n\n## 领域(Domain)层--UseCase\n调用领域层的代码都是在展现层的Presenter类中。\n\n### UseCase的外部特点：\n\n* 独立性，可复用，一个业务定义的UseCase可以被其他业务单独使用\n\n> 实例：`TaskDetailPresenter`与`TasksPresenter `都使用了`CompleteTask `\n\n* 命名直观，表示其功能\n* **一个UseCase外而言只执行一个任务**，既一个request一个reponse，没有多个方法暴露\n* Presentation层的调用者使用[命令模式]()执行UseCase\n\t* 单独运行一个UseCase\n\t* 组合运行多个UseCase：嵌套调用\n\n\n* 使用命令模式 一个执行器参考`UseCaseHandler`，参数是UseCase（命令），Request（输入参数）与Response（输出结果）。**UseCaseHandler也是在Activty中构造传入Presenter的。**\n* **注意传参的方式**，Request与Response都是定义在UseCase中的内部类，用它们来包裹传递的值，不是使用`new xxxUseCase(param1,param2).execute(callback)`的样式，或者`new xxxUseCase().execute(param1,param2,callback)`\n\n\n\n实例代码如下\n\t\n```java\n\tpublic void clearCompletedTasks() {\n        mUseCaseHandler.execute(mClearCompleteTasks, new ClearCompleteTasks.RequestValues(),\n                new UseCase.UseCaseCallback<ClearCompleteTasks.ResponseValue>() {\n                    @Override\n                    public void onSuccess(ClearCompleteTasks.ResponseValue response) {\n                        mTasksView.showCompletedTasksCleared();\n                        loadTasks(false, false);\n                    }\n\n                    @Override\n                    public void onError() {\n                        mTasksView.showLoadingTasksError();\n                    }\n                });\n    }\n```\n\n### UseCase的内部实现\n* **UseCase内部没有调用其他UseCase，组合由Presenter完成**，UseCase之间不可以互相调用？？？\n\n> demo中是这样的，实际开发中有这个需求吗？还是合理划分UseCase就可以了？，尤其是一个UseCase只有执行一个execute，如果一个复杂的UseCase有多个可以复用的任务组成，难道逻辑放到Presenter中？虽然理论上移动端不应该有如此复杂的业务逻辑。展示逻辑（如分页）在Presenter中没有问题。\n\n* UseCase内部的`executeUseCase()`覆写，实现真正的业务逻辑。\n* 内部类定义Request与Reponse，包裹传递的实体。\n* **没有在UseCase内的变量缓存数据**\n* 执行器executeUseCase默认在在非UI线程执行UseCase，但是CallBack会回到UI线程，参考`UseCaseHandler.java`\n\n```java\n// UseCase泛型参数就是命令模式的几个参数\npublic class GetTasks extends UseCase<GetTasks.RequestValues, GetTasks.ResponseValue> {\n\n\t// 注意：无变量缓存\n    private final TasksRepository mTasksRepository;\n\n    private final FilterFactory mFilterFactory;\n\n\t\n    public GetTasks(@NonNull TasksRepository tasksRepository, @NonNull FilterFactory filterFactory) {\n        mTasksRepository = checkNotNull(tasksRepository, \"tasksRepository cannot be null!\");\n        mFilterFactory = checkNotNull(filterFactory, \"filterFactory cannot be null!\");\n    }\n\n    @Override\n    protected void executeUseCase(final RequestValues values) {\n        if (values.isForceUpdate()) {\n            mTasksRepository.refreshTasks();\n        }\n\n        mTasksRepository.getTasks(new TasksDataSource.LoadTasksCallback() {\n            @Override\n            public void onTasksLoaded(List<Task> tasks) {\n            // 纯的业务逻辑，每一次都从数据仓库重新获取过滤\n                TasksFilterType currentFiltering = values.getCurrentFiltering();\n                TaskFilter taskFilter = mFilterFactory.create(currentFiltering);\n\n                List<Task> tasksFiltered = taskFilter.filter(tasks);\n                ResponseValue responseValue = new ResponseValue(tasksFiltered);\n                // 这种通知方式getUseCaseCallback的被封装了\n                getUseCaseCallback().onSuccess(responseValue);\n            }\n\n            @Override\n            public void onDataNotAvailable() {\n             // 这种通知方式getUseCaseCallback的被封装了\n                getUseCaseCallback().onError();\n            }\n        });\n\n    }\n\t// 注意这两个类UseCase.RequestValues与UseCase.ResponseValue是空的接口，子类设计也是比较自由的\n    public static final class RequestValues implements UseCase.RequestValues {\n\n        private final TasksFilterType mCurrentFiltering;\n        private final boolean mForceUpdate;\n\n        public RequestValues(boolean forceUpdate, @NonNull TasksFilterType currentFiltering) {\n            mForceUpdate = forceUpdate;\n            mCurrentFiltering = checkNotNull(currentFiltering, \"currentFiltering cannot be null!\");\n        }\n\n        public boolean isForceUpdate() {\n            return mForceUpdate;\n        }\n\n        public TasksFilterType getCurrentFiltering() {\n            return mCurrentFiltering;\n        }\n    }\n\n    public static final class ResponseValue implements UseCase.ResponseValue {\n\n        private final List<Task> mTasks;\n\n        public ResponseValue(@NonNull List<Task> tasks) {\n            mTasks = checkNotNull(tasks, \"tasks cannot be null!\");\n        }\n\n        public List<Task> getTasks() {\n            return mTasks;\n        }\n    }\n}\n\n```\n\n## 数据(Data)层--Repository模式\n领域层从数据仓库获取接口，\n### Repository的外部特点\n* 领域层直接持有数据层的类`TasksRepository`而非`TasksDataSource`接口。\n\n> 虽然持有TasksRepository，不影响测试（本质上它就是个门面，如果测试在注入时替换内部Source就行，参考下面代码），但是很奇怪。我觉得持有TasksDataSource没有问题，可能是TasksRepository语意更清晰。\n\n* 单例设计，很好理解\n* **有同步方法，也有异步方法**。但是没必要用异步的，同步即可。TasksDataSource中有一些异步的Callback接口，README中都说了没有必要。。。\n\n* 接口中的方法定义与存储的数据相关，如添加一个todo任务，删除一个todo任务，获取所有的todo任务\n\n### Repository的内部实现\n* **内部有缓存**，单仅仅是原始数据缓存，使用HashMap实现，比较简单。\n* Repository模式类似与装饰模式，`TasksRepository`暴露的接口只负责获取到数据，而不论数据的来源是哪里（可能是内存，网络，数据库）\n* `TasksRepository`的内部设计会引用多个来源TasksDataSource，他们也都实现了`TasksRepository`接口。如果需要测试，直接用fake的TasksDataSource替代真实的source即可。\n\n```java\n// 注意接口设计TasksDataSource与下面mTasksRemoteDataSource等相同\npublic class TasksRepository implements TasksDataSource {\n\n    private static TasksRepository INSTANCE = null;\n\n    private final TasksDataSource mTasksRemoteDataSource;\n\n    private final TasksDataSource mTasksLocalDataSource;\n\n    // 缓存\n    Map<String, Task> mCachedTasks;\n\t// 缓存 数据脏了\n    boolean mCacheIsDirty = false;\n\n    // Prevent direct instantiation.\n    private TasksRepository(@NonNull TasksDataSource tasksRemoteDataSource,\n                            @NonNull TasksDataSource tasksLocalDataSource) {\n        mTasksRemoteDataSource = checkNotNull(tasksRemoteDataSource);\n        mTasksLocalDataSource = checkNotNull(tasksLocalDataSource);\n    }\n\n\t// 这里有些特殊：getInstance的参数是source，RemoteDataSource与LocalDataSource可以替换成fake的source\n\t// 注意：缓存是内置的，没有用外面的\n    public static TasksRepository getInstance(TasksDataSource tasksRemoteDataSource,\n                                              TasksDataSource tasksLocalDataSource) {\n        if (INSTANCE == null) {\n            INSTANCE = new TasksRepository(tasksRemoteDataSource, tasksLocalDataSource);\n        }\n        return INSTANCE;\n    }\n\n\n    public static void destroyInstance() {\n        INSTANCE = null;\n    }\n\n\n\t// 数据获取逻辑，可能是从任何地方获取的数据\n    @Override\n    public void getTasks(@NonNull final LoadTasksCallback callback) {\n        checkNotNull(callback);\n\n        // Respond immediately with cache if available and not dirty\n        if (mCachedTasks != null && !mCacheIsDirty) {\n            callback.onTasksLoaded(new ArrayList<>(mCachedTasks.values()));\n            return;\n        }\n\n        if (mCacheIsDirty) {\n            // If the cache is dirty we need to fetch new data from the network.\n            getTasksFromRemoteDataSource(callback);\n        } else {\n            // Query the local storage if available. If not, query the network.\n            mTasksLocalDataSource.getTasks(new LoadTasksCallback() {\n                @Override\n                public void onTasksLoaded(List<Task> tasks) {\n                    refreshCache(tasks);\n                    callback.onTasksLoaded(new ArrayList<>(mCachedTasks.values()));\n                }\n\n                @Override\n                public void onDataNotAvailable() {\n                    getTasksFromRemoteDataSource(callback);\n                }\n            });\n        }\n    }\n\n    @Override\n    public void saveTask(@NonNull Task task) {\n        checkNotNull(task);\n        mTasksRemoteDataSource.saveTask(task);\n        mTasksLocalDataSource.saveTask(task);\n\n        // Do in memory cache update to keep the app UI up to date\n        if (mCachedTasks == null) {\n            mCachedTasks = new LinkedHashMap<>();\n        }\n        mCachedTasks.put(task.getId(), task);\n    }\n}\n```\n\n## 数据实体\n三层的数据Entity与Clean原文中不同\n特点：\n\n * 公用，**三层通用了一个数据Model**--Task。减少了Clean构架的三层数据模型之间的转换\n\n## 总结\n仅仅讨论Demo的不完善的地方：\n\n* 没有考虑P层的Presenter的保持\n* Domain层没有负责的业务逻辑，没有多UseCase相互调用的例子\n* Domain数据处理简单没有性能问题。没有缓存\n* 没有Notify机制的示例。都是一个request一个reponse的简单请求。\n\n优点：\n\n* Activty与Fragment职责明确\n* Contract设计\n* 轻客户端思想，Domain尽量简单（与上面对应，哈哈）\n* UseCase的简单设计思想，使得UseCese可以在其他模块复用（参考GetTasks用例）\n* Domain的命令模式，设计可以参考\n* 数据仓库的设计（缓存和多Source思想）\n\n\n争论：\n\n* StatisticsPresenter中的统计逻辑位置是否有问题？在主线程？为什么不用一个UseCase？","slug":"Android构架系列之二-MVP&&Clean理解与实践之实例分析","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbcb000inac9f04oio5q","content":"<p>前面我们分析了MVP与Clean，本文试图以<a href=\"https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean\" target=\"_blank\" rel=\"external\">Google构架Demo的Clean分支</a>为样本来分析一下具体的代码实现。由于Clean包含了MVP部分，所以MVP的部分一并说明。<br>需要强调的是这并不是Clean构架的唯一实现方式，但是其思想可以借鉴。</p>\n<h2 id=\"总体结构\"><a href=\"#总体结构\" class=\"headerlink\" title=\"总体结构\"></a>总体结构</h2><p><img src=\"https://github.com/googlesamples/android-architecture/wiki/images/mvp-clean.png\" alt=\"Diagram\"><br>分为三部分：</p>\n<ul>\n<li>展现(Presentation)层: 核心是<strong>MVP</strong> ，做UI控制。</li>\n<li>领域(Domain)层: 核心是<strong>UseCase</strong> 这一层是所有的业务逻辑，这一层的类都叫做<code>xxxUseCase</code>或者<code>xxxInteractor</code>（在这个Demo中都是UseCase的子类，命名都是以业务相关的动名词的形式，如GetTasks），代表了在Presentation层开发者可以执行的所有Action。</li>\n<li>数据(Data)层: 核心是<strong>Repository</strong>，是使用数据仓库模式。</li>\n</ul>\n<h2 id=\"展现-Presentation-层–MVP\"><a href=\"#展现-Presentation-层–MVP\" class=\"headerlink\" title=\"展现(Presentation)层–MVP\"></a>展现(Presentation)层–MVP</h2><p>由以下几部分组成</p>\n<ol>\n<li><p>Activity: <strong>组合View(Fragemnt)与Presenter</strong>，Activity不是View！Activity的<code>OnCreate</code>中完成3件事情。</p>\n<ul>\n<li>构建View，这里都是Fragment。</li>\n<li><p><strong>生成所有Presenter用到的的UseCase</strong>，UseCase用的UseCaseHandler,Repository：目的是方便修改注入，用Provider的方式代替注入框架，全部在Activity中注入完成，如果使用Dagger等注入框架，这里不必要。</p>\n<blockquote>\n<p>请对比学习</p>\n</blockquote>\n</li>\n<li><p>生成Presenter并<strong>双向绑定</strong>：注意参数：注入刚才的View，和用到的所有UserCase.</p>\n</li>\n<li><p><strong>Presenter的状态恢复</strong>，在Activity重建时，都是重新构建Presenter，并且只恢复Presenter中某些数据的状态。（这一步可选，只恢复使用的数据，大部分情况下并没有恢复数据，重新构建Presenter。这里的实现简单粗暴，也可以用Fragment来保持Presenter，关于Presenter的恢复问题MVP一节中有讨论）</p>\n<p>Activity的OnCreate中代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 生成View</span></div><div class=\"line\">       TasksFragment tasksFragment =</div><div class=\"line\">               (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</div><div class=\"line\">       <span class=\"keyword\">if</span> (tasksFragment == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"comment\">// Create the fragment</span></div><div class=\"line\">           tasksFragment = TasksFragment.newInstance();</div><div class=\"line\">           ActivityUtils.addFragmentToActivity(</div><div class=\"line\">                   getSupportFragmentManager(), tasksFragment, R.id.contentFrame);</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 生成Presenter，注意参数传入了上面生成的View和用到的UseCase</span></div><div class=\"line\"><span class=\"comment\">// 注意：在Presenter的构造函数内部会调用View的setPresenter实现双向绑定</span></div><div class=\"line\">   mTasksPresenter = <span class=\"keyword\">new</span> TasksPresenter(</div><div class=\"line\">               Injection.provideUseCaseHandler(),</div><div class=\"line\">               tasksFragment,</div><div class=\"line\">               Injection.provideGetTasks(getApplicationContext()),</div><div class=\"line\">               Injection.provideCompleteTasks(getApplicationContext()),</div><div class=\"line\">               Injection.provideActivateTask(getApplicationContext()),</div><div class=\"line\">               Injection.provideClearCompleteTasks(getApplicationContext())</div><div class=\"line\">               );</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Presenter状态恢复</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (savedInstanceState != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           TasksFilterType currentFiltering =</div><div class=\"line\">                   (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY);</div><div class=\"line\">           mTasksPresenter.setFiltering(currentFiltering);</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Fragment：代表View，与其他的View作用相同</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TasksFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> <span class=\"keyword\">implements</span> <span class=\"title\">TasksContract</span>.<span class=\"title\">View</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TasksFragment</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Requires empty public constructor</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> TasksFragment <span class=\"title\">newInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    \t<span class=\"comment\">// 构建Fragment的最佳实践，可以setArgument等</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TasksFragment();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        mListAdapter = <span class=\"keyword\">new</span> TasksAdapter(<span class=\"keyword\">new</span> ArrayList&lt;Task&gt;(<span class=\"number\">0</span>), mItemListener);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// Presenter一般都会实现以下通用的方法</span></div><div class=\"line\">        mPresenter.start();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 双向绑定时，给Presenter使用的</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPresenter</span><span class=\"params\">(@NonNull TasksContract.Presenter presenter)</span> </span>&#123;</div><div class=\"line\">        mPresenter = checkNotNull(presenter);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class=\"line\">    \t <span class=\"comment\">// 一些回调交给Presenter处理</span></div><div class=\"line\">        mPresenter.result(requestCode, resultCode);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Nullable</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container,</span></span></div><div class=\"line\">                             Bundle savedInstanceState) &#123;</div><div class=\"line\">        View root = inflater.inflate(R.layout.addtask_frag, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">        <span class=\"comment\">// 这个看情况，界面中有无需要保持的数据（如一些用户输入的信息）。</span></div><div class=\"line\">        <span class=\"comment\">// 由于这里没有使用Fragemnt来保持Presenter，这个也可以不加</span></div><div class=\"line\">        <span class=\"comment\">// setRetainInstance(true);</span></div><div class=\"line\">        <span class=\"keyword\">return</span> root;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 其他的View接口的方法实现，给Presenter使用</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showTasksList</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        getActivity().setResult(Activity.RESULT_OK);</div><div class=\"line\">        getActivity().finish();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 从上述代码中，我们可以得到几点信息：</p>\n<ul>\n<li>在View的生命周期中调用对应的Presenter方法。</li>\n<li><strong>View与Presenter的绑定时机</strong>：这里的View(Fragment)比较被动，通过在Presenter的构造函数中调用View接口的setPresnter方法注入Presenter，实现双向绑定。    </li>\n<li><p>Fragment没有履行Presenter保持的职责，他只负责保持界面的数据（如果有必要，参考<code>AddEditTaskFragment.java</code>）。</p>\n<blockquote>\n<p>之所以这样，一部分原因是由Activity来管理数据恢复这些事情，职责清晰。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>Presenter类<br>特点如下</p>\n<ul>\n<li>实现了xxxContract.Presenter接口，包括该接口的父接口BasePresenter中定义的生命周期映射（只有<code>void start()</code>方法一般在View的<code>onResume()</code>中调用）。</li>\n<li>暴露了的接口要明确。大部分暴露的接口都是View使用的操作（由用户行为触发）与Activity用到的功能（数据保持恢复型操作）。<strong>如何定义，定义什么接口具体查看Contract</strong></li>\n<li>构造函数中与Fragment绑定，setPresenter</li>\n<li>一个Presenter中<strong>含有多个UseCase</strong></li>\n<li>一个对外接口可以单独运行一个UseCase或者<strong>组合运行多个UseCase，嵌套调用。</strong></li>\n<li>可能有<code>public void result(int requestCode, int resultCode)</code>接口，映射了Fragment(不是Activity）的onActivityResult方法，处理回调。</li>\n<li>额外的还有数据获取与恢复接口给Activity调用</li>\n<li><p>接口中对View传来的<strong>原始数据</strong>进行处理。如判空等，在Presenter中，如果是null，直接调用View告知用户。而不是把这些值向下传入Domain层。<strong>原则：异常输入越早处理约好</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskDetailPresenter</span> <span class=\"keyword\">implements</span> <span class=\"title\">TaskDetailContract</span>.<span class=\"title\">Presenter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TaskDetailContract.View mTaskDetailView;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> UseCaseHandler mUseCaseHandler;</div><div class=\"line\">    <span class=\"comment\">// 含有多个UseCase</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> GetTask mGetTask;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CompleteTask mCompleteTask;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ActivateTask mActivateTask;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DeleteTask mDeleteTask;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Nullable</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String mTaskId;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskDetailPresenter</span><span class=\"params\">(@NonNull UseCaseHandler useCaseHandler,</span></span></div><div class=\"line\">            @Nullable String taskId,</div><div class=\"line\">            @NonNull TaskDetailContract.View taskDetailView,</div><div class=\"line\">            @NonNull GetTask getTask,</div><div class=\"line\">            @NonNull CompleteTask completeTask,</div><div class=\"line\">            @NonNull ActivateTask activateTask,</div><div class=\"line\">            @NonNull DeleteTask deleteTask) &#123;</div><div class=\"line\">        mTaskId = taskId;</div><div class=\"line\">        <span class=\"comment\">// 这些判空也是尽早发现问题的思想</span></div><div class=\"line\">        mUseCaseHandler = checkNotNull(useCaseHandler, <span class=\"string\">\"useCaseHandler cannot be null!\"</span>);</div><div class=\"line\">        mTaskDetailView = checkNotNull(taskDetailView, <span class=\"string\">\"taskDetailView cannot be null!\"</span>);</div><div class=\"line\">        mGetTask = checkNotNull(getTask, <span class=\"string\">\"getTask cannot be null!\"</span>);</div><div class=\"line\">        mCompleteTask = checkNotNull(completeTask, <span class=\"string\">\"completeTask cannot be null!\"</span>);</div><div class=\"line\">        mActivateTask = checkNotNull(activateTask, <span class=\"string\">\"activateTask cannot be null!\"</span>);</div><div class=\"line\">        mDeleteTask = checkNotNull(deleteTask, <span class=\"string\">\"deleteTask cannot be null!\"</span>);</div><div class=\"line\">        mTaskDetailView.setPresenter(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 抽象了一下，几乎所有的Presenter都有启动的那一刻，启动后可能是获取数据（绝大多数），或者其他操作。</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        openTask();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 这个很有意思，把Fragment的onActivityResult的值直接传递到Presenter中处理</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">result</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// If a task was successfully added, show snackbar</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (AddEditTaskActivity.REQUEST_ADD_TASK == requestCode</div><div class=\"line\">                &amp;&amp; Activity.RESULT_OK == resultCode) &#123;</div><div class=\"line\">            mTasksView.showSuccessfullySavedMessage();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">openTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里是输入的异常处理，越早越好，不要向下传再抛回来</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mTaskId == <span class=\"keyword\">null</span> || mTaskId.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.showMissingTask();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mTaskDetailView.setLoadingIndicator(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">        mUseCaseHandler.execute(mGetTask, <span class=\"keyword\">new</span> GetTask.RequestValues(mTaskId),</div><div class=\"line\">                <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;GetTask.ResponseValue&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(GetTask.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                        Task task = response.getTask();</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"comment\">// The view may not be able to handle UI updates anymore</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (!mTaskDetailView.isActive()) &#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        mTaskDetailView.setLoadingIndicator(<span class=\"keyword\">false</span>);</div><div class=\"line\">                        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == task) &#123;</div><div class=\"line\">                            mTaskDetailView.showMissingTask();</div><div class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                            showTask(task);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// The view may not be able to handle UI updates anymore</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (!mTaskDetailView.isActive()) &#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        mTaskDetailView.showMissingTask();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这些暴露的接口都是以用户动作触发为单位的！</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">editTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里是输入的异常处理，越早越好，不要向下传再抛回来</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mTaskId == <span class=\"keyword\">null</span> || mTaskId.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.showMissingTask();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mTaskDetailView.showEditTask(mTaskId);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        mUseCaseHandler.execute(mDeleteTask, <span class=\"keyword\">new</span> DeleteTask.RequestValues(mTaskId),</div><div class=\"line\">                <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;DeleteTask.ResponseValue&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(DeleteTask.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                        mTaskDetailView.showTaskDeleted();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// Show error, log, etc.</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">// 这些暴露的接口都是以用户动作触发为单位的！</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">completeTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mTaskId == <span class=\"keyword\">null</span> || mTaskId.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.showMissingTask();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mUseCaseHandler.execute(mCompleteTask, <span class=\"keyword\">new</span> CompleteTask.RequestValues(mTaskId),</div><div class=\"line\">                <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;CompleteTask.ResponseValue&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(CompleteTask.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                        mTaskDetailView.showTaskMarkedComplete();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// Show error, log, etc.</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">// 这些暴露的接口都是以用户动作触发为单位的！</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">activateTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mTaskId == <span class=\"keyword\">null</span> || mTaskId.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.showMissingTask();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mUseCaseHandler.execute(mActivateTask, <span class=\"keyword\">new</span> ActivateTask.RequestValues(mTaskId),</div><div class=\"line\">                <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;ActivateTask.ResponseValue&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(ActivateTask.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                        mTaskDetailView.showTaskMarkedActive();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// Show error, log, etc.</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">showTask</span><span class=\"params\">(Task task)</span> </span>&#123;</div><div class=\"line\">        String title = task.getTitle();</div><div class=\"line\">        String description = task.getDescription();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (title != <span class=\"keyword\">null</span> &amp;&amp; title.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.hideTitle();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mTaskDetailView.showTitle(title);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (description != <span class=\"keyword\">null</span> &amp;&amp; description.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.hideDescription();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mTaskDetailView.showDescription(description);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mTaskDetailView.showCompletionStatus(task.isCompleted());</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 这两个方法比较特别，是Avtivity保存与恢复数据使用的，不是用户操作</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFiltering</span><span class=\"params\">(TasksFilterType requestType)</span> </span>&#123;</div><div class=\"line\">        mCurrentFiltering = requestType;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TasksFilterType <span class=\"title\">getFiltering</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> mCurrentFiltering;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Contract–接口定义<br>这个类是demo的特色，把一个业务的<strong>展现层与领域层之间的接口</strong>归类到一个类中十分清晰</p>\n<ul>\n<li>View层的操作（往往由用户触发）<ul>\n<li>编辑</li>\n<li>添加</li>\n<li>删除</li>\n<li>点击</li>\n<li>下拉。。。</li>\n</ul>\n</li>\n<li>View的生命周期映射、抽象<ul>\n<li>onResume – <code>void start()</code></li>\n<li>onPause </li>\n<li>onDestroy。。。</li>\n<li><strong><code>void result(int requestCode, int resultCode);</code></strong></li>\n</ul>\n</li>\n<li>数据存储恢复（这个demo是Activity使用）<ul>\n<li>onSaveInstance – <code>void setFiltering(TasksFilterType requestType);</code></li>\n<li>onRestoreInstance – <code>TasksFilterType getFiltering();</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AddEditTaskContract</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">// view层接口,从extends BaseView&lt;Presenter&gt; 就看出来依赖</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">View</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseView</span>&lt;<span class=\"title\">Presenter</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showEmptyTaskError</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showTasksList</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setTitle</span><span class=\"params\">(String title)</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDescription</span><span class=\"params\">(String description)</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isActive</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">// presenter接口</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Presenter</span> <span class=\"keyword\">extends</span> <span class=\"title\">BasePresenter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">saveTask</span><span class=\"params\">(String title, String description)</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">populateTask</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"领域-Domain-层–UseCase\"><a href=\"#领域-Domain-层–UseCase\" class=\"headerlink\" title=\"领域(Domain)层–UseCase\"></a>领域(Domain)层–UseCase</h2><p>调用领域层的代码都是在展现层的Presenter类中。</p>\n<h3 id=\"UseCase的外部特点：\"><a href=\"#UseCase的外部特点：\" class=\"headerlink\" title=\"UseCase的外部特点：\"></a>UseCase的外部特点：</h3><ul>\n<li>独立性，可复用，一个业务定义的UseCase可以被其他业务单独使用</li>\n</ul>\n<blockquote>\n<p>实例：<code>TaskDetailPresenter</code>与<code>TasksPresenter</code>都使用了<code>CompleteTask</code></p>\n</blockquote>\n<ul>\n<li>命名直观，表示其功能</li>\n<li><strong>一个UseCase外而言只执行一个任务</strong>，既一个request一个reponse，没有多个方法暴露</li>\n<li>Presentation层的调用者使用<a href=\"\">命令模式</a>执行UseCase<ul>\n<li>单独运行一个UseCase</li>\n<li>组合运行多个UseCase：嵌套调用</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>使用命令模式 一个执行器参考<code>UseCaseHandler</code>，参数是UseCase（命令），Request（输入参数）与Response（输出结果）。<strong>UseCaseHandler也是在Activty中构造传入Presenter的。</strong></li>\n<li><strong>注意传参的方式</strong>，Request与Response都是定义在UseCase中的内部类，用它们来包裹传递的值，不是使用<code>new xxxUseCase(param1,param2).execute(callback)</code>的样式，或者<code>new xxxUseCase().execute(param1,param2,callback)</code></li>\n</ul>\n<p>实例代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clearCompletedTasks</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       mUseCaseHandler.execute(mClearCompleteTasks, <span class=\"keyword\">new</span> ClearCompleteTasks.RequestValues(),</div><div class=\"line\">               <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;ClearCompleteTasks.ResponseValue&gt;() &#123;</div><div class=\"line\">                   <span class=\"meta\">@Override</span></div><div class=\"line\">                   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(ClearCompleteTasks.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                       mTasksView.showCompletedTasksCleared();</div><div class=\"line\">                       loadTasks(<span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">                   &#125;</div><div class=\"line\"></div><div class=\"line\">                   <span class=\"meta\">@Override</span></div><div class=\"line\">                   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                       mTasksView.showLoadingTasksError();</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"UseCase的内部实现\"><a href=\"#UseCase的内部实现\" class=\"headerlink\" title=\"UseCase的内部实现\"></a>UseCase的内部实现</h3><ul>\n<li><strong>UseCase内部没有调用其他UseCase，组合由Presenter完成</strong>，UseCase之间不可以互相调用？？？</li>\n</ul>\n<blockquote>\n<p>demo中是这样的，实际开发中有这个需求吗？还是合理划分UseCase就可以了？，尤其是一个UseCase只有执行一个execute，如果一个复杂的UseCase有多个可以复用的任务组成，难道逻辑放到Presenter中？虽然理论上移动端不应该有如此复杂的业务逻辑。展示逻辑（如分页）在Presenter中没有问题。</p>\n</blockquote>\n<ul>\n<li>UseCase内部的<code>executeUseCase()</code>覆写，实现真正的业务逻辑。</li>\n<li>内部类定义Request与Reponse，包裹传递的实体。</li>\n<li><strong>没有在UseCase内的变量缓存数据</strong></li>\n<li>执行器executeUseCase默认在在非UI线程执行UseCase，但是CallBack会回到UI线程，参考<code>UseCaseHandler.java</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// UseCase泛型参数就是命令模式的几个参数</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetTasks</span> <span class=\"keyword\">extends</span> <span class=\"title\">UseCase</span>&lt;<span class=\"title\">GetTasks</span>.<span class=\"title\">RequestValues</span>, <span class=\"title\">GetTasks</span>.<span class=\"title\">ResponseValue</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 注意：无变量缓存</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TasksRepository mTasksRepository;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FilterFactory mFilterFactory;</div><div class=\"line\"></div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GetTasks</span><span class=\"params\">(@NonNull TasksRepository tasksRepository, @NonNull FilterFactory filterFactory)</span> </span>&#123;</div><div class=\"line\">        mTasksRepository = checkNotNull(tasksRepository, <span class=\"string\">\"tasksRepository cannot be null!\"</span>);</div><div class=\"line\">        mFilterFactory = checkNotNull(filterFactory, <span class=\"string\">\"filterFactory cannot be null!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">executeUseCase</span><span class=\"params\">(<span class=\"keyword\">final</span> RequestValues values)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (values.isForceUpdate()) &#123;</div><div class=\"line\">            mTasksRepository.refreshTasks();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mTasksRepository.getTasks(<span class=\"keyword\">new</span> TasksDataSource.LoadTasksCallback() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onTasksLoaded</span><span class=\"params\">(List&lt;Task&gt; tasks)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 纯的业务逻辑，每一次都从数据仓库重新获取过滤</span></div><div class=\"line\">                TasksFilterType currentFiltering = values.getCurrentFiltering();</div><div class=\"line\">                TaskFilter taskFilter = mFilterFactory.create(currentFiltering);</div><div class=\"line\"></div><div class=\"line\">                List&lt;Task&gt; tasksFiltered = taskFilter.filter(tasks);</div><div class=\"line\">                ResponseValue responseValue = <span class=\"keyword\">new</span> ResponseValue(tasksFiltered);</div><div class=\"line\">                <span class=\"comment\">// 这种通知方式getUseCaseCallback的被封装了</span></div><div class=\"line\">                getUseCaseCallback().onSuccess(responseValue);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataNotAvailable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">             <span class=\"comment\">// 这种通知方式getUseCaseCallback的被封装了</span></div><div class=\"line\">                getUseCaseCallback().onError();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 注意这两个类UseCase.RequestValues与UseCase.ResponseValue是空的接口，子类设计也是比较自由的</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestValues</span> <span class=\"keyword\">implements</span> <span class=\"title\">UseCase</span>.<span class=\"title\">RequestValues</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TasksFilterType mCurrentFiltering;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mForceUpdate;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestValues</span><span class=\"params\">(<span class=\"keyword\">boolean</span> forceUpdate, @NonNull TasksFilterType currentFiltering)</span> </span>&#123;</div><div class=\"line\">            mForceUpdate = forceUpdate;</div><div class=\"line\">            mCurrentFiltering = checkNotNull(currentFiltering, <span class=\"string\">\"currentFiltering cannot be null!\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isForceUpdate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> mForceUpdate;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> TasksFilterType <span class=\"title\">getCurrentFiltering</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> mCurrentFiltering;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseValue</span> <span class=\"keyword\">implements</span> <span class=\"title\">UseCase</span>.<span class=\"title\">ResponseValue</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Task&gt; mTasks;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResponseValue</span><span class=\"params\">(@NonNull List&lt;Task&gt; tasks)</span> </span>&#123;</div><div class=\"line\">            mTasks = checkNotNull(tasks, <span class=\"string\">\"tasks cannot be null!\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Task&gt; <span class=\"title\">getTasks</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> mTasks;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"数据-Data-层–Repository模式\"><a href=\"#数据-Data-层–Repository模式\" class=\"headerlink\" title=\"数据(Data)层–Repository模式\"></a>数据(Data)层–Repository模式</h2><p>领域层从数据仓库获取接口，</p>\n<h3 id=\"Repository的外部特点\"><a href=\"#Repository的外部特点\" class=\"headerlink\" title=\"Repository的外部特点\"></a>Repository的外部特点</h3><ul>\n<li>领域层直接持有数据层的类<code>TasksRepository</code>而非<code>TasksDataSource</code>接口。</li>\n</ul>\n<blockquote>\n<p>虽然持有TasksRepository，不影响测试（本质上它就是个门面，如果测试在注入时替换内部Source就行，参考下面代码），但是很奇怪。我觉得持有TasksDataSource没有问题，可能是TasksRepository语意更清晰。</p>\n</blockquote>\n<ul>\n<li>单例设计，很好理解</li>\n<li><p><strong>有同步方法，也有异步方法</strong>。但是没必要用异步的，同步即可。TasksDataSource中有一些异步的Callback接口，README中都说了没有必要。。。</p>\n</li>\n<li><p>接口中的方法定义与存储的数据相关，如添加一个todo任务，删除一个todo任务，获取所有的todo任务</p>\n</li>\n</ul>\n<h3 id=\"Repository的内部实现\"><a href=\"#Repository的内部实现\" class=\"headerlink\" title=\"Repository的内部实现\"></a>Repository的内部实现</h3><ul>\n<li><strong>内部有缓存</strong>，单仅仅是原始数据缓存，使用HashMap实现，比较简单。</li>\n<li>Repository模式类似与装饰模式，<code>TasksRepository</code>暴露的接口只负责获取到数据，而不论数据的来源是哪里（可能是内存，网络，数据库）</li>\n<li><code>TasksRepository</code>的内部设计会引用多个来源TasksDataSource，他们也都实现了<code>TasksRepository</code>接口。如果需要测试，直接用fake的TasksDataSource替代真实的source即可。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注意接口设计TasksDataSource与下面mTasksRemoteDataSource等相同</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TasksRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">TasksDataSource</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TasksRepository INSTANCE = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TasksDataSource mTasksRemoteDataSource;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TasksDataSource mTasksLocalDataSource;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 缓存</span></div><div class=\"line\">    Map&lt;String, Task&gt; mCachedTasks;</div><div class=\"line\">\t<span class=\"comment\">// 缓存 数据脏了</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> mCacheIsDirty = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Prevent direct instantiation.</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">TasksRepository</span><span class=\"params\">(@NonNull TasksDataSource tasksRemoteDataSource,</span></span></div><div class=\"line\">                            @NonNull TasksDataSource tasksLocalDataSource) &#123;</div><div class=\"line\">        mTasksRemoteDataSource = checkNotNull(tasksRemoteDataSource);</div><div class=\"line\">        mTasksLocalDataSource = checkNotNull(tasksLocalDataSource);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 这里有些特殊：getInstance的参数是source，RemoteDataSource与LocalDataSource可以替换成fake的source</span></div><div class=\"line\">\t<span class=\"comment\">// 注意：缓存是内置的，没有用外面的</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> TasksRepository <span class=\"title\">getInstance</span><span class=\"params\">(TasksDataSource tasksRemoteDataSource,</span></span></div><div class=\"line\">                                              TasksDataSource tasksLocalDataSource) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            INSTANCE = <span class=\"keyword\">new</span> TasksRepository(tasksRemoteDataSource, tasksLocalDataSource);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">destroyInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        INSTANCE = <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 数据获取逻辑，可能是从任何地方获取的数据</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTasks</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> LoadTasksCallback callback)</span> </span>&#123;</div><div class=\"line\">        checkNotNull(callback);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Respond immediately with cache if available and not dirty</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mCachedTasks != <span class=\"keyword\">null</span> &amp;&amp; !mCacheIsDirty) &#123;</div><div class=\"line\">            callback.onTasksLoaded(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(mCachedTasks.values()));</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mCacheIsDirty) &#123;</div><div class=\"line\">            <span class=\"comment\">// If the cache is dirty we need to fetch new data from the network.</span></div><div class=\"line\">            getTasksFromRemoteDataSource(callback);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// Query the local storage if available. If not, query the network.</span></div><div class=\"line\">            mTasksLocalDataSource.getTasks(<span class=\"keyword\">new</span> LoadTasksCallback() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onTasksLoaded</span><span class=\"params\">(List&lt;Task&gt; tasks)</span> </span>&#123;</div><div class=\"line\">                    refreshCache(tasks);</div><div class=\"line\">                    callback.onTasksLoaded(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(mCachedTasks.values()));</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataNotAvailable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    getTasksFromRemoteDataSource(callback);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveTask</span><span class=\"params\">(@NonNull Task task)</span> </span>&#123;</div><div class=\"line\">        checkNotNull(task);</div><div class=\"line\">        mTasksRemoteDataSource.saveTask(task);</div><div class=\"line\">        mTasksLocalDataSource.saveTask(task);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Do in memory cache update to keep the app UI up to date</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mCachedTasks == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            mCachedTasks = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mCachedTasks.put(task.getId(), task);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"数据实体\"><a href=\"#数据实体\" class=\"headerlink\" title=\"数据实体\"></a>数据实体</h2><p>三层的数据Entity与Clean原文中不同<br>特点：</p>\n<ul>\n<li>公用，<strong>三层通用了一个数据Model</strong>–Task。减少了Clean构架的三层数据模型之间的转换</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>仅仅讨论Demo的不完善的地方：</p>\n<ul>\n<li>没有考虑P层的Presenter的保持</li>\n<li>Domain层没有负责的业务逻辑，没有多UseCase相互调用的例子</li>\n<li>Domain数据处理简单没有性能问题。没有缓存</li>\n<li>没有Notify机制的示例。都是一个request一个reponse的简单请求。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>Activty与Fragment职责明确</li>\n<li>Contract设计</li>\n<li>轻客户端思想，Domain尽量简单（与上面对应，哈哈）</li>\n<li>UseCase的简单设计思想，使得UseCese可以在其他模块复用（参考GetTasks用例）</li>\n<li>Domain的命令模式，设计可以参考</li>\n<li>数据仓库的设计（缓存和多Source思想）</li>\n</ul>\n<p>争论：</p>\n<ul>\n<li>StatisticsPresenter中的统计逻辑位置是否有问题？在主线程？为什么不用一个UseCase？</li>\n</ul>\n","excerpt":"","more":"<p>前面我们分析了MVP与Clean，本文试图以<a href=\"https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean\">Google构架Demo的Clean分支</a>为样本来分析一下具体的代码实现。由于Clean包含了MVP部分，所以MVP的部分一并说明。<br>需要强调的是这并不是Clean构架的唯一实现方式，但是其思想可以借鉴。</p>\n<h2 id=\"总体结构\"><a href=\"#总体结构\" class=\"headerlink\" title=\"总体结构\"></a>总体结构</h2><p><img src=\"https://github.com/googlesamples/android-architecture/wiki/images/mvp-clean.png\" alt=\"Diagram\"/><br>分为三部分：</p>\n<ul>\n<li>展现(Presentation)层: 核心是<strong>MVP</strong> ，做UI控制。</li>\n<li>领域(Domain)层: 核心是<strong>UseCase</strong> 这一层是所有的业务逻辑，这一层的类都叫做<code>xxxUseCase</code>或者<code>xxxInteractor</code>（在这个Demo中都是UseCase的子类，命名都是以业务相关的动名词的形式，如GetTasks），代表了在Presentation层开发者可以执行的所有Action。</li>\n<li>数据(Data)层: 核心是<strong>Repository</strong>，是使用数据仓库模式。</li>\n</ul>\n<h2 id=\"展现-Presentation-层–MVP\"><a href=\"#展现-Presentation-层–MVP\" class=\"headerlink\" title=\"展现(Presentation)层–MVP\"></a>展现(Presentation)层–MVP</h2><p>由以下几部分组成</p>\n<ol>\n<li><p>Activity: <strong>组合View(Fragemnt)与Presenter</strong>，Activity不是View！Activity的<code>OnCreate</code>中完成3件事情。</p>\n<ul>\n<li>构建View，这里都是Fragment。</li>\n<li><p><strong>生成所有Presenter用到的的UseCase</strong>，UseCase用的UseCaseHandler,Repository：目的是方便修改注入，用Provider的方式代替注入框架，全部在Activity中注入完成，如果使用Dagger等注入框架，这里不必要。</p>\n<blockquote>\n<p>请对比学习</p>\n</blockquote>\n</li>\n<li><p>生成Presenter并<strong>双向绑定</strong>：注意参数：注入刚才的View，和用到的所有UserCase.</p>\n</li>\n<li><p><strong>Presenter的状态恢复</strong>，在Activity重建时，都是重新构建Presenter，并且只恢复Presenter中某些数据的状态。（这一步可选，只恢复使用的数据，大部分情况下并没有恢复数据，重新构建Presenter。这里的实现简单粗暴，也可以用Fragment来保持Presenter，关于Presenter的恢复问题MVP一节中有讨论）</p>\n<p>Activity的OnCreate中代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 生成View</span></div><div class=\"line\">       TasksFragment tasksFragment =</div><div class=\"line\">               (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</div><div class=\"line\">       <span class=\"keyword\">if</span> (tasksFragment == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"comment\">// Create the fragment</span></div><div class=\"line\">           tasksFragment = TasksFragment.newInstance();</div><div class=\"line\">           ActivityUtils.addFragmentToActivity(</div><div class=\"line\">                   getSupportFragmentManager(), tasksFragment, R.id.contentFrame);</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 生成Presenter，注意参数传入了上面生成的View和用到的UseCase</span></div><div class=\"line\"><span class=\"comment\">// 注意：在Presenter的构造函数内部会调用View的setPresenter实现双向绑定</span></div><div class=\"line\">   mTasksPresenter = <span class=\"keyword\">new</span> TasksPresenter(</div><div class=\"line\">               Injection.provideUseCaseHandler(),</div><div class=\"line\">               tasksFragment,</div><div class=\"line\">               Injection.provideGetTasks(getApplicationContext()),</div><div class=\"line\">               Injection.provideCompleteTasks(getApplicationContext()),</div><div class=\"line\">               Injection.provideActivateTask(getApplicationContext()),</div><div class=\"line\">               Injection.provideClearCompleteTasks(getApplicationContext())</div><div class=\"line\">               );</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Presenter状态恢复</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (savedInstanceState != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           TasksFilterType currentFiltering =</div><div class=\"line\">                   (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY);</div><div class=\"line\">           mTasksPresenter.setFiltering(currentFiltering);</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Fragment：代表View，与其他的View作用相同</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TasksFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> <span class=\"keyword\">implements</span> <span class=\"title\">TasksContract</span>.<span class=\"title\">View</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TasksFragment</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Requires empty public constructor</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> TasksFragment <span class=\"title\">newInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    \t<span class=\"comment\">// 构建Fragment的最佳实践，可以setArgument等</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TasksFragment();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        mListAdapter = <span class=\"keyword\">new</span> TasksAdapter(<span class=\"keyword\">new</span> ArrayList&lt;Task&gt;(<span class=\"number\">0</span>), mItemListener);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// Presenter一般都会实现以下通用的方法</span></div><div class=\"line\">        mPresenter.start();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 双向绑定时，给Presenter使用的</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPresenter</span><span class=\"params\">(@NonNull TasksContract.Presenter presenter)</span> </span>&#123;</div><div class=\"line\">        mPresenter = checkNotNull(presenter);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class=\"line\">    \t <span class=\"comment\">// 一些回调交给Presenter处理</span></div><div class=\"line\">        mPresenter.result(requestCode, resultCode);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Nullable</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container,</div><div class=\"line\">                             Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        View root = inflater.inflate(R.layout.addtask_frag, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">        <span class=\"comment\">// 这个看情况，界面中有无需要保持的数据（如一些用户输入的信息）。</span></div><div class=\"line\">        <span class=\"comment\">// 由于这里没有使用Fragemnt来保持Presenter，这个也可以不加</span></div><div class=\"line\">        <span class=\"comment\">// setRetainInstance(true);</span></div><div class=\"line\">        <span class=\"keyword\">return</span> root;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 其他的View接口的方法实现，给Presenter使用</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showTasksList</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        getActivity().setResult(Activity.RESULT_OK);</div><div class=\"line\">        getActivity().finish();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 从上述代码中，我们可以得到几点信息：</p>\n<ul>\n<li>在View的生命周期中调用对应的Presenter方法。</li>\n<li><strong>View与Presenter的绑定时机</strong>：这里的View(Fragment)比较被动，通过在Presenter的构造函数中调用View接口的setPresnter方法注入Presenter，实现双向绑定。    </li>\n<li><p>Fragment没有履行Presenter保持的职责，他只负责保持界面的数据（如果有必要，参考<code>AddEditTaskFragment.java</code>）。</p>\n<blockquote>\n<p>之所以这样，一部分原因是由Activity来管理数据恢复这些事情，职责清晰。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>Presenter类<br>特点如下</p>\n<ul>\n<li>实现了xxxContract.Presenter接口，包括该接口的父接口BasePresenter中定义的生命周期映射（只有<code>void start()</code>方法一般在View的<code>onResume()</code>中调用）。</li>\n<li>暴露了的接口要明确。大部分暴露的接口都是View使用的操作（由用户行为触发）与Activity用到的功能（数据保持恢复型操作）。<strong>如何定义，定义什么接口具体查看Contract</strong></li>\n<li>构造函数中与Fragment绑定，setPresenter</li>\n<li>一个Presenter中<strong>含有多个UseCase</strong></li>\n<li>一个对外接口可以单独运行一个UseCase或者<strong>组合运行多个UseCase，嵌套调用。</strong></li>\n<li>可能有<code>public void result(int requestCode, int resultCode)</code>接口，映射了Fragment(不是Activity）的onActivityResult方法，处理回调。</li>\n<li>额外的还有数据获取与恢复接口给Activity调用</li>\n<li><p>接口中对View传来的<strong>原始数据</strong>进行处理。如判空等，在Presenter中，如果是null，直接调用View告知用户。而不是把这些值向下传入Domain层。<strong>原则：异常输入越早处理约好</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskDetailPresenter</span> <span class=\"keyword\">implements</span> <span class=\"title\">TaskDetailContract</span>.<span class=\"title\">Presenter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TaskDetailContract.View mTaskDetailView;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> UseCaseHandler mUseCaseHandler;</div><div class=\"line\">    <span class=\"comment\">// 含有多个UseCase</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> GetTask mGetTask;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CompleteTask mCompleteTask;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ActivateTask mActivateTask;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DeleteTask mDeleteTask;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Nullable</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String mTaskId;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskDetailPresenter</span><span class=\"params\">(@NonNull UseCaseHandler useCaseHandler,</div><div class=\"line\">            @Nullable String taskId,</div><div class=\"line\">            @NonNull TaskDetailContract.View taskDetailView,</div><div class=\"line\">            @NonNull GetTask getTask,</div><div class=\"line\">            @NonNull CompleteTask completeTask,</div><div class=\"line\">            @NonNull ActivateTask activateTask,</div><div class=\"line\">            @NonNull DeleteTask deleteTask)</span> </span>&#123;</div><div class=\"line\">        mTaskId = taskId;</div><div class=\"line\">        <span class=\"comment\">// 这些判空也是尽早发现问题的思想</span></div><div class=\"line\">        mUseCaseHandler = checkNotNull(useCaseHandler, <span class=\"string\">\"useCaseHandler cannot be null!\"</span>);</div><div class=\"line\">        mTaskDetailView = checkNotNull(taskDetailView, <span class=\"string\">\"taskDetailView cannot be null!\"</span>);</div><div class=\"line\">        mGetTask = checkNotNull(getTask, <span class=\"string\">\"getTask cannot be null!\"</span>);</div><div class=\"line\">        mCompleteTask = checkNotNull(completeTask, <span class=\"string\">\"completeTask cannot be null!\"</span>);</div><div class=\"line\">        mActivateTask = checkNotNull(activateTask, <span class=\"string\">\"activateTask cannot be null!\"</span>);</div><div class=\"line\">        mDeleteTask = checkNotNull(deleteTask, <span class=\"string\">\"deleteTask cannot be null!\"</span>);</div><div class=\"line\">        mTaskDetailView.setPresenter(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 抽象了一下，几乎所有的Presenter都有启动的那一刻，启动后可能是获取数据（绝大多数），或者其他操作。</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        openTask();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 这个很有意思，把Fragment的onActivityResult的值直接传递到Presenter中处理</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">result</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// If a task was successfully added, show snackbar</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (AddEditTaskActivity.REQUEST_ADD_TASK == requestCode</div><div class=\"line\">                &amp;&amp; Activity.RESULT_OK == resultCode) &#123;</div><div class=\"line\">            mTasksView.showSuccessfullySavedMessage();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">openTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里是输入的异常处理，越早越好，不要向下传再抛回来</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mTaskId == <span class=\"keyword\">null</span> || mTaskId.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.showMissingTask();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mTaskDetailView.setLoadingIndicator(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">        mUseCaseHandler.execute(mGetTask, <span class=\"keyword\">new</span> GetTask.RequestValues(mTaskId),</div><div class=\"line\">                <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;GetTask.ResponseValue&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(GetTask.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                        Task task = response.getTask();</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"comment\">// The view may not be able to handle UI updates anymore</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (!mTaskDetailView.isActive()) &#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        mTaskDetailView.setLoadingIndicator(<span class=\"keyword\">false</span>);</div><div class=\"line\">                        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == task) &#123;</div><div class=\"line\">                            mTaskDetailView.showMissingTask();</div><div class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                            showTask(task);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// The view may not be able to handle UI updates anymore</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (!mTaskDetailView.isActive()) &#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        mTaskDetailView.showMissingTask();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这些暴露的接口都是以用户动作触发为单位的！</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">editTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里是输入的异常处理，越早越好，不要向下传再抛回来</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mTaskId == <span class=\"keyword\">null</span> || mTaskId.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.showMissingTask();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mTaskDetailView.showEditTask(mTaskId);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        mUseCaseHandler.execute(mDeleteTask, <span class=\"keyword\">new</span> DeleteTask.RequestValues(mTaskId),</div><div class=\"line\">                <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;DeleteTask.ResponseValue&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(DeleteTask.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                        mTaskDetailView.showTaskDeleted();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// Show error, log, etc.</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">// 这些暴露的接口都是以用户动作触发为单位的！</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">completeTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mTaskId == <span class=\"keyword\">null</span> || mTaskId.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.showMissingTask();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mUseCaseHandler.execute(mCompleteTask, <span class=\"keyword\">new</span> CompleteTask.RequestValues(mTaskId),</div><div class=\"line\">                <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;CompleteTask.ResponseValue&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(CompleteTask.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                        mTaskDetailView.showTaskMarkedComplete();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// Show error, log, etc.</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">// 这些暴露的接口都是以用户动作触发为单位的！</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">activateTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mTaskId == <span class=\"keyword\">null</span> || mTaskId.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.showMissingTask();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mUseCaseHandler.execute(mActivateTask, <span class=\"keyword\">new</span> ActivateTask.RequestValues(mTaskId),</div><div class=\"line\">                <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;ActivateTask.ResponseValue&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(ActivateTask.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                        mTaskDetailView.showTaskMarkedActive();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">// Show error, log, etc.</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">showTask</span><span class=\"params\">(Task task)</span> </span>&#123;</div><div class=\"line\">        String title = task.getTitle();</div><div class=\"line\">        String description = task.getDescription();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (title != <span class=\"keyword\">null</span> &amp;&amp; title.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.hideTitle();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mTaskDetailView.showTitle(title);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (description != <span class=\"keyword\">null</span> &amp;&amp; description.isEmpty()) &#123;</div><div class=\"line\">            mTaskDetailView.hideDescription();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mTaskDetailView.showDescription(description);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mTaskDetailView.showCompletionStatus(task.isCompleted());</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 这两个方法比较特别，是Avtivity保存与恢复数据使用的，不是用户操作</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFiltering</span><span class=\"params\">(TasksFilterType requestType)</span> </span>&#123;</div><div class=\"line\">        mCurrentFiltering = requestType;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TasksFilterType <span class=\"title\">getFiltering</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> mCurrentFiltering;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Contract–接口定义<br>这个类是demo的特色，把一个业务的<strong>展现层与领域层之间的接口</strong>归类到一个类中十分清晰</p>\n<ul>\n<li>View层的操作（往往由用户触发）<ul>\n<li>编辑</li>\n<li>添加</li>\n<li>删除</li>\n<li>点击</li>\n<li>下拉。。。</li>\n</ul>\n</li>\n<li>View的生命周期映射、抽象<ul>\n<li>onResume – <code>void start()</code></li>\n<li>onPause </li>\n<li>onDestroy。。。</li>\n<li><strong><code>void result(int requestCode, int resultCode);</code></strong></li>\n</ul>\n</li>\n<li>数据存储恢复（这个demo是Activity使用）<ul>\n<li>onSaveInstance – <code>void setFiltering(TasksFilterType requestType);</code></li>\n<li>onRestoreInstance – <code>TasksFilterType getFiltering();</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AddEditTaskContract</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">// view层接口,从extends BaseView&lt;Presenter&gt; 就看出来依赖</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">View</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseView</span>&lt;<span class=\"title\">Presenter</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showEmptyTaskError</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showTasksList</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setTitle</span><span class=\"params\">(String title)</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDescription</span><span class=\"params\">(String description)</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isActive</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">// presenter接口</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Presenter</span> <span class=\"keyword\">extends</span> <span class=\"title\">BasePresenter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">saveTask</span><span class=\"params\">(String title, String description)</span></span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">populateTask</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"领域-Domain-层–UseCase\"><a href=\"#领域-Domain-层–UseCase\" class=\"headerlink\" title=\"领域(Domain)层–UseCase\"></a>领域(Domain)层–UseCase</h2><p>调用领域层的代码都是在展现层的Presenter类中。</p>\n<h3 id=\"UseCase的外部特点：\"><a href=\"#UseCase的外部特点：\" class=\"headerlink\" title=\"UseCase的外部特点：\"></a>UseCase的外部特点：</h3><ul>\n<li>独立性，可复用，一个业务定义的UseCase可以被其他业务单独使用</li>\n</ul>\n<blockquote>\n<p>实例：<code>TaskDetailPresenter</code>与<code>TasksPresenter</code>都使用了<code>CompleteTask</code></p>\n</blockquote>\n<ul>\n<li>命名直观，表示其功能</li>\n<li><strong>一个UseCase外而言只执行一个任务</strong>，既一个request一个reponse，没有多个方法暴露</li>\n<li>Presentation层的调用者使用<a href=\"\">命令模式</a>执行UseCase<ul>\n<li>单独运行一个UseCase</li>\n<li>组合运行多个UseCase：嵌套调用</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>使用命令模式 一个执行器参考<code>UseCaseHandler</code>，参数是UseCase（命令），Request（输入参数）与Response（输出结果）。<strong>UseCaseHandler也是在Activty中构造传入Presenter的。</strong></li>\n<li><strong>注意传参的方式</strong>，Request与Response都是定义在UseCase中的内部类，用它们来包裹传递的值，不是使用<code>new xxxUseCase(param1,param2).execute(callback)</code>的样式，或者<code>new xxxUseCase().execute(param1,param2,callback)</code></li>\n</ul>\n<p>实例代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clearCompletedTasks</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       mUseCaseHandler.execute(mClearCompleteTasks, <span class=\"keyword\">new</span> ClearCompleteTasks.RequestValues(),</div><div class=\"line\">               <span class=\"keyword\">new</span> UseCase.UseCaseCallback&lt;ClearCompleteTasks.ResponseValue&gt;() &#123;</div><div class=\"line\">                   <span class=\"meta\">@Override</span></div><div class=\"line\">                   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(ClearCompleteTasks.ResponseValue response)</span> </span>&#123;</div><div class=\"line\">                       mTasksView.showCompletedTasksCleared();</div><div class=\"line\">                       loadTasks(<span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">                   &#125;</div><div class=\"line\"></div><div class=\"line\">                   <span class=\"meta\">@Override</span></div><div class=\"line\">                   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                       mTasksView.showLoadingTasksError();</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"UseCase的内部实现\"><a href=\"#UseCase的内部实现\" class=\"headerlink\" title=\"UseCase的内部实现\"></a>UseCase的内部实现</h3><ul>\n<li><strong>UseCase内部没有调用其他UseCase，组合由Presenter完成</strong>，UseCase之间不可以互相调用？？？</li>\n</ul>\n<blockquote>\n<p>demo中是这样的，实际开发中有这个需求吗？还是合理划分UseCase就可以了？，尤其是一个UseCase只有执行一个execute，如果一个复杂的UseCase有多个可以复用的任务组成，难道逻辑放到Presenter中？虽然理论上移动端不应该有如此复杂的业务逻辑。展示逻辑（如分页）在Presenter中没有问题。</p>\n</blockquote>\n<ul>\n<li>UseCase内部的<code>executeUseCase()</code>覆写，实现真正的业务逻辑。</li>\n<li>内部类定义Request与Reponse，包裹传递的实体。</li>\n<li><strong>没有在UseCase内的变量缓存数据</strong></li>\n<li>执行器executeUseCase默认在在非UI线程执行UseCase，但是CallBack会回到UI线程，参考<code>UseCaseHandler.java</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// UseCase泛型参数就是命令模式的几个参数</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetTasks</span> <span class=\"keyword\">extends</span> <span class=\"title\">UseCase</span>&lt;<span class=\"title\">GetTasks</span>.<span class=\"title\">RequestValues</span>, <span class=\"title\">GetTasks</span>.<span class=\"title\">ResponseValue</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 注意：无变量缓存</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TasksRepository mTasksRepository;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FilterFactory mFilterFactory;</div><div class=\"line\"></div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GetTasks</span><span class=\"params\">(@NonNull TasksRepository tasksRepository, @NonNull FilterFactory filterFactory)</span> </span>&#123;</div><div class=\"line\">        mTasksRepository = checkNotNull(tasksRepository, <span class=\"string\">\"tasksRepository cannot be null!\"</span>);</div><div class=\"line\">        mFilterFactory = checkNotNull(filterFactory, <span class=\"string\">\"filterFactory cannot be null!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">executeUseCase</span><span class=\"params\">(<span class=\"keyword\">final</span> RequestValues values)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (values.isForceUpdate()) &#123;</div><div class=\"line\">            mTasksRepository.refreshTasks();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mTasksRepository.getTasks(<span class=\"keyword\">new</span> TasksDataSource.LoadTasksCallback() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onTasksLoaded</span><span class=\"params\">(List&lt;Task&gt; tasks)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 纯的业务逻辑，每一次都从数据仓库重新获取过滤</span></div><div class=\"line\">                TasksFilterType currentFiltering = values.getCurrentFiltering();</div><div class=\"line\">                TaskFilter taskFilter = mFilterFactory.create(currentFiltering);</div><div class=\"line\"></div><div class=\"line\">                List&lt;Task&gt; tasksFiltered = taskFilter.filter(tasks);</div><div class=\"line\">                ResponseValue responseValue = <span class=\"keyword\">new</span> ResponseValue(tasksFiltered);</div><div class=\"line\">                <span class=\"comment\">// 这种通知方式getUseCaseCallback的被封装了</span></div><div class=\"line\">                getUseCaseCallback().onSuccess(responseValue);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataNotAvailable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">             <span class=\"comment\">// 这种通知方式getUseCaseCallback的被封装了</span></div><div class=\"line\">                getUseCaseCallback().onError();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 注意这两个类UseCase.RequestValues与UseCase.ResponseValue是空的接口，子类设计也是比较自由的</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestValues</span> <span class=\"keyword\">implements</span> <span class=\"title\">UseCase</span>.<span class=\"title\">RequestValues</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TasksFilterType mCurrentFiltering;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mForceUpdate;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestValues</span><span class=\"params\">(<span class=\"keyword\">boolean</span> forceUpdate, @NonNull TasksFilterType currentFiltering)</span> </span>&#123;</div><div class=\"line\">            mForceUpdate = forceUpdate;</div><div class=\"line\">            mCurrentFiltering = checkNotNull(currentFiltering, <span class=\"string\">\"currentFiltering cannot be null!\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isForceUpdate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> mForceUpdate;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> TasksFilterType <span class=\"title\">getCurrentFiltering</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> mCurrentFiltering;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseValue</span> <span class=\"keyword\">implements</span> <span class=\"title\">UseCase</span>.<span class=\"title\">ResponseValue</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Task&gt; mTasks;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResponseValue</span><span class=\"params\">(@NonNull List&lt;Task&gt; tasks)</span> </span>&#123;</div><div class=\"line\">            mTasks = checkNotNull(tasks, <span class=\"string\">\"tasks cannot be null!\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Task&gt; <span class=\"title\">getTasks</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> mTasks;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"数据-Data-层–Repository模式\"><a href=\"#数据-Data-层–Repository模式\" class=\"headerlink\" title=\"数据(Data)层–Repository模式\"></a>数据(Data)层–Repository模式</h2><p>领域层从数据仓库获取接口，</p>\n<h3 id=\"Repository的外部特点\"><a href=\"#Repository的外部特点\" class=\"headerlink\" title=\"Repository的外部特点\"></a>Repository的外部特点</h3><ul>\n<li>领域层直接持有数据层的类<code>TasksRepository</code>而非<code>TasksDataSource</code>接口。</li>\n</ul>\n<blockquote>\n<p>虽然持有TasksRepository，不影响测试（本质上它就是个门面，如果测试在注入时替换内部Source就行，参考下面代码），但是很奇怪。我觉得持有TasksDataSource没有问题，可能是TasksRepository语意更清晰。</p>\n</blockquote>\n<ul>\n<li>单例设计，很好理解</li>\n<li><p><strong>有同步方法，也有异步方法</strong>。但是没必要用异步的，同步即可。TasksDataSource中有一些异步的Callback接口，README中都说了没有必要。。。</p>\n</li>\n<li><p>接口中的方法定义与存储的数据相关，如添加一个todo任务，删除一个todo任务，获取所有的todo任务</p>\n</li>\n</ul>\n<h3 id=\"Repository的内部实现\"><a href=\"#Repository的内部实现\" class=\"headerlink\" title=\"Repository的内部实现\"></a>Repository的内部实现</h3><ul>\n<li><strong>内部有缓存</strong>，单仅仅是原始数据缓存，使用HashMap实现，比较简单。</li>\n<li>Repository模式类似与装饰模式，<code>TasksRepository</code>暴露的接口只负责获取到数据，而不论数据的来源是哪里（可能是内存，网络，数据库）</li>\n<li><code>TasksRepository</code>的内部设计会引用多个来源TasksDataSource，他们也都实现了<code>TasksRepository</code>接口。如果需要测试，直接用fake的TasksDataSource替代真实的source即可。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注意接口设计TasksDataSource与下面mTasksRemoteDataSource等相同</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TasksRepository</span> <span class=\"keyword\">implements</span> <span class=\"title\">TasksDataSource</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TasksRepository INSTANCE = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TasksDataSource mTasksRemoteDataSource;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TasksDataSource mTasksLocalDataSource;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 缓存</span></div><div class=\"line\">    Map&lt;String, Task&gt; mCachedTasks;</div><div class=\"line\">\t<span class=\"comment\">// 缓存 数据脏了</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> mCacheIsDirty = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Prevent direct instantiation.</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">TasksRepository</span><span class=\"params\">(@NonNull TasksDataSource tasksRemoteDataSource,</div><div class=\"line\">                            @NonNull TasksDataSource tasksLocalDataSource)</span> </span>&#123;</div><div class=\"line\">        mTasksRemoteDataSource = checkNotNull(tasksRemoteDataSource);</div><div class=\"line\">        mTasksLocalDataSource = checkNotNull(tasksLocalDataSource);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 这里有些特殊：getInstance的参数是source，RemoteDataSource与LocalDataSource可以替换成fake的source</span></div><div class=\"line\">\t<span class=\"comment\">// 注意：缓存是内置的，没有用外面的</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> TasksRepository <span class=\"title\">getInstance</span><span class=\"params\">(TasksDataSource tasksRemoteDataSource,</div><div class=\"line\">                                              TasksDataSource tasksLocalDataSource)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            INSTANCE = <span class=\"keyword\">new</span> TasksRepository(tasksRemoteDataSource, tasksLocalDataSource);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">destroyInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        INSTANCE = <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 数据获取逻辑，可能是从任何地方获取的数据</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTasks</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> LoadTasksCallback callback)</span> </span>&#123;</div><div class=\"line\">        checkNotNull(callback);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Respond immediately with cache if available and not dirty</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mCachedTasks != <span class=\"keyword\">null</span> &amp;&amp; !mCacheIsDirty) &#123;</div><div class=\"line\">            callback.onTasksLoaded(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(mCachedTasks.values()));</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mCacheIsDirty) &#123;</div><div class=\"line\">            <span class=\"comment\">// If the cache is dirty we need to fetch new data from the network.</span></div><div class=\"line\">            getTasksFromRemoteDataSource(callback);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// Query the local storage if available. If not, query the network.</span></div><div class=\"line\">            mTasksLocalDataSource.getTasks(<span class=\"keyword\">new</span> LoadTasksCallback() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onTasksLoaded</span><span class=\"params\">(List&lt;Task&gt; tasks)</span> </span>&#123;</div><div class=\"line\">                    refreshCache(tasks);</div><div class=\"line\">                    callback.onTasksLoaded(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(mCachedTasks.values()));</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataNotAvailable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    getTasksFromRemoteDataSource(callback);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveTask</span><span class=\"params\">(@NonNull Task task)</span> </span>&#123;</div><div class=\"line\">        checkNotNull(task);</div><div class=\"line\">        mTasksRemoteDataSource.saveTask(task);</div><div class=\"line\">        mTasksLocalDataSource.saveTask(task);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Do in memory cache update to keep the app UI up to date</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mCachedTasks == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            mCachedTasks = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mCachedTasks.put(task.getId(), task);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"数据实体\"><a href=\"#数据实体\" class=\"headerlink\" title=\"数据实体\"></a>数据实体</h2><p>三层的数据Entity与Clean原文中不同<br>特点：</p>\n<ul>\n<li>公用，<strong>三层通用了一个数据Model</strong>–Task。减少了Clean构架的三层数据模型之间的转换</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>仅仅讨论Demo的不完善的地方：</p>\n<ul>\n<li>没有考虑P层的Presenter的保持</li>\n<li>Domain层没有负责的业务逻辑，没有多UseCase相互调用的例子</li>\n<li>Domain数据处理简单没有性能问题。没有缓存</li>\n<li>没有Notify机制的示例。都是一个request一个reponse的简单请求。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>Activty与Fragment职责明确</li>\n<li>Contract设计</li>\n<li>轻客户端思想，Domain尽量简单（与上面对应，哈哈）</li>\n<li>UseCase的简单设计思想，使得UseCese可以在其他模块复用（参考GetTasks用例）</li>\n<li>Domain的命令模式，设计可以参考</li>\n<li>数据仓库的设计（缓存和多Source思想）</li>\n</ul>\n<p>争论：</p>\n<ul>\n<li>StatisticsPresenter中的统计逻辑位置是否有问题？在主线程？为什么不用一个UseCase？</li>\n</ul>\n"},{"title":"Android构架系列之二--MVP&&Clean理解与实践之疑问","date":"2016-04-17T12:43:26.000Z","_content":"好几周没有更新博客了，不是忘记或者偷懒，而是想写一个比较复杂的话题，MVP与Clean构架的理解，既然是理解，不深入实践，自然不敢动笔，最近会多整理一些，补一补功课。\n\n最近研读了Google发布的[一系列框架的梳理](https://github.com/googlesamples/android-architecture)中的MVP中的源代码，又学习了一些文章，同时自己也在工作中使用了基于MVP的Clean构架开发了浏览器的文件下载模块。这篇文章主要分析遇到的问题和一些感悟，同时记录一些疑问。\n学习MVP的主要内容是\n\n* Google的源码（todo-mvp分支）\n* 一篇讲解的文章：[Android官方MVP架构示例项目解析](http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&mid=403539764&idx=1&sn=d30d89e6848a8e13d4da0f5639100e5f&scene=23&srcid=0414ejxUkZ3mPYQaYU3PJYTd#rd)\n* 一篇不错的MVP的总结文章包括Clean构架：[Android MVP 详解（上）](http://www.jianshu.com/p/9a6845b26856)，[下](http://www.jianshu.com/p/0590f530c617)\n* [Clean构架的GitHub的Issue](https://github.com/android10/Android-CleanArchitecture/issues?q=sort%3Acomments-desc)中大量提问很有价值\n* 其他很多MVP介绍的文章，不一一列举\n\n\n## 疑问\n\n在使用Clean构架中遇到的几个疑惑，先记录一些，会不断的补充新的问题。尽量按照我遇到的顺序：\n\n### MVP相关\n* Clean与MVP的关系是什么？\n* MVP中V层接口的设计原则是什么？\n* MVP中V与P的对应关系？1：1，n：1，1：n？？\n* MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\n* MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)\n\n### Clean相关\n* Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\n* 可否把Clean构架理解成一种AsyncTask？\n* Domain中的UseCase是什么？它重吗？\n* 一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\n* 多个UseCase如何组合\n* 后台线程的事件与UseCase如何通讯？异步通知\n* Domain的UseCase，需要默认在非UI线程中运行吗？\n* MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\n* 内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？\n* Domain的UseCase是否需要缓存设计？\n* Presenter是否需要缓存的设计？还是仅仅是数据引用？\n* Clean中Presentation层与domain层的UseCase职责分别是什么？\n* 一些Presentation层的Adapter，如何优雅的与Presenter结合\n* Data层的理解，什么才是data，图片是吗？\n* Cache如何设计合适，如何与原始数据同步？是否有最佳实践？\n* DBFlow可以启用他的缓存实现原始数据的缓存吗？\n\n## 写作计划\n之后的一系列文章包括：\n\n* [MVP&&Clean理解与实践之MVP](2016/05/02/Android构架系列之二-MVP&&Clean理解与实践之MVP/)(done)\n* [MVP&&Clean理解与实践之Clean](2016/05/08/Android构架系列之二-MVP&&Clean理解与实践之Clean/)（done）\n* [MVP&&Clean理解与实践之实例分析](2016/05/15/Android构架系列之二-MVP&&Clean理解与实践之实例分析/) (done)\n* [MVP&&Clean理解与实践之问题解答与总结](2016/06/11/Android构架系列之二-MVP&&Clean理解与实践之问题解答与总结/) (done)\n\n\n\n\n\n\n","source":"_posts/Android构架系列之二-MVP&&Clean理解与实践之疑问.md","raw":"title: Android构架系列之二--MVP&&Clean理解与实践之疑问\ndate: 2016-04-17 20:43:26\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n好几周没有更新博客了，不是忘记或者偷懒，而是想写一个比较复杂的话题，MVP与Clean构架的理解，既然是理解，不深入实践，自然不敢动笔，最近会多整理一些，补一补功课。\n\n最近研读了Google发布的[一系列框架的梳理](https://github.com/googlesamples/android-architecture)中的MVP中的源代码，又学习了一些文章，同时自己也在工作中使用了基于MVP的Clean构架开发了浏览器的文件下载模块。这篇文章主要分析遇到的问题和一些感悟，同时记录一些疑问。\n学习MVP的主要内容是\n\n* Google的源码（todo-mvp分支）\n* 一篇讲解的文章：[Android官方MVP架构示例项目解析](http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&mid=403539764&idx=1&sn=d30d89e6848a8e13d4da0f5639100e5f&scene=23&srcid=0414ejxUkZ3mPYQaYU3PJYTd#rd)\n* 一篇不错的MVP的总结文章包括Clean构架：[Android MVP 详解（上）](http://www.jianshu.com/p/9a6845b26856)，[下](http://www.jianshu.com/p/0590f530c617)\n* [Clean构架的GitHub的Issue](https://github.com/android10/Android-CleanArchitecture/issues?q=sort%3Acomments-desc)中大量提问很有价值\n* 其他很多MVP介绍的文章，不一一列举\n\n\n## 疑问\n\n在使用Clean构架中遇到的几个疑惑，先记录一些，会不断的补充新的问题。尽量按照我遇到的顺序：\n\n### MVP相关\n* Clean与MVP的关系是什么？\n* MVP中V层接口的设计原则是什么？\n* MVP中V与P的对应关系？1：1，n：1，1：n？？\n* MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。\n* MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)\n\n### Clean相关\n* Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？\n* 可否把Clean构架理解成一种AsyncTask？\n* Domain中的UseCase是什么？它重吗？\n* 一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？\n* 多个UseCase如何组合\n* 后台线程的事件与UseCase如何通讯？异步通知\n* Domain的UseCase，需要默认在非UI线程中运行吗？\n* MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？\n* 内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？\n* Domain的UseCase是否需要缓存设计？\n* Presenter是否需要缓存的设计？还是仅仅是数据引用？\n* Clean中Presentation层与domain层的UseCase职责分别是什么？\n* 一些Presentation层的Adapter，如何优雅的与Presenter结合\n* Data层的理解，什么才是data，图片是吗？\n* Cache如何设计合适，如何与原始数据同步？是否有最佳实践？\n* DBFlow可以启用他的缓存实现原始数据的缓存吗？\n\n## 写作计划\n之后的一系列文章包括：\n\n* [MVP&&Clean理解与实践之MVP](2016/05/02/Android构架系列之二-MVP&&Clean理解与实践之MVP/)(done)\n* [MVP&&Clean理解与实践之Clean](2016/05/08/Android构架系列之二-MVP&&Clean理解与实践之Clean/)（done）\n* [MVP&&Clean理解与实践之实例分析](2016/05/15/Android构架系列之二-MVP&&Clean理解与实践之实例分析/) (done)\n* [MVP&&Clean理解与实践之问题解答与总结](2016/06/11/Android构架系列之二-MVP&&Clean理解与实践之问题解答与总结/) (done)\n\n\n\n\n\n\n","slug":"Android构架系列之二-MVP&&Clean理解与实践之疑问","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbci000nnac9eg0vadde","content":"<p>好几周没有更新博客了，不是忘记或者偷懒，而是想写一个比较复杂的话题，MVP与Clean构架的理解，既然是理解，不深入实践，自然不敢动笔，最近会多整理一些，补一补功课。</p>\n<p>最近研读了Google发布的<a href=\"https://github.com/googlesamples/android-architecture\" target=\"_blank\" rel=\"external\">一系列框架的梳理</a>中的MVP中的源代码，又学习了一些文章，同时自己也在工作中使用了基于MVP的Clean构架开发了浏览器的文件下载模块。这篇文章主要分析遇到的问题和一些感悟，同时记录一些疑问。<br>学习MVP的主要内容是</p>\n<ul>\n<li>Google的源码（todo-mvp分支）</li>\n<li>一篇讲解的文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=403539764&amp;idx=1&amp;sn=d30d89e6848a8e13d4da0f5639100e5f&amp;scene=23&amp;srcid=0414ejxUkZ3mPYQaYU3PJYTd#rd\" target=\"_blank\" rel=\"external\">Android官方MVP架构示例项目解析</a></li>\n<li>一篇不错的MVP的总结文章包括Clean构架：<a href=\"http://www.jianshu.com/p/9a6845b26856\" target=\"_blank\" rel=\"external\">Android MVP 详解（上）</a>，<a href=\"http://www.jianshu.com/p/0590f530c617\" target=\"_blank\" rel=\"external\">下</a></li>\n<li><a href=\"https://github.com/android10/Android-CleanArchitecture/issues?q=sort%3Acomments-desc\" target=\"_blank\" rel=\"external\">Clean构架的GitHub的Issue</a>中大量提问很有价值</li>\n<li>其他很多MVP介绍的文章，不一一列举</li>\n</ul>\n<h2 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h2><p>在使用Clean构架中遇到的几个疑惑，先记录一些，会不断的补充新的问题。尽量按照我遇到的顺序：</p>\n<h3 id=\"MVP相关\"><a href=\"#MVP相关\" class=\"headerlink\" title=\"MVP相关\"></a>MVP相关</h3><ul>\n<li>Clean与MVP的关系是什么？</li>\n<li>MVP中V层接口的设计原则是什么？</li>\n<li>MVP中V与P的对应关系？1：1，n：1，1：n？？</li>\n<li>MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。</li>\n<li>MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)</li>\n</ul>\n<h3 id=\"Clean相关\"><a href=\"#Clean相关\" class=\"headerlink\" title=\"Clean相关\"></a>Clean相关</h3><ul>\n<li>Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？</li>\n<li>可否把Clean构架理解成一种AsyncTask？</li>\n<li>Domain中的UseCase是什么？它重吗？</li>\n<li>一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？</li>\n<li>多个UseCase如何组合</li>\n<li>后台线程的事件与UseCase如何通讯？异步通知</li>\n<li>Domain的UseCase，需要默认在非UI线程中运行吗？</li>\n<li>MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？</li>\n<li>内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？</li>\n<li>Domain的UseCase是否需要缓存设计？</li>\n<li>Presenter是否需要缓存的设计？还是仅仅是数据引用？</li>\n<li>Clean中Presentation层与domain层的UseCase职责分别是什么？</li>\n<li>一些Presentation层的Adapter，如何优雅的与Presenter结合</li>\n<li>Data层的理解，什么才是data，图片是吗？</li>\n<li>Cache如何设计合适，如何与原始数据同步？是否有最佳实践？</li>\n<li>DBFlow可以启用他的缓存实现原始数据的缓存吗？</li>\n</ul>\n<h2 id=\"写作计划\"><a href=\"#写作计划\" class=\"headerlink\" title=\"写作计划\"></a>写作计划</h2><p>之后的一系列文章包括：</p>\n<ul>\n<li><a href=\"2016/05/02/Android构架系列之二-MVP&amp;&amp;Clean理解与实践之MVP/\">MVP&amp;&amp;Clean理解与实践之MVP</a>(done)</li>\n<li><a href=\"2016/05/08/Android构架系列之二-MVP&amp;&amp;Clean理解与实践之Clean/\">MVP&amp;&amp;Clean理解与实践之Clean</a>（done）</li>\n<li><a href=\"2016/05/15/Android构架系列之二-MVP&amp;&amp;Clean理解与实践之实例分析/\">MVP&amp;&amp;Clean理解与实践之实例分析</a> (done)</li>\n<li><a href=\"2016/06/11/Android构架系列之二-MVP&amp;&amp;Clean理解与实践之问题解答与总结/\">MVP&amp;&amp;Clean理解与实践之问题解答与总结</a> (done)</li>\n</ul>\n","excerpt":"","more":"<p>好几周没有更新博客了，不是忘记或者偷懒，而是想写一个比较复杂的话题，MVP与Clean构架的理解，既然是理解，不深入实践，自然不敢动笔，最近会多整理一些，补一补功课。</p>\n<p>最近研读了Google发布的<a href=\"https://github.com/googlesamples/android-architecture\">一系列框架的梳理</a>中的MVP中的源代码，又学习了一些文章，同时自己也在工作中使用了基于MVP的Clean构架开发了浏览器的文件下载模块。这篇文章主要分析遇到的问题和一些感悟，同时记录一些疑问。<br>学习MVP的主要内容是</p>\n<ul>\n<li>Google的源码（todo-mvp分支）</li>\n<li>一篇讲解的文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=403539764&amp;idx=1&amp;sn=d30d89e6848a8e13d4da0f5639100e5f&amp;scene=23&amp;srcid=0414ejxUkZ3mPYQaYU3PJYTd#rd\">Android官方MVP架构示例项目解析</a></li>\n<li>一篇不错的MVP的总结文章包括Clean构架：<a href=\"http://www.jianshu.com/p/9a6845b26856\">Android MVP 详解（上）</a>，<a href=\"http://www.jianshu.com/p/0590f530c617\">下</a></li>\n<li><a href=\"https://github.com/android10/Android-CleanArchitecture/issues?q=sort%3Acomments-desc\">Clean构架的GitHub的Issue</a>中大量提问很有价值</li>\n<li>其他很多MVP介绍的文章，不一一列举</li>\n</ul>\n<h2 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h2><p>在使用Clean构架中遇到的几个疑惑，先记录一些，会不断的补充新的问题。尽量按照我遇到的顺序：</p>\n<h3 id=\"MVP相关\"><a href=\"#MVP相关\" class=\"headerlink\" title=\"MVP相关\"></a>MVP相关</h3><ul>\n<li>Clean与MVP的关系是什么？</li>\n<li>MVP中V层接口的设计原则是什么？</li>\n<li>MVP中V与P的对应关系？1：1，n：1，1：n？？</li>\n<li>MVP中V的所有操作都必须经过P吗？即使不涉及M的修改。</li>\n<li>MVP中P需要主动去V中区数据吗？还是V主动把数据给P（PV？SoC?)</li>\n</ul>\n<h3 id=\"Clean相关\"><a href=\"#Clean相关\" class=\"headerlink\" title=\"Clean相关\"></a>Clean相关</h3><ul>\n<li>Clean中Presentation与Domain，Domain与Repository之间接口设计是必要的吗？</li>\n<li>可否把Clean构架理解成一种AsyncTask？</li>\n<li>Domain中的UseCase是什么？它重吗？</li>\n<li>一个UseCase应该做多少事情？一件？一组相关的？划分逻辑是什么？</li>\n<li>多个UseCase如何组合</li>\n<li>后台线程的事件与UseCase如何通讯？异步通知</li>\n<li>Domain的UseCase，需要默认在非UI线程中运行吗？</li>\n<li>MVP中Presenter是否能设计为单例？Domain不能设计为单例？Repository必须设计为单例？</li>\n<li>内存缓存放在哪一层？Repository还是Domain还是都需要？前者缓存原始数据（未处理计算），后者缓存处理后的数据。如果一个domain需要多个Repository然后计算，结果数据需要缓存吗？</li>\n<li>Domain的UseCase是否需要缓存设计？</li>\n<li>Presenter是否需要缓存的设计？还是仅仅是数据引用？</li>\n<li>Clean中Presentation层与domain层的UseCase职责分别是什么？</li>\n<li>一些Presentation层的Adapter，如何优雅的与Presenter结合</li>\n<li>Data层的理解，什么才是data，图片是吗？</li>\n<li>Cache如何设计合适，如何与原始数据同步？是否有最佳实践？</li>\n<li>DBFlow可以启用他的缓存实现原始数据的缓存吗？</li>\n</ul>\n<h2 id=\"写作计划\"><a href=\"#写作计划\" class=\"headerlink\" title=\"写作计划\"></a>写作计划</h2><p>之后的一系列文章包括：</p>\n<ul>\n<li><a href=\"2016/05/02/Android构架系列之二-MVP&amp;&amp;Clean理解与实践之MVP/\">MVP&amp;&amp;Clean理解与实践之MVP</a>(done)</li>\n<li><a href=\"2016/05/08/Android构架系列之二-MVP&amp;&amp;Clean理解与实践之Clean/\">MVP&amp;&amp;Clean理解与实践之Clean</a>（done）</li>\n<li><a href=\"2016/05/15/Android构架系列之二-MVP&amp;&amp;Clean理解与实践之实例分析/\">MVP&amp;&amp;Clean理解与实践之实例分析</a> (done)</li>\n<li><a href=\"2016/06/11/Android构架系列之二-MVP&amp;&amp;Clean理解与实践之问题解答与总结/\">MVP&amp;&amp;Clean理解与实践之问题解答与总结</a> (done)</li>\n</ul>\n"},{"title":"Google推荐的Android应用框架之demo","date":"2016-01-31T08:04:50.000Z","_content":"近日，在Google开发者的微博上推荐了一个视频，是2015年开发者峰会上两位Google的Coder的演讲，关于Android应用框架，中文相关介绍文章[看这里](http://blog.zhaiyifan.cn/2016/01/29/android-app-architecture-2015/)。\n演讲中有个demo，类似于一个QQ的聊天界面的程序，用这个例子讲解了如何优雅地处理在各种网络异常的情况下的UI界面，既如何设计一个offline的应用。\n网络请求与本地缓存相结合以获取最好的用户体验应当是几乎所有Android应用的基本需求。从我的开发经验看，我们往往会忽略之一点。大部分情况下，都是直接从网络拿回数据显示在界面上，如果网络不好，就不断loading。。。在无网情况下，app是不可用的。\n\n* 拉逻辑--获取列表，此过程是我们最常用，我们大部分是获取数据然后展示给用户，仅仅需要本地有一份数据以备在无网时使用。这个逻辑在应用中基本是通用的。\n* 推逻辑--提交post，demo中对某些请求进行排队，在后台不断重试，这种逻辑对于某些应用应该是不适用的，毕竟大部分应用是不需要这种『强同步』的（既server与local完全一致，如聊天list或记账，微信发朋友圈）。在一般应用中以下两种情况更加常见：\n\n\t* 结果失败与否并不重要。如点赞这些功能，当然也可以这么干。\n\t* 操作是一些重要的不可重复操作，必须锁死屏幕。如提交订单，付款等。\n\n选择哪一种交互是设计阶段必须考虑的，这直接决定了编码方式。当然，一个设计良好的框架必须要提供这些能力:\n\n* 封装网络请求与本地数据支持拉逻辑的操作，开发者可以选择是否先使用本地数据再等待网络更新。还是只使用网络数据。\n* 支持简单请求，锁死等待，还是异步的。\n* 支持后台可重复发送的请求--强同步--既Act locally, Sync globally。\n\n扯远了，需要一篇文章写一些app中可能用到各种交互与请求逻辑。\n\n下面翻译下Google这个demo的README文件。了解一下设计思想。\n\n## 简介\n这是个简单的社交软件，列表可以展示其他人的消息（我们叫他feed流），用户还可以发送文本信息。\n\n本文的目的是讲述如何设计一个应用，可以离线使用，并在网络可用时同步信息到服务器，尽量不影响用户。\n\n* 如何工作\n* 组件\n* 数据流\n\t* 发送信息\n\t* 同步feed流\n\t* 保持UI更新\n* 安装&运行&测试\n\t* 安装\n\t* 运行\n\t* 测试\n* 其他\n\t* 避免重复发送信息 \n* 版权许可\n\n## 如何工作\n关于『离线设计』这个主题，许多解决方案都是依赖于特定的需求，如果想要运用到其他场景，需要一些修改。因此，这个demo的同步逻辑可能并不适合你的需求。你应当把它当做一个例子学习，然后找出适合你的应用的解决方案。不幸的是，没有设计离线应用的万金油。\n这里，我们会解释用户的交互流是如何工作的，会给你的应用提供一些不错的想法。\n这个例子没有严格依照任何的构架模式，它使用混合方法满足自己的需求。我们假设这个应用会不断成长为一个大的app（因此下面比较复杂）。尽管增加了复杂度，但是我没尽量是这个demo更加真实有用。\n\n## 组件\n* Value Objects:\n\t* 这些对象通常保持着数据库中存储的数据，这些对象也知道如何校验这些数据的合法性。如果Server发送了一下无效数据（比如，API改变了），我们可以在它们影响Model之前就忽略它们。\n* Models:\n\t* 扶着数据持久化，保持到本地，并提供方法获取数据。\n* Controllers:\n\t* 保存着应用程序主要逻辑，它决定如何做某事（如发送消息），处理gcm消息等。\n* Activities:\n\t* 控制用户界面，他们知道哪里需要加载数据，什么时候需要刷新自己。\n* Events:\n\t* 本demo使用一个全局的EventBus，它唯一的作用是通知UI更新。\n\t* 当UI需要从应用逻辑那里获取数据，直接调用相关方法就可以。这种设计符合Android这个UI生命周期短的设计。这种数据流也避免了UI和后台线程的循环引用。\n* Jobs:\n\t* 他们可能是定义良好的网络操作（这比较典型，但未必）， 可以把你的应用逻辑拆分成多个job，这更方便测试和扩展。例如发送用户的文本消息到服务器就是一个job，同步用户的feed流到服务器也是个job。\n\n## 数据流\n\n### 发送消息\n当用户点击按钮，首先会发生这么4步：1.验证消息合法性。2.保持消息到本地磁盘存储（这个例子中这是一个job）。3.更新PostModel添加新的信息。4.发送event通知有消息更新。\n（可选的）4.a.如果UI可见，在收到event后更新内容。\n注意：上面这些步骤没有涉及网络，但是我已经更新了用户界面&&保持必要的数据到磁盘。最后，我们需要与Server同步。\n\n同步的步骤如下\n![Sync To Server](https://camo.githubusercontent.com/590b0315c04a7e5c0b429fbd521f99062aacde1d/68747470733a2f2f7777772e657665726e6f74652e636f6d2f73686172642f7331392f73682f31313036313730662d346637332d343531392d616537642d3466346166313364343138322f366562656436376534613734613461342f7265732f62656166626235362d633564632d346563622d393934662d3330653036616232313961342f736b697463682e706e67)\n\n* 优先级作业队列，负责处理持久化job，失败时的回退操作等，所以图中没有这些细节。\n* 一个真实环境的app应该与JobScheduler结合，确保消息在应用关闭后也可以发送。\n* 当job失败时，你最好保持一些信息到磁盘，那样下次用户打开app时，你可以通知他们发生了什么。这个demo中，当FeedActivity不可见时会显示系统通知。\n\n### 同步Feed流\n同步操作有下面三个组件负责：\n\n* FeedModel：\n\t* 为每个feed流保存最后一条FeedItem（既发送的消息）的时间戳。这个时间戳有两个作用\n\t\t* 当我们刷新feed流时，只接收最新的item。\n\t\t* 创建保存在本地的消息。本地创建的消息会显示在feed查询中是很重要的。 客户端的时间戳可能与server不同，只有当消息与Server同步时，我们分配feed最新的时间戳给这个新的消息。？？？\n\t* 给UI层提供从数据库获取feed流的方法。\n* FeedController：\n\t* 负责创建`FetchFeedJob`\n\t* 监听消息更新失败，使用系统的通知栏通知用户。除非其他的UI组件（如FeedActivity）已经处理了错误。\n\t* 这个示例的app很基础，在真实环境中，它可能还要负责当有GCM推送到达时刷新feed流。以及包括一些防止用户频繁刷新的逻辑。\n* FetFeedJob：\n\t* 发出API调用，获取某个feed流的最新消息列表。还负责更新model和发出event。\n\n### 保持UI更新\n后台与UI的交互需要良好的定义。\n\n* 等界面需要做某件事情时，UI直接调用某个方法（如发送消息）。\n* 后台任务结束时发出event通知UI更新（如更新失败）。\n\nUI组件根据自身的生命周期负责注册/反注册EventBus，因为后台永远不会持有UI的引用，我们不想有内存泄漏的风险。\n\n* EventBus的使用可能引起一些特殊的情况：由于UI错过了一些event时，导致不同步。本Demo使用下面的规则避免这种清空。\n\t* 当组件的生命周期开始时，先注册event，然后在再从model加载数据。\n\t* 当正在加载数据时，如果有event到来，会在数据加载完成后再次触发一次同步。\n\t* 所有的event都含有一个时间戳，它表示与该event相关的最老的item的时间。当UI访问model层时会使用这个时间戳，那么，如果item插入数据库时顺序不同，我们依然可以获取到这些item，因为我们使用了最老的时间戳。？？？\n\t* 当组件的生命周期结束时（例如`Activity#onStop`）,停止监听event。如果，我们再返回应用，他会做一个完整的同步，确保不会丢失在这期间发生的event。\n\n**这不是唯一的办法**：示例中使用的是一个全局的EventBus，你也可以用Rx实现相似的功能，或者手动设置listener，以及其他相似的技术。总之，你需要根据自己的应用来评估。\n\n## 安装&&运行&&测试\n### 安装\ndemo包含一个简单的server，你需要安装Ruby On Rails来运行它。建议你通过[Ruby Version Manager](https://rvm.io/)来安装。安装完之后，使用下面命令启动server：\n\n```xml\n> cd server;\n> bundle install;\n> rake db:migrate RAILS_ENV=development;\n```\n这会安装依赖，创建数据库。\n\n### 运行\n#### 服务器\n\n```xml\n> cd server;\n> rails s\n```\n\n#### 客户端\ndemo中app使用模拟器环境默认的host地址。（`http://10.0.2.2:3000`）。如果你在模拟器里运行，已经可以正常工作。你可以在设置菜单中修改，或者在`DemoConfig`类中直接修改。\n\n### 测试\n\n* 服务器：服务端没有。。我又不关心。\n* 客户端：你可以这样运行测试 `> cd client; > ./gradlew clean app:connectedCheck app:test`\n\n## 其他\n### 避免重复发送消息\n编写移动应用意味着你要处理不可靠的网络。通过使用持久化的job（存储在本地），在网络可用时，app工作了很不错，可是并不完美。在不可靠的网络条件下，我们的应用可能出现这种情况：服务端那数据已经更新存储了，但是客户端没有收到成功的返回。那么客户端依然认为消息没有上传，会不断重试。如果server的返回有问题，这就会变得更糟糕。\n通常情况下，重试就以为这重复上传消息。有很多策略可以解决这个问题。demo中我们使用一个唯一的二维元组`(userId, clientId)`来避免重复，它的原理如下：\n\n* 客户端创建消息时，生成一个唯一的`clientId`（`UUID.randomUUID().toString()`,注：随着时间会变化）。这个UUID和用户ID的组合在客户端和服务端都是唯一的。\n* 当服务端收到消息时，检查这个元组是否存在，如果以及存在，不会新增一条存储记录，而是仅仅返回这个条目已经存在。\n* 当客户端获取feed时，如果发现一个消息的` (userId, client Id)`与某个存在的消息相同，会覆盖这存在的消息。这可能发生在这种情况下发生：客户端没有收到服务端的返回，只是本地保存了这个消息，，但是这个消息出现在其他某个请求的返回里面。？？需要这样吗\n\n你可以在`server/app/controllers/posts_controller.rb`中使用`error_before_saving_post`和`error_after_saving_post`来触发这种特殊的情况。\n\n## 版权许可\n>Copyright (C) 2015 The Android Open Source Project\n\n>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\n\n>You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n\n>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n>See the License for the specific language governing permissions and limitations under the License.","source":"_posts/Google推荐的Android应用框架之demo.md","raw":"title: Google推荐的Android应用框架之demo\ndate: 2016-01-31 16:04:50\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n近日，在Google开发者的微博上推荐了一个视频，是2015年开发者峰会上两位Google的Coder的演讲，关于Android应用框架，中文相关介绍文章[看这里](http://blog.zhaiyifan.cn/2016/01/29/android-app-architecture-2015/)。\n演讲中有个demo，类似于一个QQ的聊天界面的程序，用这个例子讲解了如何优雅地处理在各种网络异常的情况下的UI界面，既如何设计一个offline的应用。\n网络请求与本地缓存相结合以获取最好的用户体验应当是几乎所有Android应用的基本需求。从我的开发经验看，我们往往会忽略之一点。大部分情况下，都是直接从网络拿回数据显示在界面上，如果网络不好，就不断loading。。。在无网情况下，app是不可用的。\n\n* 拉逻辑--获取列表，此过程是我们最常用，我们大部分是获取数据然后展示给用户，仅仅需要本地有一份数据以备在无网时使用。这个逻辑在应用中基本是通用的。\n* 推逻辑--提交post，demo中对某些请求进行排队，在后台不断重试，这种逻辑对于某些应用应该是不适用的，毕竟大部分应用是不需要这种『强同步』的（既server与local完全一致，如聊天list或记账，微信发朋友圈）。在一般应用中以下两种情况更加常见：\n\n\t* 结果失败与否并不重要。如点赞这些功能，当然也可以这么干。\n\t* 操作是一些重要的不可重复操作，必须锁死屏幕。如提交订单，付款等。\n\n选择哪一种交互是设计阶段必须考虑的，这直接决定了编码方式。当然，一个设计良好的框架必须要提供这些能力:\n\n* 封装网络请求与本地数据支持拉逻辑的操作，开发者可以选择是否先使用本地数据再等待网络更新。还是只使用网络数据。\n* 支持简单请求，锁死等待，还是异步的。\n* 支持后台可重复发送的请求--强同步--既Act locally, Sync globally。\n\n扯远了，需要一篇文章写一些app中可能用到各种交互与请求逻辑。\n\n下面翻译下Google这个demo的README文件。了解一下设计思想。\n\n## 简介\n这是个简单的社交软件，列表可以展示其他人的消息（我们叫他feed流），用户还可以发送文本信息。\n\n本文的目的是讲述如何设计一个应用，可以离线使用，并在网络可用时同步信息到服务器，尽量不影响用户。\n\n* 如何工作\n* 组件\n* 数据流\n\t* 发送信息\n\t* 同步feed流\n\t* 保持UI更新\n* 安装&运行&测试\n\t* 安装\n\t* 运行\n\t* 测试\n* 其他\n\t* 避免重复发送信息 \n* 版权许可\n\n## 如何工作\n关于『离线设计』这个主题，许多解决方案都是依赖于特定的需求，如果想要运用到其他场景，需要一些修改。因此，这个demo的同步逻辑可能并不适合你的需求。你应当把它当做一个例子学习，然后找出适合你的应用的解决方案。不幸的是，没有设计离线应用的万金油。\n这里，我们会解释用户的交互流是如何工作的，会给你的应用提供一些不错的想法。\n这个例子没有严格依照任何的构架模式，它使用混合方法满足自己的需求。我们假设这个应用会不断成长为一个大的app（因此下面比较复杂）。尽管增加了复杂度，但是我没尽量是这个demo更加真实有用。\n\n## 组件\n* Value Objects:\n\t* 这些对象通常保持着数据库中存储的数据，这些对象也知道如何校验这些数据的合法性。如果Server发送了一下无效数据（比如，API改变了），我们可以在它们影响Model之前就忽略它们。\n* Models:\n\t* 扶着数据持久化，保持到本地，并提供方法获取数据。\n* Controllers:\n\t* 保存着应用程序主要逻辑，它决定如何做某事（如发送消息），处理gcm消息等。\n* Activities:\n\t* 控制用户界面，他们知道哪里需要加载数据，什么时候需要刷新自己。\n* Events:\n\t* 本demo使用一个全局的EventBus，它唯一的作用是通知UI更新。\n\t* 当UI需要从应用逻辑那里获取数据，直接调用相关方法就可以。这种设计符合Android这个UI生命周期短的设计。这种数据流也避免了UI和后台线程的循环引用。\n* Jobs:\n\t* 他们可能是定义良好的网络操作（这比较典型，但未必）， 可以把你的应用逻辑拆分成多个job，这更方便测试和扩展。例如发送用户的文本消息到服务器就是一个job，同步用户的feed流到服务器也是个job。\n\n## 数据流\n\n### 发送消息\n当用户点击按钮，首先会发生这么4步：1.验证消息合法性。2.保持消息到本地磁盘存储（这个例子中这是一个job）。3.更新PostModel添加新的信息。4.发送event通知有消息更新。\n（可选的）4.a.如果UI可见，在收到event后更新内容。\n注意：上面这些步骤没有涉及网络，但是我已经更新了用户界面&&保持必要的数据到磁盘。最后，我们需要与Server同步。\n\n同步的步骤如下\n![Sync To Server](https://camo.githubusercontent.com/590b0315c04a7e5c0b429fbd521f99062aacde1d/68747470733a2f2f7777772e657665726e6f74652e636f6d2f73686172642f7331392f73682f31313036313730662d346637332d343531392d616537642d3466346166313364343138322f366562656436376534613734613461342f7265732f62656166626235362d633564632d346563622d393934662d3330653036616232313961342f736b697463682e706e67)\n\n* 优先级作业队列，负责处理持久化job，失败时的回退操作等，所以图中没有这些细节。\n* 一个真实环境的app应该与JobScheduler结合，确保消息在应用关闭后也可以发送。\n* 当job失败时，你最好保持一些信息到磁盘，那样下次用户打开app时，你可以通知他们发生了什么。这个demo中，当FeedActivity不可见时会显示系统通知。\n\n### 同步Feed流\n同步操作有下面三个组件负责：\n\n* FeedModel：\n\t* 为每个feed流保存最后一条FeedItem（既发送的消息）的时间戳。这个时间戳有两个作用\n\t\t* 当我们刷新feed流时，只接收最新的item。\n\t\t* 创建保存在本地的消息。本地创建的消息会显示在feed查询中是很重要的。 客户端的时间戳可能与server不同，只有当消息与Server同步时，我们分配feed最新的时间戳给这个新的消息。？？？\n\t* 给UI层提供从数据库获取feed流的方法。\n* FeedController：\n\t* 负责创建`FetchFeedJob`\n\t* 监听消息更新失败，使用系统的通知栏通知用户。除非其他的UI组件（如FeedActivity）已经处理了错误。\n\t* 这个示例的app很基础，在真实环境中，它可能还要负责当有GCM推送到达时刷新feed流。以及包括一些防止用户频繁刷新的逻辑。\n* FetFeedJob：\n\t* 发出API调用，获取某个feed流的最新消息列表。还负责更新model和发出event。\n\n### 保持UI更新\n后台与UI的交互需要良好的定义。\n\n* 等界面需要做某件事情时，UI直接调用某个方法（如发送消息）。\n* 后台任务结束时发出event通知UI更新（如更新失败）。\n\nUI组件根据自身的生命周期负责注册/反注册EventBus，因为后台永远不会持有UI的引用，我们不想有内存泄漏的风险。\n\n* EventBus的使用可能引起一些特殊的情况：由于UI错过了一些event时，导致不同步。本Demo使用下面的规则避免这种清空。\n\t* 当组件的生命周期开始时，先注册event，然后在再从model加载数据。\n\t* 当正在加载数据时，如果有event到来，会在数据加载完成后再次触发一次同步。\n\t* 所有的event都含有一个时间戳，它表示与该event相关的最老的item的时间。当UI访问model层时会使用这个时间戳，那么，如果item插入数据库时顺序不同，我们依然可以获取到这些item，因为我们使用了最老的时间戳。？？？\n\t* 当组件的生命周期结束时（例如`Activity#onStop`）,停止监听event。如果，我们再返回应用，他会做一个完整的同步，确保不会丢失在这期间发生的event。\n\n**这不是唯一的办法**：示例中使用的是一个全局的EventBus，你也可以用Rx实现相似的功能，或者手动设置listener，以及其他相似的技术。总之，你需要根据自己的应用来评估。\n\n## 安装&&运行&&测试\n### 安装\ndemo包含一个简单的server，你需要安装Ruby On Rails来运行它。建议你通过[Ruby Version Manager](https://rvm.io/)来安装。安装完之后，使用下面命令启动server：\n\n```xml\n> cd server;\n> bundle install;\n> rake db:migrate RAILS_ENV=development;\n```\n这会安装依赖，创建数据库。\n\n### 运行\n#### 服务器\n\n```xml\n> cd server;\n> rails s\n```\n\n#### 客户端\ndemo中app使用模拟器环境默认的host地址。（`http://10.0.2.2:3000`）。如果你在模拟器里运行，已经可以正常工作。你可以在设置菜单中修改，或者在`DemoConfig`类中直接修改。\n\n### 测试\n\n* 服务器：服务端没有。。我又不关心。\n* 客户端：你可以这样运行测试 `> cd client; > ./gradlew clean app:connectedCheck app:test`\n\n## 其他\n### 避免重复发送消息\n编写移动应用意味着你要处理不可靠的网络。通过使用持久化的job（存储在本地），在网络可用时，app工作了很不错，可是并不完美。在不可靠的网络条件下，我们的应用可能出现这种情况：服务端那数据已经更新存储了，但是客户端没有收到成功的返回。那么客户端依然认为消息没有上传，会不断重试。如果server的返回有问题，这就会变得更糟糕。\n通常情况下，重试就以为这重复上传消息。有很多策略可以解决这个问题。demo中我们使用一个唯一的二维元组`(userId, clientId)`来避免重复，它的原理如下：\n\n* 客户端创建消息时，生成一个唯一的`clientId`（`UUID.randomUUID().toString()`,注：随着时间会变化）。这个UUID和用户ID的组合在客户端和服务端都是唯一的。\n* 当服务端收到消息时，检查这个元组是否存在，如果以及存在，不会新增一条存储记录，而是仅仅返回这个条目已经存在。\n* 当客户端获取feed时，如果发现一个消息的` (userId, client Id)`与某个存在的消息相同，会覆盖这存在的消息。这可能发生在这种情况下发生：客户端没有收到服务端的返回，只是本地保存了这个消息，，但是这个消息出现在其他某个请求的返回里面。？？需要这样吗\n\n你可以在`server/app/controllers/posts_controller.rb`中使用`error_before_saving_post`和`error_after_saving_post`来触发这种特殊的情况。\n\n## 版权许可\n>Copyright (C) 2015 The Android Open Source Project\n\n>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\n\n>You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n\n>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n>See the License for the specific language governing permissions and limitations under the License.","slug":"Google推荐的Android应用框架之demo","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbcm000qnac940h8w6j2","content":"<p>近日，在Google开发者的微博上推荐了一个视频，是2015年开发者峰会上两位Google的Coder的演讲，关于Android应用框架，中文相关介绍文章<a href=\"http://blog.zhaiyifan.cn/2016/01/29/android-app-architecture-2015/\" target=\"_blank\" rel=\"external\">看这里</a>。<br>演讲中有个demo，类似于一个QQ的聊天界面的程序，用这个例子讲解了如何优雅地处理在各种网络异常的情况下的UI界面，既如何设计一个offline的应用。<br>网络请求与本地缓存相结合以获取最好的用户体验应当是几乎所有Android应用的基本需求。从我的开发经验看，我们往往会忽略之一点。大部分情况下，都是直接从网络拿回数据显示在界面上，如果网络不好，就不断loading。。。在无网情况下，app是不可用的。</p>\n<ul>\n<li>拉逻辑–获取列表，此过程是我们最常用，我们大部分是获取数据然后展示给用户，仅仅需要本地有一份数据以备在无网时使用。这个逻辑在应用中基本是通用的。</li>\n<li><p>推逻辑–提交post，demo中对某些请求进行排队，在后台不断重试，这种逻辑对于某些应用应该是不适用的，毕竟大部分应用是不需要这种『强同步』的（既server与local完全一致，如聊天list或记账，微信发朋友圈）。在一般应用中以下两种情况更加常见：</p>\n<ul>\n<li>结果失败与否并不重要。如点赞这些功能，当然也可以这么干。</li>\n<li>操作是一些重要的不可重复操作，必须锁死屏幕。如提交订单，付款等。</li>\n</ul>\n</li>\n</ul>\n<p>选择哪一种交互是设计阶段必须考虑的，这直接决定了编码方式。当然，一个设计良好的框架必须要提供这些能力:</p>\n<ul>\n<li>封装网络请求与本地数据支持拉逻辑的操作，开发者可以选择是否先使用本地数据再等待网络更新。还是只使用网络数据。</li>\n<li>支持简单请求，锁死等待，还是异步的。</li>\n<li>支持后台可重复发送的请求–强同步–既Act locally, Sync globally。</li>\n</ul>\n<p>扯远了，需要一篇文章写一些app中可能用到各种交互与请求逻辑。</p>\n<p>下面翻译下Google这个demo的README文件。了解一下设计思想。</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这是个简单的社交软件，列表可以展示其他人的消息（我们叫他feed流），用户还可以发送文本信息。</p>\n<p>本文的目的是讲述如何设计一个应用，可以离线使用，并在网络可用时同步信息到服务器，尽量不影响用户。</p>\n<ul>\n<li>如何工作</li>\n<li>组件</li>\n<li>数据流<ul>\n<li>发送信息</li>\n<li>同步feed流</li>\n<li>保持UI更新</li>\n</ul>\n</li>\n<li>安装&amp;运行&amp;测试<ul>\n<li>安装</li>\n<li>运行</li>\n<li>测试</li>\n</ul>\n</li>\n<li>其他<ul>\n<li>避免重复发送信息 </li>\n</ul>\n</li>\n<li>版权许可</li>\n</ul>\n<h2 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h2><p>关于『离线设计』这个主题，许多解决方案都是依赖于特定的需求，如果想要运用到其他场景，需要一些修改。因此，这个demo的同步逻辑可能并不适合你的需求。你应当把它当做一个例子学习，然后找出适合你的应用的解决方案。不幸的是，没有设计离线应用的万金油。<br>这里，我们会解释用户的交互流是如何工作的，会给你的应用提供一些不错的想法。<br>这个例子没有严格依照任何的构架模式，它使用混合方法满足自己的需求。我们假设这个应用会不断成长为一个大的app（因此下面比较复杂）。尽管增加了复杂度，但是我没尽量是这个demo更加真实有用。</p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><ul>\n<li>Value Objects:<ul>\n<li>这些对象通常保持着数据库中存储的数据，这些对象也知道如何校验这些数据的合法性。如果Server发送了一下无效数据（比如，API改变了），我们可以在它们影响Model之前就忽略它们。</li>\n</ul>\n</li>\n<li>Models:<ul>\n<li>扶着数据持久化，保持到本地，并提供方法获取数据。</li>\n</ul>\n</li>\n<li>Controllers:<ul>\n<li>保存着应用程序主要逻辑，它决定如何做某事（如发送消息），处理gcm消息等。</li>\n</ul>\n</li>\n<li>Activities:<ul>\n<li>控制用户界面，他们知道哪里需要加载数据，什么时候需要刷新自己。</li>\n</ul>\n</li>\n<li>Events:<ul>\n<li>本demo使用一个全局的EventBus，它唯一的作用是通知UI更新。</li>\n<li>当UI需要从应用逻辑那里获取数据，直接调用相关方法就可以。这种设计符合Android这个UI生命周期短的设计。这种数据流也避免了UI和后台线程的循环引用。</li>\n</ul>\n</li>\n<li>Jobs:<ul>\n<li>他们可能是定义良好的网络操作（这比较典型，但未必）， 可以把你的应用逻辑拆分成多个job，这更方便测试和扩展。例如发送用户的文本消息到服务器就是一个job，同步用户的feed流到服务器也是个job。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h2><h3 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h3><p>当用户点击按钮，首先会发生这么4步：1.验证消息合法性。2.保持消息到本地磁盘存储（这个例子中这是一个job）。3.更新PostModel添加新的信息。4.发送event通知有消息更新。<br>（可选的）4.a.如果UI可见，在收到event后更新内容。<br>注意：上面这些步骤没有涉及网络，但是我已经更新了用户界面&amp;&amp;保持必要的数据到磁盘。最后，我们需要与Server同步。</p>\n<p>同步的步骤如下<br><img src=\"https://camo.githubusercontent.com/590b0315c04a7e5c0b429fbd521f99062aacde1d/68747470733a2f2f7777772e657665726e6f74652e636f6d2f73686172642f7331392f73682f31313036313730662d346637332d343531392d616537642d3466346166313364343138322f366562656436376534613734613461342f7265732f62656166626235362d633564632d346563622d393934662d3330653036616232313961342f736b697463682e706e67\" alt=\"Sync To Server\"></p>\n<ul>\n<li>优先级作业队列，负责处理持久化job，失败时的回退操作等，所以图中没有这些细节。</li>\n<li>一个真实环境的app应该与JobScheduler结合，确保消息在应用关闭后也可以发送。</li>\n<li>当job失败时，你最好保持一些信息到磁盘，那样下次用户打开app时，你可以通知他们发生了什么。这个demo中，当FeedActivity不可见时会显示系统通知。</li>\n</ul>\n<h3 id=\"同步Feed流\"><a href=\"#同步Feed流\" class=\"headerlink\" title=\"同步Feed流\"></a>同步Feed流</h3><p>同步操作有下面三个组件负责：</p>\n<ul>\n<li>FeedModel：<ul>\n<li>为每个feed流保存最后一条FeedItem（既发送的消息）的时间戳。这个时间戳有两个作用<ul>\n<li>当我们刷新feed流时，只接收最新的item。</li>\n<li>创建保存在本地的消息。本地创建的消息会显示在feed查询中是很重要的。 客户端的时间戳可能与server不同，只有当消息与Server同步时，我们分配feed最新的时间戳给这个新的消息。？？？</li>\n</ul>\n</li>\n<li>给UI层提供从数据库获取feed流的方法。</li>\n</ul>\n</li>\n<li>FeedController：<ul>\n<li>负责创建<code>FetchFeedJob</code></li>\n<li>监听消息更新失败，使用系统的通知栏通知用户。除非其他的UI组件（如FeedActivity）已经处理了错误。</li>\n<li>这个示例的app很基础，在真实环境中，它可能还要负责当有GCM推送到达时刷新feed流。以及包括一些防止用户频繁刷新的逻辑。</li>\n</ul>\n</li>\n<li>FetFeedJob：<ul>\n<li>发出API调用，获取某个feed流的最新消息列表。还负责更新model和发出event。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"保持UI更新\"><a href=\"#保持UI更新\" class=\"headerlink\" title=\"保持UI更新\"></a>保持UI更新</h3><p>后台与UI的交互需要良好的定义。</p>\n<ul>\n<li>等界面需要做某件事情时，UI直接调用某个方法（如发送消息）。</li>\n<li>后台任务结束时发出event通知UI更新（如更新失败）。</li>\n</ul>\n<p>UI组件根据自身的生命周期负责注册/反注册EventBus，因为后台永远不会持有UI的引用，我们不想有内存泄漏的风险。</p>\n<ul>\n<li>EventBus的使用可能引起一些特殊的情况：由于UI错过了一些event时，导致不同步。本Demo使用下面的规则避免这种清空。<ul>\n<li>当组件的生命周期开始时，先注册event，然后在再从model加载数据。</li>\n<li>当正在加载数据时，如果有event到来，会在数据加载完成后再次触发一次同步。</li>\n<li>所有的event都含有一个时间戳，它表示与该event相关的最老的item的时间。当UI访问model层时会使用这个时间戳，那么，如果item插入数据库时顺序不同，我们依然可以获取到这些item，因为我们使用了最老的时间戳。？？？</li>\n<li>当组件的生命周期结束时（例如<code>Activity#onStop</code>）,停止监听event。如果，我们再返回应用，他会做一个完整的同步，确保不会丢失在这期间发生的event。</li>\n</ul>\n</li>\n</ul>\n<p><strong>这不是唯一的办法</strong>：示例中使用的是一个全局的EventBus，你也可以用Rx实现相似的功能，或者手动设置listener，以及其他相似的技术。总之，你需要根据自己的应用来评估。</p>\n<h2 id=\"安装-amp-amp-运行-amp-amp-测试\"><a href=\"#安装-amp-amp-运行-amp-amp-测试\" class=\"headerlink\" title=\"安装&amp;&amp;运行&amp;&amp;测试\"></a>安装&amp;&amp;运行&amp;&amp;测试</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>demo包含一个简单的server，你需要安装Ruby On Rails来运行它。建议你通过<a href=\"https://rvm.io/\" target=\"_blank\" rel=\"external\">Ruby Version Manager</a>来安装。安装完之后，使用下面命令启动server：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; cd server;</div><div class=\"line\">&gt; bundle install;</div><div class=\"line\">&gt; rake db:migrate RAILS_ENV=development;</div></pre></td></tr></table></figure>\n<p>这会安装依赖，创建数据库。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><h4 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; cd server;</div><div class=\"line\">&gt; rails s</div></pre></td></tr></table></figure>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><p>demo中app使用模拟器环境默认的host地址。（<code>http://10.0.2.2:3000</code>）。如果你在模拟器里运行，已经可以正常工作。你可以在设置菜单中修改，或者在<code>DemoConfig</code>类中直接修改。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><ul>\n<li>服务器：服务端没有。。我又不关心。</li>\n<li>客户端：你可以这样运行测试 <code>&gt; cd client; &gt; ./gradlew clean app:connectedCheck app:test</code></li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"避免重复发送消息\"><a href=\"#避免重复发送消息\" class=\"headerlink\" title=\"避免重复发送消息\"></a>避免重复发送消息</h3><p>编写移动应用意味着你要处理不可靠的网络。通过使用持久化的job（存储在本地），在网络可用时，app工作了很不错，可是并不完美。在不可靠的网络条件下，我们的应用可能出现这种情况：服务端那数据已经更新存储了，但是客户端没有收到成功的返回。那么客户端依然认为消息没有上传，会不断重试。如果server的返回有问题，这就会变得更糟糕。<br>通常情况下，重试就以为这重复上传消息。有很多策略可以解决这个问题。demo中我们使用一个唯一的二维元组<code>(userId, clientId)</code>来避免重复，它的原理如下：</p>\n<ul>\n<li>客户端创建消息时，生成一个唯一的<code>clientId</code>（<code>UUID.randomUUID().toString()</code>,注：随着时间会变化）。这个UUID和用户ID的组合在客户端和服务端都是唯一的。</li>\n<li>当服务端收到消息时，检查这个元组是否存在，如果以及存在，不会新增一条存储记录，而是仅仅返回这个条目已经存在。</li>\n<li>当客户端获取feed时，如果发现一个消息的<code>(userId, client Id)</code>与某个存在的消息相同，会覆盖这存在的消息。这可能发生在这种情况下发生：客户端没有收到服务端的返回，只是本地保存了这个消息，，但是这个消息出现在其他某个请求的返回里面。？？需要这样吗</li>\n</ul>\n<p>你可以在<code>server/app/controllers/posts_controller.rb</code>中使用<code>error_before_saving_post</code>和<code>error_after_saving_post</code>来触发这种特殊的情况。</p>\n<h2 id=\"版权许可\"><a href=\"#版权许可\" class=\"headerlink\" title=\"版权许可\"></a>版权许可</h2><blockquote>\n<p>Copyright (C) 2015 The Android Open Source Project</p>\n<p>Licensed under the Apache License, Version 2.0 (the “License”);<br>you may not use this file except in compliance with the License.</p>\n<p>You may obtain a copy of the License at<br>  <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" target=\"_blank\" rel=\"external\">http://www.apache.org/licenses/LICENSE-2.0</a></p>\n<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>\n<p>See the License for the specific language governing permissions and limitations under the License.</p>\n</blockquote>\n","excerpt":"","more":"<p>近日，在Google开发者的微博上推荐了一个视频，是2015年开发者峰会上两位Google的Coder的演讲，关于Android应用框架，中文相关介绍文章<a href=\"http://blog.zhaiyifan.cn/2016/01/29/android-app-architecture-2015/\">看这里</a>。<br>演讲中有个demo，类似于一个QQ的聊天界面的程序，用这个例子讲解了如何优雅地处理在各种网络异常的情况下的UI界面，既如何设计一个offline的应用。<br>网络请求与本地缓存相结合以获取最好的用户体验应当是几乎所有Android应用的基本需求。从我的开发经验看，我们往往会忽略之一点。大部分情况下，都是直接从网络拿回数据显示在界面上，如果网络不好，就不断loading。。。在无网情况下，app是不可用的。</p>\n<ul>\n<li>拉逻辑–获取列表，此过程是我们最常用，我们大部分是获取数据然后展示给用户，仅仅需要本地有一份数据以备在无网时使用。这个逻辑在应用中基本是通用的。</li>\n<li><p>推逻辑–提交post，demo中对某些请求进行排队，在后台不断重试，这种逻辑对于某些应用应该是不适用的，毕竟大部分应用是不需要这种『强同步』的（既server与local完全一致，如聊天list或记账，微信发朋友圈）。在一般应用中以下两种情况更加常见：</p>\n<ul>\n<li>结果失败与否并不重要。如点赞这些功能，当然也可以这么干。</li>\n<li>操作是一些重要的不可重复操作，必须锁死屏幕。如提交订单，付款等。</li>\n</ul>\n</li>\n</ul>\n<p>选择哪一种交互是设计阶段必须考虑的，这直接决定了编码方式。当然，一个设计良好的框架必须要提供这些能力:</p>\n<ul>\n<li>封装网络请求与本地数据支持拉逻辑的操作，开发者可以选择是否先使用本地数据再等待网络更新。还是只使用网络数据。</li>\n<li>支持简单请求，锁死等待，还是异步的。</li>\n<li>支持后台可重复发送的请求–强同步–既Act locally, Sync globally。</li>\n</ul>\n<p>扯远了，需要一篇文章写一些app中可能用到各种交互与请求逻辑。</p>\n<p>下面翻译下Google这个demo的README文件。了解一下设计思想。</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这是个简单的社交软件，列表可以展示其他人的消息（我们叫他feed流），用户还可以发送文本信息。</p>\n<p>本文的目的是讲述如何设计一个应用，可以离线使用，并在网络可用时同步信息到服务器，尽量不影响用户。</p>\n<ul>\n<li>如何工作</li>\n<li>组件</li>\n<li>数据流<ul>\n<li>发送信息</li>\n<li>同步feed流</li>\n<li>保持UI更新</li>\n</ul>\n</li>\n<li>安装&amp;运行&amp;测试<ul>\n<li>安装</li>\n<li>运行</li>\n<li>测试</li>\n</ul>\n</li>\n<li>其他<ul>\n<li>避免重复发送信息 </li>\n</ul>\n</li>\n<li>版权许可</li>\n</ul>\n<h2 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h2><p>关于『离线设计』这个主题，许多解决方案都是依赖于特定的需求，如果想要运用到其他场景，需要一些修改。因此，这个demo的同步逻辑可能并不适合你的需求。你应当把它当做一个例子学习，然后找出适合你的应用的解决方案。不幸的是，没有设计离线应用的万金油。<br>这里，我们会解释用户的交互流是如何工作的，会给你的应用提供一些不错的想法。<br>这个例子没有严格依照任何的构架模式，它使用混合方法满足自己的需求。我们假设这个应用会不断成长为一个大的app（因此下面比较复杂）。尽管增加了复杂度，但是我没尽量是这个demo更加真实有用。</p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><ul>\n<li>Value Objects:<ul>\n<li>这些对象通常保持着数据库中存储的数据，这些对象也知道如何校验这些数据的合法性。如果Server发送了一下无效数据（比如，API改变了），我们可以在它们影响Model之前就忽略它们。</li>\n</ul>\n</li>\n<li>Models:<ul>\n<li>扶着数据持久化，保持到本地，并提供方法获取数据。</li>\n</ul>\n</li>\n<li>Controllers:<ul>\n<li>保存着应用程序主要逻辑，它决定如何做某事（如发送消息），处理gcm消息等。</li>\n</ul>\n</li>\n<li>Activities:<ul>\n<li>控制用户界面，他们知道哪里需要加载数据，什么时候需要刷新自己。</li>\n</ul>\n</li>\n<li>Events:<ul>\n<li>本demo使用一个全局的EventBus，它唯一的作用是通知UI更新。</li>\n<li>当UI需要从应用逻辑那里获取数据，直接调用相关方法就可以。这种设计符合Android这个UI生命周期短的设计。这种数据流也避免了UI和后台线程的循环引用。</li>\n</ul>\n</li>\n<li>Jobs:<ul>\n<li>他们可能是定义良好的网络操作（这比较典型，但未必）， 可以把你的应用逻辑拆分成多个job，这更方便测试和扩展。例如发送用户的文本消息到服务器就是一个job，同步用户的feed流到服务器也是个job。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h2><h3 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h3><p>当用户点击按钮，首先会发生这么4步：1.验证消息合法性。2.保持消息到本地磁盘存储（这个例子中这是一个job）。3.更新PostModel添加新的信息。4.发送event通知有消息更新。<br>（可选的）4.a.如果UI可见，在收到event后更新内容。<br>注意：上面这些步骤没有涉及网络，但是我已经更新了用户界面&amp;&amp;保持必要的数据到磁盘。最后，我们需要与Server同步。</p>\n<p>同步的步骤如下<br><img src=\"https://camo.githubusercontent.com/590b0315c04a7e5c0b429fbd521f99062aacde1d/68747470733a2f2f7777772e657665726e6f74652e636f6d2f73686172642f7331392f73682f31313036313730662d346637332d343531392d616537642d3466346166313364343138322f366562656436376534613734613461342f7265732f62656166626235362d633564632d346563622d393934662d3330653036616232313961342f736b697463682e706e67\" alt=\"Sync To Server\"></p>\n<ul>\n<li>优先级作业队列，负责处理持久化job，失败时的回退操作等，所以图中没有这些细节。</li>\n<li>一个真实环境的app应该与JobScheduler结合，确保消息在应用关闭后也可以发送。</li>\n<li>当job失败时，你最好保持一些信息到磁盘，那样下次用户打开app时，你可以通知他们发生了什么。这个demo中，当FeedActivity不可见时会显示系统通知。</li>\n</ul>\n<h3 id=\"同步Feed流\"><a href=\"#同步Feed流\" class=\"headerlink\" title=\"同步Feed流\"></a>同步Feed流</h3><p>同步操作有下面三个组件负责：</p>\n<ul>\n<li>FeedModel：<ul>\n<li>为每个feed流保存最后一条FeedItem（既发送的消息）的时间戳。这个时间戳有两个作用<ul>\n<li>当我们刷新feed流时，只接收最新的item。</li>\n<li>创建保存在本地的消息。本地创建的消息会显示在feed查询中是很重要的。 客户端的时间戳可能与server不同，只有当消息与Server同步时，我们分配feed最新的时间戳给这个新的消息。？？？</li>\n</ul>\n</li>\n<li>给UI层提供从数据库获取feed流的方法。</li>\n</ul>\n</li>\n<li>FeedController：<ul>\n<li>负责创建<code>FetchFeedJob</code></li>\n<li>监听消息更新失败，使用系统的通知栏通知用户。除非其他的UI组件（如FeedActivity）已经处理了错误。</li>\n<li>这个示例的app很基础，在真实环境中，它可能还要负责当有GCM推送到达时刷新feed流。以及包括一些防止用户频繁刷新的逻辑。</li>\n</ul>\n</li>\n<li>FetFeedJob：<ul>\n<li>发出API调用，获取某个feed流的最新消息列表。还负责更新model和发出event。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"保持UI更新\"><a href=\"#保持UI更新\" class=\"headerlink\" title=\"保持UI更新\"></a>保持UI更新</h3><p>后台与UI的交互需要良好的定义。</p>\n<ul>\n<li>等界面需要做某件事情时，UI直接调用某个方法（如发送消息）。</li>\n<li>后台任务结束时发出event通知UI更新（如更新失败）。</li>\n</ul>\n<p>UI组件根据自身的生命周期负责注册/反注册EventBus，因为后台永远不会持有UI的引用，我们不想有内存泄漏的风险。</p>\n<ul>\n<li>EventBus的使用可能引起一些特殊的情况：由于UI错过了一些event时，导致不同步。本Demo使用下面的规则避免这种清空。<ul>\n<li>当组件的生命周期开始时，先注册event，然后在再从model加载数据。</li>\n<li>当正在加载数据时，如果有event到来，会在数据加载完成后再次触发一次同步。</li>\n<li>所有的event都含有一个时间戳，它表示与该event相关的最老的item的时间。当UI访问model层时会使用这个时间戳，那么，如果item插入数据库时顺序不同，我们依然可以获取到这些item，因为我们使用了最老的时间戳。？？？</li>\n<li>当组件的生命周期结束时（例如<code>Activity#onStop</code>）,停止监听event。如果，我们再返回应用，他会做一个完整的同步，确保不会丢失在这期间发生的event。</li>\n</ul>\n</li>\n</ul>\n<p><strong>这不是唯一的办法</strong>：示例中使用的是一个全局的EventBus，你也可以用Rx实现相似的功能，或者手动设置listener，以及其他相似的技术。总之，你需要根据自己的应用来评估。</p>\n<h2 id=\"安装-amp-amp-运行-amp-amp-测试\"><a href=\"#安装-amp-amp-运行-amp-amp-测试\" class=\"headerlink\" title=\"安装&amp;&amp;运行&amp;&amp;测试\"></a>安装&amp;&amp;运行&amp;&amp;测试</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>demo包含一个简单的server，你需要安装Ruby On Rails来运行它。建议你通过<a href=\"https://rvm.io/\">Ruby Version Manager</a>来安装。安装完之后，使用下面命令启动server：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; cd server;</div><div class=\"line\">&gt; bundle install;</div><div class=\"line\">&gt; rake db:migrate RAILS_ENV=development;</div></pre></td></tr></table></figure>\n<p>这会安装依赖，创建数据库。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><h4 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; cd server;</div><div class=\"line\">&gt; rails s</div></pre></td></tr></table></figure>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><p>demo中app使用模拟器环境默认的host地址。（<code>http://10.0.2.2:3000</code>）。如果你在模拟器里运行，已经可以正常工作。你可以在设置菜单中修改，或者在<code>DemoConfig</code>类中直接修改。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><ul>\n<li>服务器：服务端没有。。我又不关心。</li>\n<li>客户端：你可以这样运行测试 <code>&gt; cd client; &gt; ./gradlew clean app:connectedCheck app:test</code></li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"避免重复发送消息\"><a href=\"#避免重复发送消息\" class=\"headerlink\" title=\"避免重复发送消息\"></a>避免重复发送消息</h3><p>编写移动应用意味着你要处理不可靠的网络。通过使用持久化的job（存储在本地），在网络可用时，app工作了很不错，可是并不完美。在不可靠的网络条件下，我们的应用可能出现这种情况：服务端那数据已经更新存储了，但是客户端没有收到成功的返回。那么客户端依然认为消息没有上传，会不断重试。如果server的返回有问题，这就会变得更糟糕。<br>通常情况下，重试就以为这重复上传消息。有很多策略可以解决这个问题。demo中我们使用一个唯一的二维元组<code>(userId, clientId)</code>来避免重复，它的原理如下：</p>\n<ul>\n<li>客户端创建消息时，生成一个唯一的<code>clientId</code>（<code>UUID.randomUUID().toString()</code>,注：随着时间会变化）。这个UUID和用户ID的组合在客户端和服务端都是唯一的。</li>\n<li>当服务端收到消息时，检查这个元组是否存在，如果以及存在，不会新增一条存储记录，而是仅仅返回这个条目已经存在。</li>\n<li>当客户端获取feed时，如果发现一个消息的<code>(userId, client Id)</code>与某个存在的消息相同，会覆盖这存在的消息。这可能发生在这种情况下发生：客户端没有收到服务端的返回，只是本地保存了这个消息，，但是这个消息出现在其他某个请求的返回里面。？？需要这样吗</li>\n</ul>\n<p>你可以在<code>server/app/controllers/posts_controller.rb</code>中使用<code>error_before_saving_post</code>和<code>error_after_saving_post</code>来触发这种特殊的情况。</p>\n<h2 id=\"版权许可\"><a href=\"#版权许可\" class=\"headerlink\" title=\"版权许可\"></a>版权许可</h2><blockquote>\n<p>Copyright (C) 2015 The Android Open Source Project</p>\n<p>Licensed under the Apache License, Version 2.0 (the “License”);<br>you may not use this file except in compliance with the License.</p>\n<p>You may obtain a copy of the License at<br>  <a href=\"http://www.apache.org/licenses/LICENSE-2.0\">http://www.apache.org/licenses/LICENSE-2.0</a></p>\n<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>\n<p>See the License for the specific language governing permissions and limitations under the License.</p>\n</blockquote>\n"},{"title":"一些感想--什么是重要的？","date":"2016-03-13T05:29:32.000Z","_content":"今天写一篇杂谈，谈谈自己的所思，所想。不知道是什么时候关注的笑来老师的公众号--**学习学习再学习**，关注了就放在那里，看着发的一篇篇『鸡汤』，甚至都懒得点击看看。去年的某日吧，无聊地在星巴克坐了半天，看了一下午他的文章，很有感触。不是寻常的『鸡汤』，很多的想法与自己不谋而合，很多想法让我惊喜。最重要的是让我思考一些忽略已久的东西：\n\n> **思考怎样去思考，学习如何去学习。**\n\n这是一个meta-problem。这是一个我还没有思考清楚的问题，也是最重要的问题。为什么是重要的？我想这需要一个判断标准，下面会粗浅的说一些我的理解。\n\n## 什么是重要的，什么又是最重要的\n\n一个重要的标准：\n\n> **那些影响越长远的东西，越重要**\n\n是当前重要的事情先做，还是当前收益小却会持续很久的事情先做？人是天生短视的动物，我们往往把眼前的事情放在第一位：今天的工作任务，明天的周报，这周的开发迭代，这个月的绩效。有时候即使是在做喜欢的事情，也会变得无趣。日积月累，渐渐的感到**空虚**。如果换一种方式思考：什么东西会持续人的一生呢？\n\n* 健康，活的好好的，有活力的\n* 财富，财务自由，不被金钱所累\n* 思考的能力，不被忽悠，学习的能力，思考会持续我们一生！\n* 学识，长期的学习，积累的知识能力\n\n似乎可以列出很多，多每个人的排序也不同。但是有他们一个特点：**这些都是要长期坚持的事情，不是几天，几个月，几年就能完成的。**\n\n于是可以反推出这么个结论：\n\n> **越是需要长期坚持的事情，越值得做**\n\n那么这些重要的事情，具体需要做什么？\n\n* 健康：锻炼/健身。这是需要长期坚持，然后持续收益的事情，越到后面收益越大。\n* 财富：理财。这也是需要坚持的，不断学习，不动摇，不跟风。越到后面收益越大。\n* 思考能力：阅读与冥想。学会如何思考，持续改进。越到后面收益越大。\n* 学识：阅读与总结，读什么书（会选择，思考的能力），越到后面收益越大。\n* 重要的技能：搜索引擎，还有呢？\n\n于是不管工作多么忙，不管有多少琐碎的事情，这些事情最应该先做：**健身，理财，读书，思考，总结。**总结的一种很好的方式就是：**写作/Blog。**\n\n如果一定要选一个最最重要的呢？我想一定是\n\n> **思考：思考如何思考，思考如何学习，思考是是逻辑的起点！**\n\n如果只看这么一句话，是多么的假大空。但仔细想来确是多么正确。思考的习惯会让我们去联系，去求证，去行动！于是，下面的结论可能是正确的，也可能是谬误！\n\n## 举个栗子\n举一些例子，来说说什么是重要的！\n\n1. 写代码与写博客 ---> 写博客\n2. 准点上班与早起运动 ---> 运动\n3. 提交代码与理财计划制定 ---> 理财计划制定\n3. 看《xxx编程指南/进阶编程》与看《Beyond Feelings》--->《Beyond Feelings》\n4. 实现一个功能与构架模块 ---> 构架模块\n5. 学开车与跑步 ---> 跑步\n6. 学开车与写代码 --> 开车\n\n随着我们思考与学识的增长，有些事情的重要性会改变，但是这些必然是有强大的逻辑基础的！\n\n发现没有，对程序员而言：\n\n> **写代码原来没有那么重要啊！**\n\n## 什么在阻碍我们\n\n* 不敢面对现实，承认问题：很多人这都不敢承认😪，所以没有开始。\n* 为什么会动摇，为什么会坚持：这个问题很有意思，一个根本原因：**缺乏思考+缺乏学识-->没清晰的逻辑-->对自己的决定没有信心**\n* 运气与惊喜：当你越早开始那些需要长期坚持的事情的时候，越到后期，越感觉坏运气少了。即使坏运气出现了，那么转换的概率变大了，往往是惊喜的伏笔。\n\n## 总之\n人生是由一个个选择构成的，当我们需要选择时，两个基本的逻辑决定什么是重要:\n\n> **影响越长远的东西，越重要**\n> \n> **越是需要长期坚持的事情，越值得做**\n\n还有：这篇不是鸡汤！如果要实践指南的话：\n\n> **选择一件需要长期坚持的事情开始做 -- 健身**\n","source":"_posts/一些感想-什么是重要的.md","raw":"title: 一些感想--什么是重要的？\ndate: 2016-03-13 13:29:32\ncategories:\n- 杂谈\ntags:\n- 成长\n---\n今天写一篇杂谈，谈谈自己的所思，所想。不知道是什么时候关注的笑来老师的公众号--**学习学习再学习**，关注了就放在那里，看着发的一篇篇『鸡汤』，甚至都懒得点击看看。去年的某日吧，无聊地在星巴克坐了半天，看了一下午他的文章，很有感触。不是寻常的『鸡汤』，很多的想法与自己不谋而合，很多想法让我惊喜。最重要的是让我思考一些忽略已久的东西：\n\n> **思考怎样去思考，学习如何去学习。**\n\n这是一个meta-problem。这是一个我还没有思考清楚的问题，也是最重要的问题。为什么是重要的？我想这需要一个判断标准，下面会粗浅的说一些我的理解。\n\n## 什么是重要的，什么又是最重要的\n\n一个重要的标准：\n\n> **那些影响越长远的东西，越重要**\n\n是当前重要的事情先做，还是当前收益小却会持续很久的事情先做？人是天生短视的动物，我们往往把眼前的事情放在第一位：今天的工作任务，明天的周报，这周的开发迭代，这个月的绩效。有时候即使是在做喜欢的事情，也会变得无趣。日积月累，渐渐的感到**空虚**。如果换一种方式思考：什么东西会持续人的一生呢？\n\n* 健康，活的好好的，有活力的\n* 财富，财务自由，不被金钱所累\n* 思考的能力，不被忽悠，学习的能力，思考会持续我们一生！\n* 学识，长期的学习，积累的知识能力\n\n似乎可以列出很多，多每个人的排序也不同。但是有他们一个特点：**这些都是要长期坚持的事情，不是几天，几个月，几年就能完成的。**\n\n于是可以反推出这么个结论：\n\n> **越是需要长期坚持的事情，越值得做**\n\n那么这些重要的事情，具体需要做什么？\n\n* 健康：锻炼/健身。这是需要长期坚持，然后持续收益的事情，越到后面收益越大。\n* 财富：理财。这也是需要坚持的，不断学习，不动摇，不跟风。越到后面收益越大。\n* 思考能力：阅读与冥想。学会如何思考，持续改进。越到后面收益越大。\n* 学识：阅读与总结，读什么书（会选择，思考的能力），越到后面收益越大。\n* 重要的技能：搜索引擎，还有呢？\n\n于是不管工作多么忙，不管有多少琐碎的事情，这些事情最应该先做：**健身，理财，读书，思考，总结。**总结的一种很好的方式就是：**写作/Blog。**\n\n如果一定要选一个最最重要的呢？我想一定是\n\n> **思考：思考如何思考，思考如何学习，思考是是逻辑的起点！**\n\n如果只看这么一句话，是多么的假大空。但仔细想来确是多么正确。思考的习惯会让我们去联系，去求证，去行动！于是，下面的结论可能是正确的，也可能是谬误！\n\n## 举个栗子\n举一些例子，来说说什么是重要的！\n\n1. 写代码与写博客 ---> 写博客\n2. 准点上班与早起运动 ---> 运动\n3. 提交代码与理财计划制定 ---> 理财计划制定\n3. 看《xxx编程指南/进阶编程》与看《Beyond Feelings》--->《Beyond Feelings》\n4. 实现一个功能与构架模块 ---> 构架模块\n5. 学开车与跑步 ---> 跑步\n6. 学开车与写代码 --> 开车\n\n随着我们思考与学识的增长，有些事情的重要性会改变，但是这些必然是有强大的逻辑基础的！\n\n发现没有，对程序员而言：\n\n> **写代码原来没有那么重要啊！**\n\n## 什么在阻碍我们\n\n* 不敢面对现实，承认问题：很多人这都不敢承认😪，所以没有开始。\n* 为什么会动摇，为什么会坚持：这个问题很有意思，一个根本原因：**缺乏思考+缺乏学识-->没清晰的逻辑-->对自己的决定没有信心**\n* 运气与惊喜：当你越早开始那些需要长期坚持的事情的时候，越到后期，越感觉坏运气少了。即使坏运气出现了，那么转换的概率变大了，往往是惊喜的伏笔。\n\n## 总之\n人生是由一个个选择构成的，当我们需要选择时，两个基本的逻辑决定什么是重要:\n\n> **影响越长远的东西，越重要**\n> \n> **越是需要长期坚持的事情，越值得做**\n\n还有：这篇不是鸡汤！如果要实践指南的话：\n\n> **选择一件需要长期坚持的事情开始做 -- 健身**\n","slug":"一些感想-什么是重要的","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbco000unac9sjcr5ggr","content":"<p>今天写一篇杂谈，谈谈自己的所思，所想。不知道是什么时候关注的笑来老师的公众号–<strong>学习学习再学习</strong>，关注了就放在那里，看着发的一篇篇『鸡汤』，甚至都懒得点击看看。去年的某日吧，无聊地在星巴克坐了半天，看了一下午他的文章，很有感触。不是寻常的『鸡汤』，很多的想法与自己不谋而合，很多想法让我惊喜。最重要的是让我思考一些忽略已久的东西：</p>\n<blockquote>\n<p><strong>思考怎样去思考，学习如何去学习。</strong></p>\n</blockquote>\n<p>这是一个meta-problem。这是一个我还没有思考清楚的问题，也是最重要的问题。为什么是重要的？我想这需要一个判断标准，下面会粗浅的说一些我的理解。</p>\n<h2 id=\"什么是重要的，什么又是最重要的\"><a href=\"#什么是重要的，什么又是最重要的\" class=\"headerlink\" title=\"什么是重要的，什么又是最重要的\"></a>什么是重要的，什么又是最重要的</h2><p>一个重要的标准：</p>\n<blockquote>\n<p><strong>那些影响越长远的东西，越重要</strong></p>\n</blockquote>\n<p>是当前重要的事情先做，还是当前收益小却会持续很久的事情先做？人是天生短视的动物，我们往往把眼前的事情放在第一位：今天的工作任务，明天的周报，这周的开发迭代，这个月的绩效。有时候即使是在做喜欢的事情，也会变得无趣。日积月累，渐渐的感到<strong>空虚</strong>。如果换一种方式思考：什么东西会持续人的一生呢？</p>\n<ul>\n<li>健康，活的好好的，有活力的</li>\n<li>财富，财务自由，不被金钱所累</li>\n<li>思考的能力，不被忽悠，学习的能力，思考会持续我们一生！</li>\n<li>学识，长期的学习，积累的知识能力</li>\n</ul>\n<p>似乎可以列出很多，多每个人的排序也不同。但是有他们一个特点：<strong>这些都是要长期坚持的事情，不是几天，几个月，几年就能完成的。</strong></p>\n<p>于是可以反推出这么个结论：</p>\n<blockquote>\n<p><strong>越是需要长期坚持的事情，越值得做</strong></p>\n</blockquote>\n<p>那么这些重要的事情，具体需要做什么？</p>\n<ul>\n<li>健康：锻炼/健身。这是需要长期坚持，然后持续收益的事情，越到后面收益越大。</li>\n<li>财富：理财。这也是需要坚持的，不断学习，不动摇，不跟风。越到后面收益越大。</li>\n<li>思考能力：阅读与冥想。学会如何思考，持续改进。越到后面收益越大。</li>\n<li>学识：阅读与总结，读什么书（会选择，思考的能力），越到后面收益越大。</li>\n<li>重要的技能：搜索引擎，还有呢？</li>\n</ul>\n<p>于是不管工作多么忙，不管有多少琐碎的事情，这些事情最应该先做：<strong>健身，理财，读书，思考，总结。</strong>总结的一种很好的方式就是：<strong>写作/Blog。</strong></p>\n<p>如果一定要选一个最最重要的呢？我想一定是</p>\n<blockquote>\n<p><strong>思考：思考如何思考，思考如何学习，思考是是逻辑的起点！</strong></p>\n</blockquote>\n<p>如果只看这么一句话，是多么的假大空。但仔细想来确是多么正确。思考的习惯会让我们去联系，去求证，去行动！于是，下面的结论可能是正确的，也可能是谬误！</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>举一些例子，来说说什么是重要的！</p>\n<ol>\n<li>写代码与写博客 —&gt; 写博客</li>\n<li>准点上班与早起运动 —&gt; 运动</li>\n<li>提交代码与理财计划制定 —&gt; 理财计划制定</li>\n<li>看《xxx编程指南/进阶编程》与看《Beyond Feelings》—&gt;《Beyond Feelings》</li>\n<li>实现一个功能与构架模块 —&gt; 构架模块</li>\n<li>学开车与跑步 —&gt; 跑步</li>\n<li>学开车与写代码 –&gt; 开车</li>\n</ol>\n<p>随着我们思考与学识的增长，有些事情的重要性会改变，但是这些必然是有强大的逻辑基础的！</p>\n<p>发现没有，对程序员而言：</p>\n<blockquote>\n<p><strong>写代码原来没有那么重要啊！</strong></p>\n</blockquote>\n<h2 id=\"什么在阻碍我们\"><a href=\"#什么在阻碍我们\" class=\"headerlink\" title=\"什么在阻碍我们\"></a>什么在阻碍我们</h2><ul>\n<li>不敢面对现实，承认问题：很多人这都不敢承认😪，所以没有开始。</li>\n<li>为什么会动摇，为什么会坚持：这个问题很有意思，一个根本原因：<strong>缺乏思考+缺乏学识–&gt;没清晰的逻辑–&gt;对自己的决定没有信心</strong></li>\n<li>运气与惊喜：当你越早开始那些需要长期坚持的事情的时候，越到后期，越感觉坏运气少了。即使坏运气出现了，那么转换的概率变大了，往往是惊喜的伏笔。</li>\n</ul>\n<h2 id=\"总之\"><a href=\"#总之\" class=\"headerlink\" title=\"总之\"></a>总之</h2><p>人生是由一个个选择构成的，当我们需要选择时，两个基本的逻辑决定什么是重要:</p>\n<blockquote>\n<p><strong>影响越长远的东西，越重要</strong></p>\n<p><strong>越是需要长期坚持的事情，越值得做</strong></p>\n</blockquote>\n<p>还有：这篇不是鸡汤！如果要实践指南的话：</p>\n<blockquote>\n<p><strong>选择一件需要长期坚持的事情开始做 – 健身</strong></p>\n</blockquote>\n","excerpt":"","more":"<p>今天写一篇杂谈，谈谈自己的所思，所想。不知道是什么时候关注的笑来老师的公众号–<strong>学习学习再学习</strong>，关注了就放在那里，看着发的一篇篇『鸡汤』，甚至都懒得点击看看。去年的某日吧，无聊地在星巴克坐了半天，看了一下午他的文章，很有感触。不是寻常的『鸡汤』，很多的想法与自己不谋而合，很多想法让我惊喜。最重要的是让我思考一些忽略已久的东西：</p>\n<blockquote>\n<p><strong>思考怎样去思考，学习如何去学习。</strong></p>\n</blockquote>\n<p>这是一个meta-problem。这是一个我还没有思考清楚的问题，也是最重要的问题。为什么是重要的？我想这需要一个判断标准，下面会粗浅的说一些我的理解。</p>\n<h2 id=\"什么是重要的，什么又是最重要的\"><a href=\"#什么是重要的，什么又是最重要的\" class=\"headerlink\" title=\"什么是重要的，什么又是最重要的\"></a>什么是重要的，什么又是最重要的</h2><p>一个重要的标准：</p>\n<blockquote>\n<p><strong>那些影响越长远的东西，越重要</strong></p>\n</blockquote>\n<p>是当前重要的事情先做，还是当前收益小却会持续很久的事情先做？人是天生短视的动物，我们往往把眼前的事情放在第一位：今天的工作任务，明天的周报，这周的开发迭代，这个月的绩效。有时候即使是在做喜欢的事情，也会变得无趣。日积月累，渐渐的感到<strong>空虚</strong>。如果换一种方式思考：什么东西会持续人的一生呢？</p>\n<ul>\n<li>健康，活的好好的，有活力的</li>\n<li>财富，财务自由，不被金钱所累</li>\n<li>思考的能力，不被忽悠，学习的能力，思考会持续我们一生！</li>\n<li>学识，长期的学习，积累的知识能力</li>\n</ul>\n<p>似乎可以列出很多，多每个人的排序也不同。但是有他们一个特点：<strong>这些都是要长期坚持的事情，不是几天，几个月，几年就能完成的。</strong></p>\n<p>于是可以反推出这么个结论：</p>\n<blockquote>\n<p><strong>越是需要长期坚持的事情，越值得做</strong></p>\n</blockquote>\n<p>那么这些重要的事情，具体需要做什么？</p>\n<ul>\n<li>健康：锻炼/健身。这是需要长期坚持，然后持续收益的事情，越到后面收益越大。</li>\n<li>财富：理财。这也是需要坚持的，不断学习，不动摇，不跟风。越到后面收益越大。</li>\n<li>思考能力：阅读与冥想。学会如何思考，持续改进。越到后面收益越大。</li>\n<li>学识：阅读与总结，读什么书（会选择，思考的能力），越到后面收益越大。</li>\n<li>重要的技能：搜索引擎，还有呢？</li>\n</ul>\n<p>于是不管工作多么忙，不管有多少琐碎的事情，这些事情最应该先做：<strong>健身，理财，读书，思考，总结。</strong>总结的一种很好的方式就是：<strong>写作/Blog。</strong></p>\n<p>如果一定要选一个最最重要的呢？我想一定是</p>\n<blockquote>\n<p><strong>思考：思考如何思考，思考如何学习，思考是是逻辑的起点！</strong></p>\n</blockquote>\n<p>如果只看这么一句话，是多么的假大空。但仔细想来确是多么正确。思考的习惯会让我们去联系，去求证，去行动！于是，下面的结论可能是正确的，也可能是谬误！</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>举一些例子，来说说什么是重要的！</p>\n<ol>\n<li>写代码与写博客 —&gt; 写博客</li>\n<li>准点上班与早起运动 —&gt; 运动</li>\n<li>提交代码与理财计划制定 —&gt; 理财计划制定</li>\n<li>看《xxx编程指南/进阶编程》与看《Beyond Feelings》—&gt;《Beyond Feelings》</li>\n<li>实现一个功能与构架模块 —&gt; 构架模块</li>\n<li>学开车与跑步 —&gt; 跑步</li>\n<li>学开车与写代码 –&gt; 开车</li>\n</ol>\n<p>随着我们思考与学识的增长，有些事情的重要性会改变，但是这些必然是有强大的逻辑基础的！</p>\n<p>发现没有，对程序员而言：</p>\n<blockquote>\n<p><strong>写代码原来没有那么重要啊！</strong></p>\n</blockquote>\n<h2 id=\"什么在阻碍我们\"><a href=\"#什么在阻碍我们\" class=\"headerlink\" title=\"什么在阻碍我们\"></a>什么在阻碍我们</h2><ul>\n<li>不敢面对现实，承认问题：很多人这都不敢承认😪，所以没有开始。</li>\n<li>为什么会动摇，为什么会坚持：这个问题很有意思，一个根本原因：<strong>缺乏思考+缺乏学识–&gt;没清晰的逻辑–&gt;对自己的决定没有信心</strong></li>\n<li>运气与惊喜：当你越早开始那些需要长期坚持的事情的时候，越到后期，越感觉坏运气少了。即使坏运气出现了，那么转换的概率变大了，往往是惊喜的伏笔。</li>\n</ul>\n<h2 id=\"总之\"><a href=\"#总之\" class=\"headerlink\" title=\"总之\"></a>总之</h2><p>人生是由一个个选择构成的，当我们需要选择时，两个基本的逻辑决定什么是重要:</p>\n<blockquote>\n<p><strong>影响越长远的东西，越重要</strong></p>\n<p><strong>越是需要长期坚持的事情，越值得做</strong></p>\n</blockquote>\n<p>还有：这篇不是鸡汤！如果要实践指南的话：</p>\n<blockquote>\n<p><strong>选择一件需要长期坚持的事情开始做 – 健身</strong></p>\n</blockquote>\n"},{"title":"全沾Growth工程师学习计划","date":"2016-07-03T06:14:44.000Z","_content":"\n关于最近的学习计划，3个月的时间(7、8、9三个月)做一名全沾工程师。全沾是指对各个方面的技术的框架有几个基本了解，Growth是指如果需要深入可以快速成长切入。\n\n## 技术清单\n\n* 前端：\n  * 移动端\n    * Android/IOS App开发（以后可以RN开发）\n  * web开发\n    * HTML\n    * CSS\n    * JavaScript\n* 后端\n  * NodeJS\n  * Redis MySql\n  * JSP  Spring MVC+Spring+Hibernate \n* 运维\n  * Nginix\n  * 虚拟机，容灾\n  * 性能优化 分库分表\n* 设计UX\n  * 设计工具Sketch\n  * 设计基础原则学习\n* 运营\n  * 数据分析 \n  * 广告 推广 SEO 流量 \n\n## 学习方式\n\n以一个博客系统为实践相关知识。先使用一种最简单的技术栈实现，然后用其他技术栈实现，形成对比。然后分析不同方案，思考如何大并发等问题，挑选不同技术形成\"最优\"方案。\n\n## 学习计划\n安排12周的时间（大概75天，每天6--8小时）进行学习，重点偏向技术，UX和运营有个基本的认识，没有时间可以延后。\n\n使用思维导图描绘学习路径\n\n### 第一周\n总体目标：html/css/javascript完成，nodejs入门，博客启动，初步打通前后端。\n\n- [x] 周一 javascript对象模型，原型模式\n- [x] 周二 前后端框架初探，Growth全栈增长工程师指南138\n- [x] 周三 html/css 3WSchool教程看完 \n- [x] 周四 CSS相关，javascript语法\n- [x] 周五 javascript语法 http://javascript.ruanyifeng.com/\n- [x] 周末 javascript语法 http://javascript.ruanyifeng.com/\n\n\n第二周\n\n-[ ] 周一 [javascript语法完成]( http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n-[ ] 周二 node入门搭建\n-[ ] 周三  \n-[ ] 周四 \n-[ ] 周五 \n-[ ] 周末 \n\n","source":"_posts/全沾Growth工程师学习计划.md","raw":"title: 全沾Growth工程师学习计划\ndate: 2016-07-03 14:14:44\ncategories:\n- 技术\n\ntags:\n- Guide\n---\n\n关于最近的学习计划，3个月的时间(7、8、9三个月)做一名全沾工程师。全沾是指对各个方面的技术的框架有几个基本了解，Growth是指如果需要深入可以快速成长切入。\n\n## 技术清单\n\n* 前端：\n  * 移动端\n    * Android/IOS App开发（以后可以RN开发）\n  * web开发\n    * HTML\n    * CSS\n    * JavaScript\n* 后端\n  * NodeJS\n  * Redis MySql\n  * JSP  Spring MVC+Spring+Hibernate \n* 运维\n  * Nginix\n  * 虚拟机，容灾\n  * 性能优化 分库分表\n* 设计UX\n  * 设计工具Sketch\n  * 设计基础原则学习\n* 运营\n  * 数据分析 \n  * 广告 推广 SEO 流量 \n\n## 学习方式\n\n以一个博客系统为实践相关知识。先使用一种最简单的技术栈实现，然后用其他技术栈实现，形成对比。然后分析不同方案，思考如何大并发等问题，挑选不同技术形成\"最优\"方案。\n\n## 学习计划\n安排12周的时间（大概75天，每天6--8小时）进行学习，重点偏向技术，UX和运营有个基本的认识，没有时间可以延后。\n\n使用思维导图描绘学习路径\n\n### 第一周\n总体目标：html/css/javascript完成，nodejs入门，博客启动，初步打通前后端。\n\n- [x] 周一 javascript对象模型，原型模式\n- [x] 周二 前后端框架初探，Growth全栈增长工程师指南138\n- [x] 周三 html/css 3WSchool教程看完 \n- [x] 周四 CSS相关，javascript语法\n- [x] 周五 javascript语法 http://javascript.ruanyifeng.com/\n- [x] 周末 javascript语法 http://javascript.ruanyifeng.com/\n\n\n第二周\n\n-[ ] 周一 [javascript语法完成]( http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n-[ ] 周二 node入门搭建\n-[ ] 周三  \n-[ ] 周四 \n-[ ] 周五 \n-[ ] 周末 \n\n","slug":"全沾Growth工程师学习计划","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbcr000xnac91tzln2c4","content":"<p>关于最近的学习计划，3个月的时间(7、8、9三个月)做一名全沾工程师。全沾是指对各个方面的技术的框架有几个基本了解，Growth是指如果需要深入可以快速成长切入。</p>\n<h2 id=\"技术清单\"><a href=\"#技术清单\" class=\"headerlink\" title=\"技术清单\"></a>技术清单</h2><ul>\n<li>前端：<ul>\n<li>移动端<ul>\n<li>Android/IOS App开发（以后可以RN开发）</li>\n</ul>\n</li>\n<li>web开发<ul>\n<li>HTML</li>\n<li>CSS</li>\n<li>JavaScript</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>后端<ul>\n<li>NodeJS</li>\n<li>Redis MySql</li>\n<li>JSP  Spring MVC+Spring+Hibernate </li>\n</ul>\n</li>\n<li>运维<ul>\n<li>Nginix</li>\n<li>虚拟机，容灾</li>\n<li>性能优化 分库分表</li>\n</ul>\n</li>\n<li>设计UX<ul>\n<li>设计工具Sketch</li>\n<li>设计基础原则学习</li>\n</ul>\n</li>\n<li>运营<ul>\n<li>数据分析 </li>\n<li>广告 推广 SEO 流量 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"学习方式\"><a href=\"#学习方式\" class=\"headerlink\" title=\"学习方式\"></a>学习方式</h2><p>以一个博客系统为实践相关知识。先使用一种最简单的技术栈实现，然后用其他技术栈实现，形成对比。然后分析不同方案，思考如何大并发等问题，挑选不同技术形成”最优”方案。</p>\n<h2 id=\"学习计划\"><a href=\"#学习计划\" class=\"headerlink\" title=\"学习计划\"></a>学习计划</h2><p>安排12周的时间（大概75天，每天6–8小时）进行学习，重点偏向技术，UX和运营有个基本的认识，没有时间可以延后。</p>\n<p>使用思维导图描绘学习路径</p>\n<h3 id=\"第一周\"><a href=\"#第一周\" class=\"headerlink\" title=\"第一周\"></a>第一周</h3><p>总体目标：html/css/javascript完成，nodejs入门，博客启动，初步打通前后端。</p>\n<ul>\n<li>[x] 周一 javascript对象模型，原型模式</li>\n<li>[x] 周二 前后端框架初探，Growth全栈增长工程师指南138</li>\n<li>[x] 周三 html/css 3WSchool教程看完 </li>\n<li>[x] 周四 CSS相关，javascript语法</li>\n<li>[x] 周五 javascript语法 <a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"external\">http://javascript.ruanyifeng.com/</a></li>\n<li>[x] 周末 javascript语法 <a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"external\">http://javascript.ruanyifeng.com/</a></li>\n</ul>\n<p>第二周</p>\n<p>-[ ] 周一 <a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"external\">javascript语法完成</a><br>-[ ] 周二 node入门搭建<br>-[ ] 周三<br>-[ ] 周四<br>-[ ] 周五<br>-[ ] 周末 </p>\n","excerpt":"","more":"<p>关于最近的学习计划，3个月的时间(7、8、9三个月)做一名全沾工程师。全沾是指对各个方面的技术的框架有几个基本了解，Growth是指如果需要深入可以快速成长切入。</p>\n<h2 id=\"技术清单\"><a href=\"#技术清单\" class=\"headerlink\" title=\"技术清单\"></a>技术清单</h2><ul>\n<li>前端：<ul>\n<li>移动端<ul>\n<li>Android/IOS App开发（以后可以RN开发）</li>\n</ul>\n</li>\n<li>web开发<ul>\n<li>HTML</li>\n<li>CSS</li>\n<li>JavaScript</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>后端<ul>\n<li>NodeJS</li>\n<li>Redis MySql</li>\n<li>JSP  Spring MVC+Spring+Hibernate </li>\n</ul>\n</li>\n<li>运维<ul>\n<li>Nginix</li>\n<li>虚拟机，容灾</li>\n<li>性能优化 分库分表</li>\n</ul>\n</li>\n<li>设计UX<ul>\n<li>设计工具Sketch</li>\n<li>设计基础原则学习</li>\n</ul>\n</li>\n<li>运营<ul>\n<li>数据分析 </li>\n<li>广告 推广 SEO 流量 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"学习方式\"><a href=\"#学习方式\" class=\"headerlink\" title=\"学习方式\"></a>学习方式</h2><p>以一个博客系统为实践相关知识。先使用一种最简单的技术栈实现，然后用其他技术栈实现，形成对比。然后分析不同方案，思考如何大并发等问题，挑选不同技术形成”最优”方案。</p>\n<h2 id=\"学习计划\"><a href=\"#学习计划\" class=\"headerlink\" title=\"学习计划\"></a>学习计划</h2><p>安排12周的时间（大概75天，每天6–8小时）进行学习，重点偏向技术，UX和运营有个基本的认识，没有时间可以延后。</p>\n<p>使用思维导图描绘学习路径</p>\n<h3 id=\"第一周\"><a href=\"#第一周\" class=\"headerlink\" title=\"第一周\"></a>第一周</h3><p>总体目标：html/css/javascript完成，nodejs入门，博客启动，初步打通前后端。</p>\n<ul>\n<li>[x] 周一 javascript对象模型，原型模式</li>\n<li>[x] 周二 前后端框架初探，Growth全栈增长工程师指南138</li>\n<li>[x] 周三 html/css 3WSchool教程看完 </li>\n<li>[x] 周四 CSS相关，javascript语法</li>\n<li>[x] 周五 javascript语法 <a href=\"http://javascript.ruanyifeng.com/\">http://javascript.ruanyifeng.com/</a></li>\n<li>[x] 周末 javascript语法 <a href=\"http://javascript.ruanyifeng.com/\">http://javascript.ruanyifeng.com/</a></li>\n</ul>\n<p>第二周</p>\n<p>-[ ] 周一 <a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\">javascript语法完成</a><br>-[ ] 周二 node入门搭建<br>-[ ] 周三<br>-[ ] 周四<br>-[ ] 周五<br>-[ ] 周末 </p>\n"},{"title":"始发站，将通往何处","date":"2016-01-10T04:36:26.000Z","sticky":10,"description":"从零开始构建一个用于生产环境的Android App，要走这些路。这篇文章是博客的总目录，会持续更新。同时也是我的一个起点，一些思考。优先写一些感兴趣的技术点，最后形成一个体系，完成构建一个可持续改进的用于生产环境的App的目标。当然也可能扩展到Server和IOS的其他方面。","_content":"\n起床，吃饭，就到了晌午。\n这周的任务还没有完成，在家里总是慵懒的状态，转念来到楼下的咖啡馆--HappyTree，躺在沙发上思考这个奇怪的问题。不想写鸡汤或者感悟，但是这文风不对啊！\n这是一篇Guide，罗列**一些技术的兴奋点**（G点？）。虽然我属于杂牌军系列，什么都想搞一些，可是现在还是专注于Android方向。\n\n## 切入点\n不管在哪工作，一直都在思考或者观察这两个问题\n\n* **如何搭建一个高效的开发框架**\n* 如何组建一个有战斗力的团队\n\n本文主要从第一点思考问题，一个合格的框架是怎样组成的？谈谈我经历的两个团队（有机会写文章细谈），第一团队，简单规范的开发框架，入门程序员也可以完成开发，第二个团队，项目太久，框架太多导致没有框架，自由发挥。理所当然地认为前者niubility，后者太low。但是在第一个团队有一种错觉，技术就是这些东西，没有什么可以说的了。直到现在，**当自己思考如何构建一个框架的时候，发现世界如此精彩。**\n用时刻准备创业的心态去思考工作。所以，现在我在始发站，总有一天会启程。最近有一篇很不错的微信团队的文章[《创业码农的一些建议》](https://simpleton.gitbooks.io/sim-tech-note/content/Android/AndroidStartupTutorial.html)，核心思想:**\"不要重复发明轮子\"，当然这不意味着不需要知道怎么制造轮子。**那么，看看如何用这些轮子来造车。\n\n\n## 构建一个App\n一个完备的app应当具有这些基础能力\n\n* 网络能力（https、下载、升级等）\n* 图片库\n* 数据库框架\n* 开发框架（模式）\n* 公共库/控件库/工具库\n* apk打包与瘦身\n* bug跟踪机制/质量保证\n* 用户分析系统\n* 推送机制/长连接方案\n* 对内规范（工程结构、代码style等）\n* 对外规范（接口规范、沟通规范）\n\n\n一个优秀的app应当具有这些技术能力\n\n* 灰度发布能力\n* 插件化技术\n* 热修复技术\n* Android测试技术\n* mock系统\n* 性能优化（内存，启动时间等）\n* apk安全问题\n\n团队协作的基础设施\n\n* 版本管理工具\n* Code Review工具\n* 持续集成\n\n### 网络能力\n[okhttp](https://github.com/square/okhttp) 现在使用中，http基础库，良好的同步/异步接口\n\n[android-async-http](https://github.com/loopj/android-async-http) 之前使用，比较老，功能也比较完备\n\n> okhttp\\android-async-http\\volley\\retrofit 比较\n> okhttp 和 async http是一个基础的通信库，都很强大，但需要自己封装使用才更方便。另外okhttp已经被谷歌官方用在android源码中了。 retrofit和 volley是属于比较高级点的封装库了。其中 retrofit是默认使用okhttp，volley也支持okhttp作为其底层通信的部件。retrofit的特点是使用清晰简单的接口，非常方便，而 volley在使用的时候也还简单，不过要使用高级一点的功能需要自己自定义很多东西，个人常用 **retrofit+okhttp**\n链接：https://www.zhihu.com/question/35189851/answer/62857319\n来源：知乎\n\n[Gson](https://github.com/google/gson) json解析，一直使用这个库\n\n[jackson]() 没有使用过，有空研究一下\n\n> jackson gson fastjson\n> jackson 似乎有优势，尤其是大文件多并发的情况下\n\n\n### 图片库\n[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader) 使用过且阅读过源码，比较简单，功能较弱，无法很好应当OOM\n\n[Glide]() 目前使用的的库，在非专业图片应用中强烈推荐，综合各种数据最优秀的Lib，同时也是Google推荐的。支持gif（webp动图不支持？video支持？）源码中大量的接口的设计，十分值得学习。大小500kb以内。\n\n[fresco](https://github.com/facebook/fresco) 最优秀的内存管理和最强大的功能，支持WebP动图。FB出品，一些黑科技，代码复杂，压缩后通用安装包代码1M（包含两个平台的so）。\n\n> Fresco vs UIL vs Glide vs Piasso\n> UIL 比较老，功能比较弱（不支持Gif WebP）,\n> Fresco最为强大，问题是对外接口不友好（需要替换ImageView），在使用过程遇到问题很难修改源码解决问题，比较复杂，建议不是图片特别重的App不要使用。\n> Piasso 都没有使用过，对外接口简单。据说：『Glide的性能更好一些，并且支持更多格式的图片』，以后有时间调研一下Glide。\n\n### 数据库框架\nDBFlow\n### 开发框架\n这里包括且不限于：一些设计模式（MVC等），一些多线程工具库（代替AsyncTask，如Bolts等）\n\n[Bolts-Android](https://github.com/BoltsFramework/Bolts-Android) android多线程，取代AsyncTask作为统一的线程池。具有链式调用的结构，可指定运行的不通线程。FB出品，现在在使用中，入门简单，使用代价很小。\n\n[MVP && MVVM](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)    MVP是在开发中常用的设计模式，当前使用中。\n\n[Flow 思想](http://zhuanlan.zhihu.com/FrontendMagazine/19900243) 一种单向数据流的思想，在React框架中使用，可以在移动开发中使用。FB出名，学习ing，没有实践过。\n> Flow VS MVP ?\n\n[RxJava RxAndroid](https://github.com/ReactiveX/RxAndroid) ReactiveX的Java版本和Android扩展，强大！链式调用，可以代替Bolts的所有功能（也可以封装后代替EventBus），一种完备的开发框架（思想）。微软出品，学习中，入门较难，对团队要求很高，可以极大简化代码。\n\n[EventBus](https://github.com/greenrobot/EventBus) 一种总线机制，使用发布-订阅的方式解耦模块，没有使用过。类似的还有[Otto](https://github.com/square/otto)\n\n> 关于一些团队内部使用的框架：大致思想类似于bolts这一类框架再封装一下网络框架。方便开发者快速发起Rest请求并且在合适的线程处理数据和UI。\n> \n> 其他：\n> [EventBus VS RxJava ](https://www.zhihu.com/question/32179258)\n> \n> 待补充：一些其他的注入框架，和如何联合使用这些框架。\n\n### 公共库/控件库/工具库\n待补充，主要是一些通用的公共组件和工具类，可能包含BaseActivity\\BaseFragment,xxxUtils。一些动画库nineOld\n[Timber](https://www.youtube.com/watch?v=0BEkVaPlU9A&feature=youtu.be)：开源日志记录函数库，JakeWharton开发，默认打印类名。\n[其他辅助开发工具](http://tech.luffyjet.com/2015/04/10/android-debug-tools-hugo-scalpel-timber/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n### bug跟踪机制/质量保证\n发现问题的能力是App的一种重要的能力，类似百度使用的Crab平台跟踪用户崩溃和bug率是重要的。\n\n[bug跟踪系统](https://get.fabric.io/?locale=zh-cn) 上报用户崩溃数据，部分用户分析工具具备此功能（如GA），但是建议加入专门的bug上报工具，类似百，功能强大。\n\n[用户反馈的设计]() 一般app都需要反馈模块供用户主动反应问题。\n\n[性能、内存监控]() 主要是开发阶段使用，暴露问题。例如LeakCanary、BlockCanary\n\n### 用户分析系统\n跟踪用户行为，收集数据是持续优化的基础，也是产品重要能力。基本的埋点机制或者类似于Google Analyse的分析系统\n\n[App埋点设计与数据上报]()\n\n[接入第三方分析系统]() 获取用户行为数据，形成画像是这些系统的重要功能。\n\n### 推送机制/长连接方案\n推送的第三方方案，信鸽、other？\n部分应用可能需要长连接，MQTT\n\n### 对内规范\n[构建工程结构]() 如何构建合理的工程结构，依据业务？功能？，如何方便扩展功能，发布不通版本？\n\n[代码Style](https://github.com/square/java-code-styles) Square的java-code-styles,也可以自己fork做相应的修改\n\n[资源Style]() Android特有的问题，dimens,styles,strings中按照UI需求设计一些基本的公共值（业务无关？）。否则会导致不可控。\n\n[代码检测]() 代码静态检测，动态检测，提前发现潜在问题，提高代码质量。\n\n[CodeReview]() 代码提交commit前的审核流程\n\n### 对外规范\n[网络请求]() http or https，get or post ,是否使用私有证书？\n\n[json格式规范]() 使用标准的json格式，定义合理的返回结构和状态码（错误码建议不要使用http head中的代码，部分广告工具/防火墙拦截，而是定义在json中）。\n\n[加密方式服规范]() 定义不同信息的安全等级以及对应加密算法--DES or RSA or MD5校验\n\n[迭代流程与发版规范]() 敏捷流程，灰度/发版标准（bug率？）\n\n[问题解决流程]() 次奥，这些问题太多了\n\n### 灰度发布\n待研究，GooglePlay具有此功能，也可以自行开发，对于用户量较多的App此功能具有重要意义，防止新版本问题影响到全部用户和验证功能效果都有作用。\n\n### 插件化技术\n[简单可靠的插件化技术](https://github.com/wequick/Small) 插件化是大型产品的框架需求，尤其是平台化产品或者对App安装包大小有严格限制的应用。同时也是对65535限制的技术解决方案。\n\n### 热修复技术\n[热修复技术研究](http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/) 热修复技术是产品上线后紧急修复的需要，是对灰度发布补充。\n\n### mock系统\nclient团队内部开发使用，可以部分解决server与client开发不协调的问题，尤其是server进度慢于client的情况，也可以用于client程序员自己调试程序。\n\n### 性能优化\nApp迭代到一定阶段，自然而然地会进入这么一个阶段。一个好的框架可能会暂时隐藏这些问题。但是对系统的持续监控（性能分析报告）是必不可少，及早发现问题与定位，寻求时间优化问题十分重要。\n\n### 版本管理工具\n[git](http://www.bootcss.com/p/git-guide/) 使用较多的版本管理工具，代替svn等传统工具\n[git flow](http://nvie.com/posts/a-successful-git-branching-model/)  git版本管理的工作流的最佳实践。满足正式开发、新特性预研、灰度、Release等版本的发布需求。\n[git服务器搭建]()\n[gitlab](https://about.gitlab.com/gitlab-com/) 开源的本地管理系统，类似github的功能\n\n### Code Review工具\n[Gerrit]() 适用于团队内部开发代码提交审核的工具。以及该工具与IDE、Git的集成。\n\n### 持续集成\n[jenkins+git+gerrit方案]() 将Android的Gradle build 持续集成\n\n> 是否考虑第三方服务？\n\n\n## 趋势\n作为一个程序员，能感受到Android开发技术发展迅速，新技术目不暇接。**分享一些信息获取[渠道](http://www.limuzhi.com/read/)**。对于趋势，类比于其他技术是种不错的思路，[《从中间件的历史来看移动App开发的未来》](http://blog.jobbole.com/91662/)给我一些启发。\n\n[React](http://www.ruanyifeng.com/blog/2015/03/react.html) FB提出的一种Js的mvc开发框架，虚拟dom具有高效的特点，并且可以扩展到App中。JavaScript有望占领前后端(Node.js)和各个平台。\n\n[React Native](http://www.androidweekly.cn/android-dev-special-weekly-react-native/) React的android版本，有望取代其他的hybrid开发框架。\n\n\n## 最后一些话\n至此，基本总结了App开发的技术点，留了很多坑等着以后慢慢填，每一点展开都能写很多。后续会不断更新这些文章到自己的博文，也可能增删一些内容。从哪里开始写还没有想好，期间会插入一些小项目。打算在春节前写一个抢红包的系列文章，主要分析一些抢红包插件的源码。\n\n本人一年多的工作经验，大部分的内容也在探索中或者只有一些概念，任何问题欢迎提出。","source":"_posts/始发站，将通往何处.md","raw":"title: 始发站，将通往何处\ndate: 2016-01-10 12:36:26\nsticky: 10\ndescription: 从零开始构建一个用于生产环境的Android App，要走这些路。这篇文章是博客的总目录，会持续更新。同时也是我的一个起点，一些思考。优先写一些感兴趣的技术点，最后形成一个体系，完成构建一个可持续改进的用于生产环境的App的目标。当然也可能扩展到Server和IOS的其他方面。\ncategories:\n- 技术\ntags:\n- Android\n- Guide\n- 最佳实践 \n---\n\n起床，吃饭，就到了晌午。\n这周的任务还没有完成，在家里总是慵懒的状态，转念来到楼下的咖啡馆--HappyTree，躺在沙发上思考这个奇怪的问题。不想写鸡汤或者感悟，但是这文风不对啊！\n这是一篇Guide，罗列**一些技术的兴奋点**（G点？）。虽然我属于杂牌军系列，什么都想搞一些，可是现在还是专注于Android方向。\n\n## 切入点\n不管在哪工作，一直都在思考或者观察这两个问题\n\n* **如何搭建一个高效的开发框架**\n* 如何组建一个有战斗力的团队\n\n本文主要从第一点思考问题，一个合格的框架是怎样组成的？谈谈我经历的两个团队（有机会写文章细谈），第一团队，简单规范的开发框架，入门程序员也可以完成开发，第二个团队，项目太久，框架太多导致没有框架，自由发挥。理所当然地认为前者niubility，后者太low。但是在第一个团队有一种错觉，技术就是这些东西，没有什么可以说的了。直到现在，**当自己思考如何构建一个框架的时候，发现世界如此精彩。**\n用时刻准备创业的心态去思考工作。所以，现在我在始发站，总有一天会启程。最近有一篇很不错的微信团队的文章[《创业码农的一些建议》](https://simpleton.gitbooks.io/sim-tech-note/content/Android/AndroidStartupTutorial.html)，核心思想:**\"不要重复发明轮子\"，当然这不意味着不需要知道怎么制造轮子。**那么，看看如何用这些轮子来造车。\n\n\n## 构建一个App\n一个完备的app应当具有这些基础能力\n\n* 网络能力（https、下载、升级等）\n* 图片库\n* 数据库框架\n* 开发框架（模式）\n* 公共库/控件库/工具库\n* apk打包与瘦身\n* bug跟踪机制/质量保证\n* 用户分析系统\n* 推送机制/长连接方案\n* 对内规范（工程结构、代码style等）\n* 对外规范（接口规范、沟通规范）\n\n\n一个优秀的app应当具有这些技术能力\n\n* 灰度发布能力\n* 插件化技术\n* 热修复技术\n* Android测试技术\n* mock系统\n* 性能优化（内存，启动时间等）\n* apk安全问题\n\n团队协作的基础设施\n\n* 版本管理工具\n* Code Review工具\n* 持续集成\n\n### 网络能力\n[okhttp](https://github.com/square/okhttp) 现在使用中，http基础库，良好的同步/异步接口\n\n[android-async-http](https://github.com/loopj/android-async-http) 之前使用，比较老，功能也比较完备\n\n> okhttp\\android-async-http\\volley\\retrofit 比较\n> okhttp 和 async http是一个基础的通信库，都很强大，但需要自己封装使用才更方便。另外okhttp已经被谷歌官方用在android源码中了。 retrofit和 volley是属于比较高级点的封装库了。其中 retrofit是默认使用okhttp，volley也支持okhttp作为其底层通信的部件。retrofit的特点是使用清晰简单的接口，非常方便，而 volley在使用的时候也还简单，不过要使用高级一点的功能需要自己自定义很多东西，个人常用 **retrofit+okhttp**\n链接：https://www.zhihu.com/question/35189851/answer/62857319\n来源：知乎\n\n[Gson](https://github.com/google/gson) json解析，一直使用这个库\n\n[jackson]() 没有使用过，有空研究一下\n\n> jackson gson fastjson\n> jackson 似乎有优势，尤其是大文件多并发的情况下\n\n\n### 图片库\n[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader) 使用过且阅读过源码，比较简单，功能较弱，无法很好应当OOM\n\n[Glide]() 目前使用的的库，在非专业图片应用中强烈推荐，综合各种数据最优秀的Lib，同时也是Google推荐的。支持gif（webp动图不支持？video支持？）源码中大量的接口的设计，十分值得学习。大小500kb以内。\n\n[fresco](https://github.com/facebook/fresco) 最优秀的内存管理和最强大的功能，支持WebP动图。FB出品，一些黑科技，代码复杂，压缩后通用安装包代码1M（包含两个平台的so）。\n\n> Fresco vs UIL vs Glide vs Piasso\n> UIL 比较老，功能比较弱（不支持Gif WebP）,\n> Fresco最为强大，问题是对外接口不友好（需要替换ImageView），在使用过程遇到问题很难修改源码解决问题，比较复杂，建议不是图片特别重的App不要使用。\n> Piasso 都没有使用过，对外接口简单。据说：『Glide的性能更好一些，并且支持更多格式的图片』，以后有时间调研一下Glide。\n\n### 数据库框架\nDBFlow\n### 开发框架\n这里包括且不限于：一些设计模式（MVC等），一些多线程工具库（代替AsyncTask，如Bolts等）\n\n[Bolts-Android](https://github.com/BoltsFramework/Bolts-Android) android多线程，取代AsyncTask作为统一的线程池。具有链式调用的结构，可指定运行的不通线程。FB出品，现在在使用中，入门简单，使用代价很小。\n\n[MVP && MVVM](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)    MVP是在开发中常用的设计模式，当前使用中。\n\n[Flow 思想](http://zhuanlan.zhihu.com/FrontendMagazine/19900243) 一种单向数据流的思想，在React框架中使用，可以在移动开发中使用。FB出名，学习ing，没有实践过。\n> Flow VS MVP ?\n\n[RxJava RxAndroid](https://github.com/ReactiveX/RxAndroid) ReactiveX的Java版本和Android扩展，强大！链式调用，可以代替Bolts的所有功能（也可以封装后代替EventBus），一种完备的开发框架（思想）。微软出品，学习中，入门较难，对团队要求很高，可以极大简化代码。\n\n[EventBus](https://github.com/greenrobot/EventBus) 一种总线机制，使用发布-订阅的方式解耦模块，没有使用过。类似的还有[Otto](https://github.com/square/otto)\n\n> 关于一些团队内部使用的框架：大致思想类似于bolts这一类框架再封装一下网络框架。方便开发者快速发起Rest请求并且在合适的线程处理数据和UI。\n> \n> 其他：\n> [EventBus VS RxJava ](https://www.zhihu.com/question/32179258)\n> \n> 待补充：一些其他的注入框架，和如何联合使用这些框架。\n\n### 公共库/控件库/工具库\n待补充，主要是一些通用的公共组件和工具类，可能包含BaseActivity\\BaseFragment,xxxUtils。一些动画库nineOld\n[Timber](https://www.youtube.com/watch?v=0BEkVaPlU9A&feature=youtu.be)：开源日志记录函数库，JakeWharton开发，默认打印类名。\n[其他辅助开发工具](http://tech.luffyjet.com/2015/04/10/android-debug-tools-hugo-scalpel-timber/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n### bug跟踪机制/质量保证\n发现问题的能力是App的一种重要的能力，类似百度使用的Crab平台跟踪用户崩溃和bug率是重要的。\n\n[bug跟踪系统](https://get.fabric.io/?locale=zh-cn) 上报用户崩溃数据，部分用户分析工具具备此功能（如GA），但是建议加入专门的bug上报工具，类似百，功能强大。\n\n[用户反馈的设计]() 一般app都需要反馈模块供用户主动反应问题。\n\n[性能、内存监控]() 主要是开发阶段使用，暴露问题。例如LeakCanary、BlockCanary\n\n### 用户分析系统\n跟踪用户行为，收集数据是持续优化的基础，也是产品重要能力。基本的埋点机制或者类似于Google Analyse的分析系统\n\n[App埋点设计与数据上报]()\n\n[接入第三方分析系统]() 获取用户行为数据，形成画像是这些系统的重要功能。\n\n### 推送机制/长连接方案\n推送的第三方方案，信鸽、other？\n部分应用可能需要长连接，MQTT\n\n### 对内规范\n[构建工程结构]() 如何构建合理的工程结构，依据业务？功能？，如何方便扩展功能，发布不通版本？\n\n[代码Style](https://github.com/square/java-code-styles) Square的java-code-styles,也可以自己fork做相应的修改\n\n[资源Style]() Android特有的问题，dimens,styles,strings中按照UI需求设计一些基本的公共值（业务无关？）。否则会导致不可控。\n\n[代码检测]() 代码静态检测，动态检测，提前发现潜在问题，提高代码质量。\n\n[CodeReview]() 代码提交commit前的审核流程\n\n### 对外规范\n[网络请求]() http or https，get or post ,是否使用私有证书？\n\n[json格式规范]() 使用标准的json格式，定义合理的返回结构和状态码（错误码建议不要使用http head中的代码，部分广告工具/防火墙拦截，而是定义在json中）。\n\n[加密方式服规范]() 定义不同信息的安全等级以及对应加密算法--DES or RSA or MD5校验\n\n[迭代流程与发版规范]() 敏捷流程，灰度/发版标准（bug率？）\n\n[问题解决流程]() 次奥，这些问题太多了\n\n### 灰度发布\n待研究，GooglePlay具有此功能，也可以自行开发，对于用户量较多的App此功能具有重要意义，防止新版本问题影响到全部用户和验证功能效果都有作用。\n\n### 插件化技术\n[简单可靠的插件化技术](https://github.com/wequick/Small) 插件化是大型产品的框架需求，尤其是平台化产品或者对App安装包大小有严格限制的应用。同时也是对65535限制的技术解决方案。\n\n### 热修复技术\n[热修复技术研究](http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/) 热修复技术是产品上线后紧急修复的需要，是对灰度发布补充。\n\n### mock系统\nclient团队内部开发使用，可以部分解决server与client开发不协调的问题，尤其是server进度慢于client的情况，也可以用于client程序员自己调试程序。\n\n### 性能优化\nApp迭代到一定阶段，自然而然地会进入这么一个阶段。一个好的框架可能会暂时隐藏这些问题。但是对系统的持续监控（性能分析报告）是必不可少，及早发现问题与定位，寻求时间优化问题十分重要。\n\n### 版本管理工具\n[git](http://www.bootcss.com/p/git-guide/) 使用较多的版本管理工具，代替svn等传统工具\n[git flow](http://nvie.com/posts/a-successful-git-branching-model/)  git版本管理的工作流的最佳实践。满足正式开发、新特性预研、灰度、Release等版本的发布需求。\n[git服务器搭建]()\n[gitlab](https://about.gitlab.com/gitlab-com/) 开源的本地管理系统，类似github的功能\n\n### Code Review工具\n[Gerrit]() 适用于团队内部开发代码提交审核的工具。以及该工具与IDE、Git的集成。\n\n### 持续集成\n[jenkins+git+gerrit方案]() 将Android的Gradle build 持续集成\n\n> 是否考虑第三方服务？\n\n\n## 趋势\n作为一个程序员，能感受到Android开发技术发展迅速，新技术目不暇接。**分享一些信息获取[渠道](http://www.limuzhi.com/read/)**。对于趋势，类比于其他技术是种不错的思路，[《从中间件的历史来看移动App开发的未来》](http://blog.jobbole.com/91662/)给我一些启发。\n\n[React](http://www.ruanyifeng.com/blog/2015/03/react.html) FB提出的一种Js的mvc开发框架，虚拟dom具有高效的特点，并且可以扩展到App中。JavaScript有望占领前后端(Node.js)和各个平台。\n\n[React Native](http://www.androidweekly.cn/android-dev-special-weekly-react-native/) React的android版本，有望取代其他的hybrid开发框架。\n\n\n## 最后一些话\n至此，基本总结了App开发的技术点，留了很多坑等着以后慢慢填，每一点展开都能写很多。后续会不断更新这些文章到自己的博文，也可能增删一些内容。从哪里开始写还没有想好，期间会插入一些小项目。打算在春节前写一个抢红包的系列文章，主要分析一些抢红包插件的源码。\n\n本人一年多的工作经验，大部分的内容也在探索中或者只有一些概念，任何问题欢迎提出。","slug":"始发站，将通往何处","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbcs0012nac9qwj84y5t","content":"<p>起床，吃饭，就到了晌午。<br>这周的任务还没有完成，在家里总是慵懒的状态，转念来到楼下的咖啡馆–HappyTree，躺在沙发上思考这个奇怪的问题。不想写鸡汤或者感悟，但是这文风不对啊！<br>这是一篇Guide，罗列<strong>一些技术的兴奋点</strong>（G点？）。虽然我属于杂牌军系列，什么都想搞一些，可是现在还是专注于Android方向。</p>\n<h2 id=\"切入点\"><a href=\"#切入点\" class=\"headerlink\" title=\"切入点\"></a>切入点</h2><p>不管在哪工作，一直都在思考或者观察这两个问题</p>\n<ul>\n<li><strong>如何搭建一个高效的开发框架</strong></li>\n<li>如何组建一个有战斗力的团队</li>\n</ul>\n<p>本文主要从第一点思考问题，一个合格的框架是怎样组成的？谈谈我经历的两个团队（有机会写文章细谈），第一团队，简单规范的开发框架，入门程序员也可以完成开发，第二个团队，项目太久，框架太多导致没有框架，自由发挥。理所当然地认为前者niubility，后者太low。但是在第一个团队有一种错觉，技术就是这些东西，没有什么可以说的了。直到现在，<strong>当自己思考如何构建一个框架的时候，发现世界如此精彩。</strong><br>用时刻准备创业的心态去思考工作。所以，现在我在始发站，总有一天会启程。最近有一篇很不错的微信团队的文章<a href=\"https://simpleton.gitbooks.io/sim-tech-note/content/Android/AndroidStartupTutorial.html\" target=\"_blank\" rel=\"external\">《创业码农的一些建议》</a>，核心思想:<strong>“不要重复发明轮子”，当然这不意味着不需要知道怎么制造轮子。</strong>那么，看看如何用这些轮子来造车。</p>\n<h2 id=\"构建一个App\"><a href=\"#构建一个App\" class=\"headerlink\" title=\"构建一个App\"></a>构建一个App</h2><p>一个完备的app应当具有这些基础能力</p>\n<ul>\n<li>网络能力（https、下载、升级等）</li>\n<li>图片库</li>\n<li>数据库框架</li>\n<li>开发框架（模式）</li>\n<li>公共库/控件库/工具库</li>\n<li>apk打包与瘦身</li>\n<li>bug跟踪机制/质量保证</li>\n<li>用户分析系统</li>\n<li>推送机制/长连接方案</li>\n<li>对内规范（工程结构、代码style等）</li>\n<li>对外规范（接口规范、沟通规范）</li>\n</ul>\n<p>一个优秀的app应当具有这些技术能力</p>\n<ul>\n<li>灰度发布能力</li>\n<li>插件化技术</li>\n<li>热修复技术</li>\n<li>Android测试技术</li>\n<li>mock系统</li>\n<li>性能优化（内存，启动时间等）</li>\n<li>apk安全问题</li>\n</ul>\n<p>团队协作的基础设施</p>\n<ul>\n<li>版本管理工具</li>\n<li>Code Review工具</li>\n<li>持续集成</li>\n</ul>\n<h3 id=\"网络能力\"><a href=\"#网络能力\" class=\"headerlink\" title=\"网络能力\"></a>网络能力</h3><p><a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"external\">okhttp</a> 现在使用中，http基础库，良好的同步/异步接口</p>\n<p><a href=\"https://github.com/loopj/android-async-http\" target=\"_blank\" rel=\"external\">android-async-http</a> 之前使用，比较老，功能也比较完备</p>\n<blockquote>\n<p>okhttp\\android-async-http\\volley\\retrofit 比较<br>okhttp 和 async http是一个基础的通信库，都很强大，但需要自己封装使用才更方便。另外okhttp已经被谷歌官方用在android源码中了。 retrofit和 volley是属于比较高级点的封装库了。其中 retrofit是默认使用okhttp，volley也支持okhttp作为其底层通信的部件。retrofit的特点是使用清晰简单的接口，非常方便，而 volley在使用的时候也还简单，不过要使用高级一点的功能需要自己自定义很多东西，个人常用 <strong>retrofit+okhttp</strong><br>链接：<a href=\"https://www.zhihu.com/question/35189851/answer/62857319\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/35189851/answer/62857319</a><br>来源：知乎</p>\n</blockquote>\n<p><a href=\"https://github.com/google/gson\" target=\"_blank\" rel=\"external\">Gson</a> json解析，一直使用这个库</p>\n<p><a href=\"\">jackson</a> 没有使用过，有空研究一下</p>\n<blockquote>\n<p>jackson gson fastjson<br>jackson 似乎有优势，尤其是大文件多并发的情况下</p>\n</blockquote>\n<h3 id=\"图片库\"><a href=\"#图片库\" class=\"headerlink\" title=\"图片库\"></a>图片库</h3><p><a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\" target=\"_blank\" rel=\"external\">Android-Universal-Image-Loader</a> 使用过且阅读过源码，比较简单，功能较弱，无法很好应当OOM</p>\n<p><a href=\"\">Glide</a> 目前使用的的库，在非专业图片应用中强烈推荐，综合各种数据最优秀的Lib，同时也是Google推荐的。支持gif（webp动图不支持？video支持？）源码中大量的接口的设计，十分值得学习。大小500kb以内。</p>\n<p><a href=\"https://github.com/facebook/fresco\" target=\"_blank\" rel=\"external\">fresco</a> 最优秀的内存管理和最强大的功能，支持WebP动图。FB出品，一些黑科技，代码复杂，压缩后通用安装包代码1M（包含两个平台的so）。</p>\n<blockquote>\n<p>Fresco vs UIL vs Glide vs Piasso<br>UIL 比较老，功能比较弱（不支持Gif WebP）,<br>Fresco最为强大，问题是对外接口不友好（需要替换ImageView），在使用过程遇到问题很难修改源码解决问题，比较复杂，建议不是图片特别重的App不要使用。<br>Piasso 都没有使用过，对外接口简单。据说：『Glide的性能更好一些，并且支持更多格式的图片』，以后有时间调研一下Glide。</p>\n</blockquote>\n<h3 id=\"数据库框架\"><a href=\"#数据库框架\" class=\"headerlink\" title=\"数据库框架\"></a>数据库框架</h3><p>DBFlow</p>\n<h3 id=\"开发框架\"><a href=\"#开发框架\" class=\"headerlink\" title=\"开发框架\"></a>开发框架</h3><p>这里包括且不限于：一些设计模式（MVC等），一些多线程工具库（代替AsyncTask，如Bolts等）</p>\n<p><a href=\"https://github.com/BoltsFramework/Bolts-Android\" target=\"_blank\" rel=\"external\">Bolts-Android</a> android多线程，取代AsyncTask作为统一的线程池。具有链式调用的结构，可指定运行的不通线程。FB出品，现在在使用中，入门简单，使用代价很小。</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\" target=\"_blank\" rel=\"external\">MVP &amp;&amp; MVVM</a>    MVP是在开发中常用的设计模式，当前使用中。</p>\n<p><a href=\"http://zhuanlan.zhihu.com/FrontendMagazine/19900243\" target=\"_blank\" rel=\"external\">Flow 思想</a> 一种单向数据流的思想，在React框架中使用，可以在移动开发中使用。FB出名，学习ing，没有实践过。</p>\n<blockquote>\n<p>Flow VS MVP ?</p>\n</blockquote>\n<p><a href=\"https://github.com/ReactiveX/RxAndroid\" target=\"_blank\" rel=\"external\">RxJava RxAndroid</a> ReactiveX的Java版本和Android扩展，强大！链式调用，可以代替Bolts的所有功能（也可以封装后代替EventBus），一种完备的开发框架（思想）。微软出品，学习中，入门较难，对团队要求很高，可以极大简化代码。</p>\n<p><a href=\"https://github.com/greenrobot/EventBus\" target=\"_blank\" rel=\"external\">EventBus</a> 一种总线机制，使用发布-订阅的方式解耦模块，没有使用过。类似的还有<a href=\"https://github.com/square/otto\" target=\"_blank\" rel=\"external\">Otto</a></p>\n<blockquote>\n<p>关于一些团队内部使用的框架：大致思想类似于bolts这一类框架再封装一下网络框架。方便开发者快速发起Rest请求并且在合适的线程处理数据和UI。</p>\n<p>其他：<br><a href=\"https://www.zhihu.com/question/32179258\" target=\"_blank\" rel=\"external\">EventBus VS RxJava </a></p>\n<p>待补充：一些其他的注入框架，和如何联合使用这些框架。</p>\n</blockquote>\n<h3 id=\"公共库-控件库-工具库\"><a href=\"#公共库-控件库-工具库\" class=\"headerlink\" title=\"公共库/控件库/工具库\"></a>公共库/控件库/工具库</h3><p>待补充，主要是一些通用的公共组件和工具类，可能包含BaseActivity\\BaseFragment,xxxUtils。一些动画库nineOld<br><a href=\"https://www.youtube.com/watch?v=0BEkVaPlU9A&amp;feature=youtu.be\" target=\"_blank\" rel=\"external\">Timber</a>：开源日志记录函数库，JakeWharton开发，默认打印类名。<br><a href=\"http://tech.luffyjet.com/2015/04/10/android-debug-tools-hugo-scalpel-timber/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"external\">其他辅助开发工具</a></p>\n<h3 id=\"bug跟踪机制-质量保证\"><a href=\"#bug跟踪机制-质量保证\" class=\"headerlink\" title=\"bug跟踪机制/质量保证\"></a>bug跟踪机制/质量保证</h3><p>发现问题的能力是App的一种重要的能力，类似百度使用的Crab平台跟踪用户崩溃和bug率是重要的。</p>\n<p><a href=\"https://get.fabric.io/?locale=zh-cn\" target=\"_blank\" rel=\"external\">bug跟踪系统</a> 上报用户崩溃数据，部分用户分析工具具备此功能（如GA），但是建议加入专门的bug上报工具，类似百，功能强大。</p>\n<p><a href=\"\">用户反馈的设计</a> 一般app都需要反馈模块供用户主动反应问题。</p>\n<p><a href=\"\">性能、内存监控</a> 主要是开发阶段使用，暴露问题。例如LeakCanary、BlockCanary</p>\n<h3 id=\"用户分析系统\"><a href=\"#用户分析系统\" class=\"headerlink\" title=\"用户分析系统\"></a>用户分析系统</h3><p>跟踪用户行为，收集数据是持续优化的基础，也是产品重要能力。基本的埋点机制或者类似于Google Analyse的分析系统</p>\n<p><a href=\"\">App埋点设计与数据上报</a></p>\n<p><a href=\"\">接入第三方分析系统</a> 获取用户行为数据，形成画像是这些系统的重要功能。</p>\n<h3 id=\"推送机制-长连接方案\"><a href=\"#推送机制-长连接方案\" class=\"headerlink\" title=\"推送机制/长连接方案\"></a>推送机制/长连接方案</h3><p>推送的第三方方案，信鸽、other？<br>部分应用可能需要长连接，MQTT</p>\n<h3 id=\"对内规范\"><a href=\"#对内规范\" class=\"headerlink\" title=\"对内规范\"></a>对内规范</h3><p><a href=\"\">构建工程结构</a> 如何构建合理的工程结构，依据业务？功能？，如何方便扩展功能，发布不通版本？</p>\n<p><a href=\"https://github.com/square/java-code-styles\" target=\"_blank\" rel=\"external\">代码Style</a> Square的java-code-styles,也可以自己fork做相应的修改</p>\n<p><a href=\"\">资源Style</a> Android特有的问题，dimens,styles,strings中按照UI需求设计一些基本的公共值（业务无关？）。否则会导致不可控。</p>\n<p><a href=\"\">代码检测</a> 代码静态检测，动态检测，提前发现潜在问题，提高代码质量。</p>\n<p><a href=\"\">CodeReview</a> 代码提交commit前的审核流程</p>\n<h3 id=\"对外规范\"><a href=\"#对外规范\" class=\"headerlink\" title=\"对外规范\"></a>对外规范</h3><p><a href=\"\">网络请求</a> http or https，get or post ,是否使用私有证书？</p>\n<p><a href=\"\">json格式规范</a> 使用标准的json格式，定义合理的返回结构和状态码（错误码建议不要使用http head中的代码，部分广告工具/防火墙拦截，而是定义在json中）。</p>\n<p><a href=\"\">加密方式服规范</a> 定义不同信息的安全等级以及对应加密算法–DES or RSA or MD5校验</p>\n<p><a href=\"\">迭代流程与发版规范</a> 敏捷流程，灰度/发版标准（bug率？）</p>\n<p><a href=\"\">问题解决流程</a> 次奥，这些问题太多了</p>\n<h3 id=\"灰度发布\"><a href=\"#灰度发布\" class=\"headerlink\" title=\"灰度发布\"></a>灰度发布</h3><p>待研究，GooglePlay具有此功能，也可以自行开发，对于用户量较多的App此功能具有重要意义，防止新版本问题影响到全部用户和验证功能效果都有作用。</p>\n<h3 id=\"插件化技术\"><a href=\"#插件化技术\" class=\"headerlink\" title=\"插件化技术\"></a>插件化技术</h3><p><a href=\"https://github.com/wequick/Small\" target=\"_blank\" rel=\"external\">简单可靠的插件化技术</a> 插件化是大型产品的框架需求，尤其是平台化产品或者对App安装包大小有严格限制的应用。同时也是对65535限制的技术解决方案。</p>\n<h3 id=\"热修复技术\"><a href=\"#热修复技术\" class=\"headerlink\" title=\"热修复技术\"></a>热修复技术</h3><p><a href=\"http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/\" target=\"_blank\" rel=\"external\">热修复技术研究</a> 热修复技术是产品上线后紧急修复的需要，是对灰度发布补充。</p>\n<h3 id=\"mock系统\"><a href=\"#mock系统\" class=\"headerlink\" title=\"mock系统\"></a>mock系统</h3><p>client团队内部开发使用，可以部分解决server与client开发不协调的问题，尤其是server进度慢于client的情况，也可以用于client程序员自己调试程序。</p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p>App迭代到一定阶段，自然而然地会进入这么一个阶段。一个好的框架可能会暂时隐藏这些问题。但是对系统的持续监控（性能分析报告）是必不可少，及早发现问题与定位，寻求时间优化问题十分重要。</p>\n<h3 id=\"版本管理工具\"><a href=\"#版本管理工具\" class=\"headerlink\" title=\"版本管理工具\"></a>版本管理工具</h3><p><a href=\"http://www.bootcss.com/p/git-guide/\" target=\"_blank\" rel=\"external\">git</a> 使用较多的版本管理工具，代替svn等传统工具<br><a href=\"http://nvie.com/posts/a-successful-git-branching-model/\" target=\"_blank\" rel=\"external\">git flow</a>  git版本管理的工作流的最佳实践。满足正式开发、新特性预研、灰度、Release等版本的发布需求。<br><a href=\"\">git服务器搭建</a><br><a href=\"https://about.gitlab.com/gitlab-com/\" target=\"_blank\" rel=\"external\">gitlab</a> 开源的本地管理系统，类似github的功能</p>\n<h3 id=\"Code-Review工具\"><a href=\"#Code-Review工具\" class=\"headerlink\" title=\"Code Review工具\"></a>Code Review工具</h3><p><a href=\"\">Gerrit</a> 适用于团队内部开发代码提交审核的工具。以及该工具与IDE、Git的集成。</p>\n<h3 id=\"持续集成\"><a href=\"#持续集成\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h3><p><a href=\"\">jenkins+git+gerrit方案</a> 将Android的Gradle build 持续集成</p>\n<blockquote>\n<p>是否考虑第三方服务？</p>\n</blockquote>\n<h2 id=\"趋势\"><a href=\"#趋势\" class=\"headerlink\" title=\"趋势\"></a>趋势</h2><p>作为一个程序员，能感受到Android开发技术发展迅速，新技术目不暇接。<strong>分享一些信息获取<a href=\"http://www.limuzhi.com/read/\" target=\"_blank\" rel=\"external\">渠道</a></strong>。对于趋势，类比于其他技术是种不错的思路，<a href=\"http://blog.jobbole.com/91662/\" target=\"_blank\" rel=\"external\">《从中间件的历史来看移动App开发的未来》</a>给我一些启发。</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"external\">React</a> FB提出的一种Js的mvc开发框架，虚拟dom具有高效的特点，并且可以扩展到App中。JavaScript有望占领前后端(Node.js)和各个平台。</p>\n<p><a href=\"http://www.androidweekly.cn/android-dev-special-weekly-react-native/\" target=\"_blank\" rel=\"external\">React Native</a> React的android版本，有望取代其他的hybrid开发框架。</p>\n<h2 id=\"最后一些话\"><a href=\"#最后一些话\" class=\"headerlink\" title=\"最后一些话\"></a>最后一些话</h2><p>至此，基本总结了App开发的技术点，留了很多坑等着以后慢慢填，每一点展开都能写很多。后续会不断更新这些文章到自己的博文，也可能增删一些内容。从哪里开始写还没有想好，期间会插入一些小项目。打算在春节前写一个抢红包的系列文章，主要分析一些抢红包插件的源码。</p>\n<p>本人一年多的工作经验，大部分的内容也在探索中或者只有一些概念，任何问题欢迎提出。</p>\n","excerpt":"","more":"<p>起床，吃饭，就到了晌午。<br>这周的任务还没有完成，在家里总是慵懒的状态，转念来到楼下的咖啡馆–HappyTree，躺在沙发上思考这个奇怪的问题。不想写鸡汤或者感悟，但是这文风不对啊！<br>这是一篇Guide，罗列<strong>一些技术的兴奋点</strong>（G点？）。虽然我属于杂牌军系列，什么都想搞一些，可是现在还是专注于Android方向。</p>\n<h2 id=\"切入点\"><a href=\"#切入点\" class=\"headerlink\" title=\"切入点\"></a>切入点</h2><p>不管在哪工作，一直都在思考或者观察这两个问题</p>\n<ul>\n<li><strong>如何搭建一个高效的开发框架</strong></li>\n<li>如何组建一个有战斗力的团队</li>\n</ul>\n<p>本文主要从第一点思考问题，一个合格的框架是怎样组成的？谈谈我经历的两个团队（有机会写文章细谈），第一团队，简单规范的开发框架，入门程序员也可以完成开发，第二个团队，项目太久，框架太多导致没有框架，自由发挥。理所当然地认为前者niubility，后者太low。但是在第一个团队有一种错觉，技术就是这些东西，没有什么可以说的了。直到现在，<strong>当自己思考如何构建一个框架的时候，发现世界如此精彩。</strong><br>用时刻准备创业的心态去思考工作。所以，现在我在始发站，总有一天会启程。最近有一篇很不错的微信团队的文章<a href=\"https://simpleton.gitbooks.io/sim-tech-note/content/Android/AndroidStartupTutorial.html\">《创业码农的一些建议》</a>，核心思想:<strong>“不要重复发明轮子”，当然这不意味着不需要知道怎么制造轮子。</strong>那么，看看如何用这些轮子来造车。</p>\n<h2 id=\"构建一个App\"><a href=\"#构建一个App\" class=\"headerlink\" title=\"构建一个App\"></a>构建一个App</h2><p>一个完备的app应当具有这些基础能力</p>\n<ul>\n<li>网络能力（https、下载、升级等）</li>\n<li>图片库</li>\n<li>数据库框架</li>\n<li>开发框架（模式）</li>\n<li>公共库/控件库/工具库</li>\n<li>apk打包与瘦身</li>\n<li>bug跟踪机制/质量保证</li>\n<li>用户分析系统</li>\n<li>推送机制/长连接方案</li>\n<li>对内规范（工程结构、代码style等）</li>\n<li>对外规范（接口规范、沟通规范）</li>\n</ul>\n<p>一个优秀的app应当具有这些技术能力</p>\n<ul>\n<li>灰度发布能力</li>\n<li>插件化技术</li>\n<li>热修复技术</li>\n<li>Android测试技术</li>\n<li>mock系统</li>\n<li>性能优化（内存，启动时间等）</li>\n<li>apk安全问题</li>\n</ul>\n<p>团队协作的基础设施</p>\n<ul>\n<li>版本管理工具</li>\n<li>Code Review工具</li>\n<li>持续集成</li>\n</ul>\n<h3 id=\"网络能力\"><a href=\"#网络能力\" class=\"headerlink\" title=\"网络能力\"></a>网络能力</h3><p><a href=\"https://github.com/square/okhttp\">okhttp</a> 现在使用中，http基础库，良好的同步/异步接口</p>\n<p><a href=\"https://github.com/loopj/android-async-http\">android-async-http</a> 之前使用，比较老，功能也比较完备</p>\n<blockquote>\n<p>okhttp\\android-async-http\\volley\\retrofit 比较<br>okhttp 和 async http是一个基础的通信库，都很强大，但需要自己封装使用才更方便。另外okhttp已经被谷歌官方用在android源码中了。 retrofit和 volley是属于比较高级点的封装库了。其中 retrofit是默认使用okhttp，volley也支持okhttp作为其底层通信的部件。retrofit的特点是使用清晰简单的接口，非常方便，而 volley在使用的时候也还简单，不过要使用高级一点的功能需要自己自定义很多东西，个人常用 <strong>retrofit+okhttp</strong><br>链接：<a href=\"https://www.zhihu.com/question/35189851/answer/62857319\">https://www.zhihu.com/question/35189851/answer/62857319</a><br>来源：知乎</p>\n</blockquote>\n<p><a href=\"https://github.com/google/gson\">Gson</a> json解析，一直使用这个库</p>\n<p><a href=\"\">jackson</a> 没有使用过，有空研究一下</p>\n<blockquote>\n<p>jackson gson fastjson<br>jackson 似乎有优势，尤其是大文件多并发的情况下</p>\n</blockquote>\n<h3 id=\"图片库\"><a href=\"#图片库\" class=\"headerlink\" title=\"图片库\"></a>图片库</h3><p><a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\">Android-Universal-Image-Loader</a> 使用过且阅读过源码，比较简单，功能较弱，无法很好应当OOM</p>\n<p><a href=\"\">Glide</a> 目前使用的的库，在非专业图片应用中强烈推荐，综合各种数据最优秀的Lib，同时也是Google推荐的。支持gif（webp动图不支持？video支持？）源码中大量的接口的设计，十分值得学习。大小500kb以内。</p>\n<p><a href=\"https://github.com/facebook/fresco\">fresco</a> 最优秀的内存管理和最强大的功能，支持WebP动图。FB出品，一些黑科技，代码复杂，压缩后通用安装包代码1M（包含两个平台的so）。</p>\n<blockquote>\n<p>Fresco vs UIL vs Glide vs Piasso<br>UIL 比较老，功能比较弱（不支持Gif WebP）,<br>Fresco最为强大，问题是对外接口不友好（需要替换ImageView），在使用过程遇到问题很难修改源码解决问题，比较复杂，建议不是图片特别重的App不要使用。<br>Piasso 都没有使用过，对外接口简单。据说：『Glide的性能更好一些，并且支持更多格式的图片』，以后有时间调研一下Glide。</p>\n</blockquote>\n<h3 id=\"数据库框架\"><a href=\"#数据库框架\" class=\"headerlink\" title=\"数据库框架\"></a>数据库框架</h3><p>DBFlow</p>\n<h3 id=\"开发框架\"><a href=\"#开发框架\" class=\"headerlink\" title=\"开发框架\"></a>开发框架</h3><p>这里包括且不限于：一些设计模式（MVC等），一些多线程工具库（代替AsyncTask，如Bolts等）</p>\n<p><a href=\"https://github.com/BoltsFramework/Bolts-Android\">Bolts-Android</a> android多线程，取代AsyncTask作为统一的线程池。具有链式调用的结构，可指定运行的不通线程。FB出品，现在在使用中，入门简单，使用代价很小。</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\">MVP &amp;&amp; MVVM</a>    MVP是在开发中常用的设计模式，当前使用中。</p>\n<p><a href=\"http://zhuanlan.zhihu.com/FrontendMagazine/19900243\">Flow 思想</a> 一种单向数据流的思想，在React框架中使用，可以在移动开发中使用。FB出名，学习ing，没有实践过。</p>\n<blockquote>\n<p>Flow VS MVP ?</p>\n</blockquote>\n<p><a href=\"https://github.com/ReactiveX/RxAndroid\">RxJava RxAndroid</a> ReactiveX的Java版本和Android扩展，强大！链式调用，可以代替Bolts的所有功能（也可以封装后代替EventBus），一种完备的开发框架（思想）。微软出品，学习中，入门较难，对团队要求很高，可以极大简化代码。</p>\n<p><a href=\"https://github.com/greenrobot/EventBus\">EventBus</a> 一种总线机制，使用发布-订阅的方式解耦模块，没有使用过。类似的还有<a href=\"https://github.com/square/otto\">Otto</a></p>\n<blockquote>\n<p>关于一些团队内部使用的框架：大致思想类似于bolts这一类框架再封装一下网络框架。方便开发者快速发起Rest请求并且在合适的线程处理数据和UI。</p>\n<p>其他：<br><a href=\"https://www.zhihu.com/question/32179258\">EventBus VS RxJava </a></p>\n<p>待补充：一些其他的注入框架，和如何联合使用这些框架。</p>\n</blockquote>\n<h3 id=\"公共库-控件库-工具库\"><a href=\"#公共库-控件库-工具库\" class=\"headerlink\" title=\"公共库/控件库/工具库\"></a>公共库/控件库/工具库</h3><p>待补充，主要是一些通用的公共组件和工具类，可能包含BaseActivity\\BaseFragment,xxxUtils。一些动画库nineOld<br><a href=\"https://www.youtube.com/watch?v=0BEkVaPlU9A&amp;feature=youtu.be\">Timber</a>：开源日志记录函数库，JakeWharton开发，默认打印类名。<br><a href=\"http://tech.luffyjet.com/2015/04/10/android-debug-tools-hugo-scalpel-timber/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\">其他辅助开发工具</a></p>\n<h3 id=\"bug跟踪机制-质量保证\"><a href=\"#bug跟踪机制-质量保证\" class=\"headerlink\" title=\"bug跟踪机制/质量保证\"></a>bug跟踪机制/质量保证</h3><p>发现问题的能力是App的一种重要的能力，类似百度使用的Crab平台跟踪用户崩溃和bug率是重要的。</p>\n<p><a href=\"https://get.fabric.io/?locale=zh-cn\">bug跟踪系统</a> 上报用户崩溃数据，部分用户分析工具具备此功能（如GA），但是建议加入专门的bug上报工具，类似百，功能强大。</p>\n<p><a href=\"\">用户反馈的设计</a> 一般app都需要反馈模块供用户主动反应问题。</p>\n<p><a href=\"\">性能、内存监控</a> 主要是开发阶段使用，暴露问题。例如LeakCanary、BlockCanary</p>\n<h3 id=\"用户分析系统\"><a href=\"#用户分析系统\" class=\"headerlink\" title=\"用户分析系统\"></a>用户分析系统</h3><p>跟踪用户行为，收集数据是持续优化的基础，也是产品重要能力。基本的埋点机制或者类似于Google Analyse的分析系统</p>\n<p><a href=\"\">App埋点设计与数据上报</a></p>\n<p><a href=\"\">接入第三方分析系统</a> 获取用户行为数据，形成画像是这些系统的重要功能。</p>\n<h3 id=\"推送机制-长连接方案\"><a href=\"#推送机制-长连接方案\" class=\"headerlink\" title=\"推送机制/长连接方案\"></a>推送机制/长连接方案</h3><p>推送的第三方方案，信鸽、other？<br>部分应用可能需要长连接，MQTT</p>\n<h3 id=\"对内规范\"><a href=\"#对内规范\" class=\"headerlink\" title=\"对内规范\"></a>对内规范</h3><p><a href=\"\">构建工程结构</a> 如何构建合理的工程结构，依据业务？功能？，如何方便扩展功能，发布不通版本？</p>\n<p><a href=\"https://github.com/square/java-code-styles\">代码Style</a> Square的java-code-styles,也可以自己fork做相应的修改</p>\n<p><a href=\"\">资源Style</a> Android特有的问题，dimens,styles,strings中按照UI需求设计一些基本的公共值（业务无关？）。否则会导致不可控。</p>\n<p><a href=\"\">代码检测</a> 代码静态检测，动态检测，提前发现潜在问题，提高代码质量。</p>\n<p><a href=\"\">CodeReview</a> 代码提交commit前的审核流程</p>\n<h3 id=\"对外规范\"><a href=\"#对外规范\" class=\"headerlink\" title=\"对外规范\"></a>对外规范</h3><p><a href=\"\">网络请求</a> http or https，get or post ,是否使用私有证书？</p>\n<p><a href=\"\">json格式规范</a> 使用标准的json格式，定义合理的返回结构和状态码（错误码建议不要使用http head中的代码，部分广告工具/防火墙拦截，而是定义在json中）。</p>\n<p><a href=\"\">加密方式服规范</a> 定义不同信息的安全等级以及对应加密算法–DES or RSA or MD5校验</p>\n<p><a href=\"\">迭代流程与发版规范</a> 敏捷流程，灰度/发版标准（bug率？）</p>\n<p><a href=\"\">问题解决流程</a> 次奥，这些问题太多了</p>\n<h3 id=\"灰度发布\"><a href=\"#灰度发布\" class=\"headerlink\" title=\"灰度发布\"></a>灰度发布</h3><p>待研究，GooglePlay具有此功能，也可以自行开发，对于用户量较多的App此功能具有重要意义，防止新版本问题影响到全部用户和验证功能效果都有作用。</p>\n<h3 id=\"插件化技术\"><a href=\"#插件化技术\" class=\"headerlink\" title=\"插件化技术\"></a>插件化技术</h3><p><a href=\"https://github.com/wequick/Small\">简单可靠的插件化技术</a> 插件化是大型产品的框架需求，尤其是平台化产品或者对App安装包大小有严格限制的应用。同时也是对65535限制的技术解决方案。</p>\n<h3 id=\"热修复技术\"><a href=\"#热修复技术\" class=\"headerlink\" title=\"热修复技术\"></a>热修复技术</h3><p><a href=\"http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/\">热修复技术研究</a> 热修复技术是产品上线后紧急修复的需要，是对灰度发布补充。</p>\n<h3 id=\"mock系统\"><a href=\"#mock系统\" class=\"headerlink\" title=\"mock系统\"></a>mock系统</h3><p>client团队内部开发使用，可以部分解决server与client开发不协调的问题，尤其是server进度慢于client的情况，也可以用于client程序员自己调试程序。</p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p>App迭代到一定阶段，自然而然地会进入这么一个阶段。一个好的框架可能会暂时隐藏这些问题。但是对系统的持续监控（性能分析报告）是必不可少，及早发现问题与定位，寻求时间优化问题十分重要。</p>\n<h3 id=\"版本管理工具\"><a href=\"#版本管理工具\" class=\"headerlink\" title=\"版本管理工具\"></a>版本管理工具</h3><p><a href=\"http://www.bootcss.com/p/git-guide/\">git</a> 使用较多的版本管理工具，代替svn等传统工具<br><a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">git flow</a>  git版本管理的工作流的最佳实践。满足正式开发、新特性预研、灰度、Release等版本的发布需求。<br><a href=\"\">git服务器搭建</a><br><a href=\"https://about.gitlab.com/gitlab-com/\">gitlab</a> 开源的本地管理系统，类似github的功能</p>\n<h3 id=\"Code-Review工具\"><a href=\"#Code-Review工具\" class=\"headerlink\" title=\"Code Review工具\"></a>Code Review工具</h3><p><a href=\"\">Gerrit</a> 适用于团队内部开发代码提交审核的工具。以及该工具与IDE、Git的集成。</p>\n<h3 id=\"持续集成\"><a href=\"#持续集成\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h3><p><a href=\"\">jenkins+git+gerrit方案</a> 将Android的Gradle build 持续集成</p>\n<blockquote>\n<p>是否考虑第三方服务？</p>\n</blockquote>\n<h2 id=\"趋势\"><a href=\"#趋势\" class=\"headerlink\" title=\"趋势\"></a>趋势</h2><p>作为一个程序员，能感受到Android开发技术发展迅速，新技术目不暇接。<strong>分享一些信息获取<a href=\"http://www.limuzhi.com/read/\">渠道</a></strong>。对于趋势，类比于其他技术是种不错的思路，<a href=\"http://blog.jobbole.com/91662/\">《从中间件的历史来看移动App开发的未来》</a>给我一些启发。</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\">React</a> FB提出的一种Js的mvc开发框架，虚拟dom具有高效的特点，并且可以扩展到App中。JavaScript有望占领前后端(Node.js)和各个平台。</p>\n<p><a href=\"http://www.androidweekly.cn/android-dev-special-weekly-react-native/\">React Native</a> React的android版本，有望取代其他的hybrid开发框架。</p>\n<h2 id=\"最后一些话\"><a href=\"#最后一些话\" class=\"headerlink\" title=\"最后一些话\"></a>最后一些话</h2><p>至此，基本总结了App开发的技术点，留了很多坑等着以后慢慢填，每一点展开都能写很多。后续会不断更新这些文章到自己的博文，也可能增删一些内容。从哪里开始写还没有想好，期间会插入一些小项目。打算在春节前写一个抢红包的系列文章，主要分析一些抢红包插件的源码。</p>\n<p>本人一年多的工作经验，大部分的内容也在探索中或者只有一些概念，任何问题欢迎提出。</p>\n"},{"title":"Android注入框架Dagger2学习笔记","date":"2016-03-06T04:47:07.000Z","_content":"\n## 简介\nDagger2是一个Google推荐的注入框架，关于什么是注入，为什么需要注入，可以参考下面的疑问以及解答文章。如果你在项目中使用MVP架构开发，强烈建议配合dagger2一起使用。\nDagger2大量使用注解，使开发者可以优雅的构造对象，同时，这些注解仅在编译期间生成代码，没有用到运行时的反射，对性能的影响可以忽略。使用者可以查看编译期间生成的代码，方便debug。\n本文是学习Dagger2的笔记，需要先学习下面的文章，了解Dagger2，然后在学习过程中有一些疑问，形成一些思考与测试，形成此文。但是我还没有机会在项目中实际使用，若以后有实践经验会不断补充。\n\n主要学习的文章：\n\n*  [Android常用开源工具（1）-Dagger2入门](http://blog.csdn.net/duo2005duo/article/details/50618171)：dagger2的基本用法，很好的文章。\n*  [Android常用开源工具（2）-Dagger2进阶](http://blog.csdn.net/duo2005duo/article/details/50696166)：dagger2的一些高级用法，如限定符。\n*   [详解Dagger2](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html)：这篇文章翻译的不好，参考英文原文。\n\n### 疑问以及解答\n* [什么是依赖注入](<http://www.codekk.com/open-source-project-analysis/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>)\n\n* [Dagger 源码解析](http://www.codekk.com/blogs/detail/54cfab086c4761e5001b2537)：dagger第一代的讲解，参考了解两者的差异。\n\n* [Android中是否有必要使用依赖注入的争议](<http://dk-exp.com/2015/01/28/use-ioc-in-android/>)\n\n## 一个非常容易的错误\ninject的参数。。。不能是父类，必须是你注入的那个内\n\n## 一个重要的概念：向子图暴露\n即在component中写如下方法向把它依赖的component来暴露构造方法，且只能暴露一层。\n\n```java\n//定义ComponentB,modules可以不写，也可以与其他Component依赖的modules相同\n@Component(modules={××××××××})\ninterface ComponentB{\n    // 必须暴露出来，给A注入的对象用\n    Apple apple()\n}\n//定义ComponentA，dependencies是A依赖的，区分 extend ComponentB\n@Component(dependencies={ComponentB.class},modules={××××××××})//使用dependencies\ninterface ComponentA{\n    // 注意注入的必须是具体的子类MyApp/XXActivity，不能是父类，如Application/Activity\n    void inject(MyApp app)\n}\n```\n\n## 错误汇总\n1. 错误: com.android.example.devsummit.archdemo.di.module.Apple is bound multiple times:\n\n\t原因：一个类定义了多个provider：\n\t* component关联的（n个或者1个）module中有重复的provider\n\t* component A有dependencies的component B，A关联的Module A中有provider，component B关联的Module B中也有provider，**且在component B中暴露出来了**（不暴露不影响）\n\n\t下面的情况**没有**影响：\n\t\n\t* component 关联的module有provider，且类自己的构造函数有Inject标志，不影响，且provider优先。\n\t* component A有dependencies的component B， A关联的Module A中有provider，component B关联的Module B中也有provider，但是component B中没有暴露，不影响\n \n\n2. 错误: Types may only contain one @Inject constructor.\n\n\t原因：一个类的构造函数只能有一个有@inject\n\n3. 错误: com.android.example.devsummit.archdemo.di.module.Apple cannot be provided without an @Inject constructor or from an @Provides-annotated method.\n\n\t原因：\n\t* 没有provider或者inject\n\t* 如果component含有dependencies，可能没有向外面暴露\n\n##区分易混淆的概念\n\n1. component与module\n2. component的dependencies与component接口的继承（extend）\n\n## 关于Scope的粗浅理解\n### 概念\nscope是范围，标志一个注入器/对象的使用范围，那么可以理解：\n\n* 父类（dependencies）有范围，子类必须有，且要小于它\n* 父类子类范围不能一样？\n* component中某一个对象构造有范围（Module中的一个方法有范围），那么该component就有范围。\n\n### 作用\n作用是允许对象被记录在正确的组件（component）。即module的构造方法用在正确的注入器（component）中，防止用错地方。**因为一个component关联的module中如果有其他的scope的provider会报错，因为component没有这个scope。**\n\n### 自定义scope\n```java\n@Scope\n@Documented\n@Retention(RUNTIME)\npublic @interface Singleton{}\n```\n\n### 使用scope时规则\n结合scope的概念理解\n\n* component关联的Model中的**任何一个被构造的对象**有scope，则该整个component要加上这个scope。在暴露或者注入时（不暴露且不注入时，既不使用它构造对象时，不报错），会有如下错误\n > Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) may not reference scoped bindings:\n@Provides @com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.vo.User com.android.example.devsummit.archdemo.di.module.TestModule.user()\n\n* component的dependencies与component自身的scope不能相同，即组件之间的scope不同\n* Singleton的组件不能依赖其他scope的组件，只能其他scope的组件依赖Singleton的组件。\n* 没有scope的不能依赖有scope的组件，理解一下。。。\n\n  > Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) cannot depend on scoped components:\n@com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.di.component.MyTestComponentX\n* 一个component不能同时有多个scope(Subcomponent除外)\n\n\t> Error:Execution failed for task ':app:compileDebugJavaWithJavac'.\n\t> java.lang.IllegalArgumentException: com.android.example.devsummit.archdemo.di.component.MyTestComponent was annotated with more than one @Scope annotation\n\n## 其他概念\n### @Subcomponent\nSubcomponent与dependencies区别：\ndependencies不会继承范围，Subcomponent会。子component同时具备两种不同生命周期的scope。\n\n## 实践\n### Module\ndagger使用的目的在于更多的使用面向接口的编程。在Module中构造的对象返回的应当尽量是：**构造具体的类的实现，但是返回接口**，如②中所示，参考[文章](http://www.jianshu.com/p/c2feb21064bb)，常用写法如下：\n\n```java\n@Module\npublic class AppModule {\n    private final MyApplication application;\n\n    public AppModule(MyApplication application) {\n        this.application = application;\n    }\n\n\t// ①这种情况是返回module内部保持的变量\n    @Provides\n    @Singleton\n    Context provideApplicationContext() { \n       return application;\n    }\n\n\t// ②这种含有参数的写法会自动构造参数，前提是provideThreadExecutor，有provider或者@inject，ThreadExecutor是接口，JobExecutor是具体的类\n\t// 注意一种错误:参数和返回值不能是相同的类！！\n    @Provides\n    @Singleton\n    ThreadExecutor provideThreadExecutor(JobExecutor jobExecutor) {\n        return jobExecutor;\n    }\n\n\t// ③这种写法会自动构造参数，前提是RetrofitManager，有provider或者@inject\n    @Provides\n    @Singleton\n    ApiService providesApiService(RetrofitManager retrofitManager) {\n        return retrofitManager.getService();\n    }\n\n\t// ④这种写法是比较常见的，内部new一个对象返回\n    @Provides\n    @Singleton\n    DBManager provideDBManager() {\n        return new DBManager(application);\n    }\n}\n```\t","source":"_posts/Android注入框架Dagger2学习笔记.md","raw":"title: Android注入框架Dagger2学习笔记\ndate: 2016-03-06 12:47:07\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n\n## 简介\nDagger2是一个Google推荐的注入框架，关于什么是注入，为什么需要注入，可以参考下面的疑问以及解答文章。如果你在项目中使用MVP架构开发，强烈建议配合dagger2一起使用。\nDagger2大量使用注解，使开发者可以优雅的构造对象，同时，这些注解仅在编译期间生成代码，没有用到运行时的反射，对性能的影响可以忽略。使用者可以查看编译期间生成的代码，方便debug。\n本文是学习Dagger2的笔记，需要先学习下面的文章，了解Dagger2，然后在学习过程中有一些疑问，形成一些思考与测试，形成此文。但是我还没有机会在项目中实际使用，若以后有实践经验会不断补充。\n\n主要学习的文章：\n\n*  [Android常用开源工具（1）-Dagger2入门](http://blog.csdn.net/duo2005duo/article/details/50618171)：dagger2的基本用法，很好的文章。\n*  [Android常用开源工具（2）-Dagger2进阶](http://blog.csdn.net/duo2005duo/article/details/50696166)：dagger2的一些高级用法，如限定符。\n*   [详解Dagger2](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html)：这篇文章翻译的不好，参考英文原文。\n\n### 疑问以及解答\n* [什么是依赖注入](<http://www.codekk.com/open-source-project-analysis/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>)\n\n* [Dagger 源码解析](http://www.codekk.com/blogs/detail/54cfab086c4761e5001b2537)：dagger第一代的讲解，参考了解两者的差异。\n\n* [Android中是否有必要使用依赖注入的争议](<http://dk-exp.com/2015/01/28/use-ioc-in-android/>)\n\n## 一个非常容易的错误\ninject的参数。。。不能是父类，必须是你注入的那个内\n\n## 一个重要的概念：向子图暴露\n即在component中写如下方法向把它依赖的component来暴露构造方法，且只能暴露一层。\n\n```java\n//定义ComponentB,modules可以不写，也可以与其他Component依赖的modules相同\n@Component(modules={××××××××})\ninterface ComponentB{\n    // 必须暴露出来，给A注入的对象用\n    Apple apple()\n}\n//定义ComponentA，dependencies是A依赖的，区分 extend ComponentB\n@Component(dependencies={ComponentB.class},modules={××××××××})//使用dependencies\ninterface ComponentA{\n    // 注意注入的必须是具体的子类MyApp/XXActivity，不能是父类，如Application/Activity\n    void inject(MyApp app)\n}\n```\n\n## 错误汇总\n1. 错误: com.android.example.devsummit.archdemo.di.module.Apple is bound multiple times:\n\n\t原因：一个类定义了多个provider：\n\t* component关联的（n个或者1个）module中有重复的provider\n\t* component A有dependencies的component B，A关联的Module A中有provider，component B关联的Module B中也有provider，**且在component B中暴露出来了**（不暴露不影响）\n\n\t下面的情况**没有**影响：\n\t\n\t* component 关联的module有provider，且类自己的构造函数有Inject标志，不影响，且provider优先。\n\t* component A有dependencies的component B， A关联的Module A中有provider，component B关联的Module B中也有provider，但是component B中没有暴露，不影响\n \n\n2. 错误: Types may only contain one @Inject constructor.\n\n\t原因：一个类的构造函数只能有一个有@inject\n\n3. 错误: com.android.example.devsummit.archdemo.di.module.Apple cannot be provided without an @Inject constructor or from an @Provides-annotated method.\n\n\t原因：\n\t* 没有provider或者inject\n\t* 如果component含有dependencies，可能没有向外面暴露\n\n##区分易混淆的概念\n\n1. component与module\n2. component的dependencies与component接口的继承（extend）\n\n## 关于Scope的粗浅理解\n### 概念\nscope是范围，标志一个注入器/对象的使用范围，那么可以理解：\n\n* 父类（dependencies）有范围，子类必须有，且要小于它\n* 父类子类范围不能一样？\n* component中某一个对象构造有范围（Module中的一个方法有范围），那么该component就有范围。\n\n### 作用\n作用是允许对象被记录在正确的组件（component）。即module的构造方法用在正确的注入器（component）中，防止用错地方。**因为一个component关联的module中如果有其他的scope的provider会报错，因为component没有这个scope。**\n\n### 自定义scope\n```java\n@Scope\n@Documented\n@Retention(RUNTIME)\npublic @interface Singleton{}\n```\n\n### 使用scope时规则\n结合scope的概念理解\n\n* component关联的Model中的**任何一个被构造的对象**有scope，则该整个component要加上这个scope。在暴露或者注入时（不暴露且不注入时，既不使用它构造对象时，不报错），会有如下错误\n > Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) may not reference scoped bindings:\n@Provides @com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.vo.User com.android.example.devsummit.archdemo.di.module.TestModule.user()\n\n* component的dependencies与component自身的scope不能相同，即组件之间的scope不同\n* Singleton的组件不能依赖其他scope的组件，只能其他scope的组件依赖Singleton的组件。\n* 没有scope的不能依赖有scope的组件，理解一下。。。\n\n  > Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) cannot depend on scoped components:\n@com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.di.component.MyTestComponentX\n* 一个component不能同时有多个scope(Subcomponent除外)\n\n\t> Error:Execution failed for task ':app:compileDebugJavaWithJavac'.\n\t> java.lang.IllegalArgumentException: com.android.example.devsummit.archdemo.di.component.MyTestComponent was annotated with more than one @Scope annotation\n\n## 其他概念\n### @Subcomponent\nSubcomponent与dependencies区别：\ndependencies不会继承范围，Subcomponent会。子component同时具备两种不同生命周期的scope。\n\n## 实践\n### Module\ndagger使用的目的在于更多的使用面向接口的编程。在Module中构造的对象返回的应当尽量是：**构造具体的类的实现，但是返回接口**，如②中所示，参考[文章](http://www.jianshu.com/p/c2feb21064bb)，常用写法如下：\n\n```java\n@Module\npublic class AppModule {\n    private final MyApplication application;\n\n    public AppModule(MyApplication application) {\n        this.application = application;\n    }\n\n\t// ①这种情况是返回module内部保持的变量\n    @Provides\n    @Singleton\n    Context provideApplicationContext() { \n       return application;\n    }\n\n\t// ②这种含有参数的写法会自动构造参数，前提是provideThreadExecutor，有provider或者@inject，ThreadExecutor是接口，JobExecutor是具体的类\n\t// 注意一种错误:参数和返回值不能是相同的类！！\n    @Provides\n    @Singleton\n    ThreadExecutor provideThreadExecutor(JobExecutor jobExecutor) {\n        return jobExecutor;\n    }\n\n\t// ③这种写法会自动构造参数，前提是RetrofitManager，有provider或者@inject\n    @Provides\n    @Singleton\n    ApiService providesApiService(RetrofitManager retrofitManager) {\n        return retrofitManager.getService();\n    }\n\n\t// ④这种写法是比较常见的，内部new一个对象返回\n    @Provides\n    @Singleton\n    DBManager provideDBManager() {\n        return new DBManager(application);\n    }\n}\n```\t","slug":"Android注入框架Dagger2学习笔记","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbcv0015nac9ip5h9vzu","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dagger2是一个Google推荐的注入框架，关于什么是注入，为什么需要注入，可以参考下面的疑问以及解答文章。如果你在项目中使用MVP架构开发，强烈建议配合dagger2一起使用。<br>Dagger2大量使用注解，使开发者可以优雅的构造对象，同时，这些注解仅在编译期间生成代码，没有用到运行时的反射，对性能的影响可以忽略。使用者可以查看编译期间生成的代码，方便debug。<br>本文是学习Dagger2的笔记，需要先学习下面的文章，了解Dagger2，然后在学习过程中有一些疑问，形成一些思考与测试，形成此文。但是我还没有机会在项目中实际使用，若以后有实践经验会不断补充。</p>\n<p>主要学习的文章：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/duo2005duo/article/details/50618171\" target=\"_blank\" rel=\"external\">Android常用开源工具（1）-Dagger2入门</a>：dagger2的基本用法，很好的文章。</li>\n<li><a href=\"http://blog.csdn.net/duo2005duo/article/details/50696166\" target=\"_blank\" rel=\"external\">Android常用开源工具（2）-Dagger2进阶</a>：dagger2的一些高级用法，如限定符。</li>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html\" target=\"_blank\" rel=\"external\">详解Dagger2</a>：这篇文章翻译的不好，参考英文原文。</li>\n</ul>\n<h3 id=\"疑问以及解答\"><a href=\"#疑问以及解答\" class=\"headerlink\" title=\"疑问以及解答\"></a>疑问以及解答</h3><ul>\n<li><p><a href=\"http://www.codekk.com/open-source-project-analysis/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5\" target=\"_blank\" rel=\"external\">什么是依赖注入</a></p>\n</li>\n<li><p><a href=\"http://www.codekk.com/blogs/detail/54cfab086c4761e5001b2537\" target=\"_blank\" rel=\"external\">Dagger 源码解析</a>：dagger第一代的讲解，参考了解两者的差异。</p>\n</li>\n<li><p><a href=\"http://dk-exp.com/2015/01/28/use-ioc-in-android/\" target=\"_blank\" rel=\"external\">Android中是否有必要使用依赖注入的争议</a></p>\n</li>\n</ul>\n<h2 id=\"一个非常容易的错误\"><a href=\"#一个非常容易的错误\" class=\"headerlink\" title=\"一个非常容易的错误\"></a>一个非常容易的错误</h2><p>inject的参数。。。不能是父类，必须是你注入的那个内</p>\n<h2 id=\"一个重要的概念：向子图暴露\"><a href=\"#一个重要的概念：向子图暴露\" class=\"headerlink\" title=\"一个重要的概念：向子图暴露\"></a>一个重要的概念：向子图暴露</h2><p>即在component中写如下方法向把它依赖的component来暴露构造方法，且只能暴露一层。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义ComponentB,modules可以不写，也可以与其他Component依赖的modules相同</span></div><div class=\"line\"><span class=\"meta\">@Component</span>(modules=&#123;××××××××&#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ComponentB</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 必须暴露出来，给A注入的对象用</span></div><div class=\"line\">    <span class=\"function\">Apple <span class=\"title\">apple</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//定义ComponentA，dependencies是A依赖的，区分 extend ComponentB</span></div><div class=\"line\">@<span class=\"title\">Component</span><span class=\"params\">(dependencies=&#123;ComponentB.class&#125;,modules=&#123;××××××××&#125;)</span><span class=\"comment\">//使用dependencies</span></div><div class=\"line\">interface ComponentA&#123;</div><div class=\"line\">    <span class=\"comment\">// 注意注入的必须是具体的子类MyApp/XXActivity，不能是父类，如Application/Activity</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(MyApp app)</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"错误汇总\"><a href=\"#错误汇总\" class=\"headerlink\" title=\"错误汇总\"></a>错误汇总</h2><ol>\n<li><p>错误: com.android.example.devsummit.archdemo.di.module.Apple is bound multiple times:</p>\n<p> 原因：一个类定义了多个provider：</p>\n<ul>\n<li>component关联的（n个或者1个）module中有重复的provider</li>\n<li><p>component A有dependencies的component B，A关联的Module A中有provider，component B关联的Module B中也有provider，<strong>且在component B中暴露出来了</strong>（不暴露不影响）</p>\n<p>下面的情况<strong>没有</strong>影响：</p>\n</li>\n<li><p>component 关联的module有provider，且类自己的构造函数有Inject标志，不影响，且provider优先。</p>\n</li>\n<li>component A有dependencies的component B， A关联的Module A中有provider，component B关联的Module B中也有provider，但是component B中没有暴露，不影响</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>错误: Types may only contain one @Inject constructor.</p>\n<p> 原因：一个类的构造函数只能有一个有@inject</p>\n</li>\n<li><p>错误: com.android.example.devsummit.archdemo.di.module.Apple cannot be provided without an @Inject constructor or from an @Provides-annotated method.</p>\n<p> 原因：</p>\n<ul>\n<li>没有provider或者inject</li>\n<li>如果component含有dependencies，可能没有向外面暴露</li>\n</ul>\n</li>\n</ol>\n<p>##区分易混淆的概念</p>\n<ol>\n<li>component与module</li>\n<li>component的dependencies与component接口的继承（extend）</li>\n</ol>\n<h2 id=\"关于Scope的粗浅理解\"><a href=\"#关于Scope的粗浅理解\" class=\"headerlink\" title=\"关于Scope的粗浅理解\"></a>关于Scope的粗浅理解</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>scope是范围，标志一个注入器/对象的使用范围，那么可以理解：</p>\n<ul>\n<li>父类（dependencies）有范围，子类必须有，且要小于它</li>\n<li>父类子类范围不能一样？</li>\n<li>component中某一个对象构造有范围（Module中的一个方法有范围），那么该component就有范围。</li>\n</ul>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>作用是允许对象被记录在正确的组件（component）。即module的构造方法用在正确的注入器（component）中，防止用错地方。<strong>因为一个component关联的module中如果有其他的scope的provider会报错，因为component没有这个scope。</strong></p>\n<h3 id=\"自定义scope\"><a href=\"#自定义scope\" class=\"headerlink\" title=\"自定义scope\"></a>自定义scope</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Scope</span></div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Retention</span>(RUNTIME)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Singleton&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"使用scope时规则\"><a href=\"#使用scope时规则\" class=\"headerlink\" title=\"使用scope时规则\"></a>使用scope时规则</h3><p>结合scope的概念理解</p>\n<ul>\n<li><p>component关联的Model中的<strong>任何一个被构造的对象</strong>有scope，则该整个component要加上这个scope。在暴露或者注入时（不暴露且不注入时，既不使用它构造对象时，不报错），会有如下错误</p>\n<blockquote>\n<p>Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) may not reference scoped bindings:<br>@Provides @com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.vo.User com.android.example.devsummit.archdemo.di.module.TestModule.user()</p>\n</blockquote>\n</li>\n<li><p>component的dependencies与component自身的scope不能相同，即组件之间的scope不同</p>\n</li>\n<li>Singleton的组件不能依赖其他scope的组件，只能其他scope的组件依赖Singleton的组件。</li>\n<li><p>没有scope的不能依赖有scope的组件，理解一下。。。</p>\n<blockquote>\n<p>Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) cannot depend on scoped components:<br>@com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.di.component.MyTestComponentX</p>\n</blockquote>\n</li>\n<li><p>一个component不能同时有多个scope(Subcomponent除外)</p>\n<blockquote>\n<p>Error:Execution failed for task ‘:app:compileDebugJavaWithJavac’.<br>java.lang.IllegalArgumentException: com.android.example.devsummit.archdemo.di.component.MyTestComponent was annotated with more than one @Scope annotation</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"其他概念\"><a href=\"#其他概念\" class=\"headerlink\" title=\"其他概念\"></a>其他概念</h2><h3 id=\"Subcomponent\"><a href=\"#Subcomponent\" class=\"headerlink\" title=\"@Subcomponent\"></a>@Subcomponent</h3><p>Subcomponent与dependencies区别：<br>dependencies不会继承范围，Subcomponent会。子component同时具备两种不同生命周期的scope。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><p>dagger使用的目的在于更多的使用面向接口的编程。在Module中构造的对象返回的应当尽量是：<strong>构造具体的类的实现，但是返回接口</strong>，如②中所示，参考<a href=\"http://www.jianshu.com/p/c2feb21064bb\" target=\"_blank\" rel=\"external\">文章</a>，常用写法如下：</p>\n<pre><code class=\"java\"><span class=\"meta\">@Module</span>\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> </span>{\n    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MyApplication application;\n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppModule</span><span class=\"params\">(MyApplication application)</span> </span>{\n        <span class=\"keyword\">this</span>.application = application;\n    }\n\n    <span class=\"comment\">// ①这种情况是返回module内部保持的变量</span>\n    <span class=\"meta\">@Provides</span>\n    <span class=\"meta\">@Singleton</span>\n    <span class=\"function\">Context <span class=\"title\">provideApplicationContext</span><span class=\"params\">()</span> </span>{ \n       <span class=\"keyword\">return</span> application;\n    }\n\n    <span class=\"comment\">// ②这种含有参数的写法会自动构造参数，前提是provideThreadExecutor，有provider或者@inject，ThreadExecutor是接口，JobExecutor是具体的类</span>\n    <span class=\"comment\">// 注意一种错误:参数和返回值不能是相同的类！！</span>\n    <span class=\"meta\">@Provides</span>\n    <span class=\"meta\">@Singleton</span>\n    <span class=\"function\">ThreadExecutor <span class=\"title\">provideThreadExecutor</span><span class=\"params\">(JobExecutor jobExecutor)</span> </span>{\n        <span class=\"keyword\">return</span> jobExecutor;\n    }\n\n    <span class=\"comment\">// ③这种写法会自动构造参数，前提是RetrofitManager，有provider或者@inject</span>\n    <span class=\"meta\">@Provides</span>\n    <span class=\"meta\">@Singleton</span>\n    <span class=\"function\">ApiService <span class=\"title\">providesApiService</span><span class=\"params\">(RetrofitManager retrofitManager)</span> </span>{\n        <span class=\"keyword\">return</span> retrofitManager.getService();\n    }\n\n    <span class=\"comment\">// ④这种写法是比较常见的，内部new一个对象返回</span>\n    <span class=\"meta\">@Provides</span>\n    <span class=\"meta\">@Singleton</span>\n    <span class=\"function\">DBManager <span class=\"title\">provideDBManager</span><span class=\"params\">()</span> </span>{\n        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DBManager(application);\n    }\n}\n</code></pre>\n","excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dagger2是一个Google推荐的注入框架，关于什么是注入，为什么需要注入，可以参考下面的疑问以及解答文章。如果你在项目中使用MVP架构开发，强烈建议配合dagger2一起使用。<br>Dagger2大量使用注解，使开发者可以优雅的构造对象，同时，这些注解仅在编译期间生成代码，没有用到运行时的反射，对性能的影响可以忽略。使用者可以查看编译期间生成的代码，方便debug。<br>本文是学习Dagger2的笔记，需要先学习下面的文章，了解Dagger2，然后在学习过程中有一些疑问，形成一些思考与测试，形成此文。但是我还没有机会在项目中实际使用，若以后有实践经验会不断补充。</p>\n<p>主要学习的文章：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/duo2005duo/article/details/50618171\">Android常用开源工具（1）-Dagger2入门</a>：dagger2的基本用法，很好的文章。</li>\n<li><a href=\"http://blog.csdn.net/duo2005duo/article/details/50696166\">Android常用开源工具（2）-Dagger2进阶</a>：dagger2的一些高级用法，如限定符。</li>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html\">详解Dagger2</a>：这篇文章翻译的不好，参考英文原文。</li>\n</ul>\n<h3 id=\"疑问以及解答\"><a href=\"#疑问以及解答\" class=\"headerlink\" title=\"疑问以及解答\"></a>疑问以及解答</h3><ul>\n<li><p><a href=\"http://www.codekk.com/open-source-project-analysis/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5\">什么是依赖注入</a></p>\n</li>\n<li><p><a href=\"http://www.codekk.com/blogs/detail/54cfab086c4761e5001b2537\">Dagger 源码解析</a>：dagger第一代的讲解，参考了解两者的差异。</p>\n</li>\n<li><p><a href=\"http://dk-exp.com/2015/01/28/use-ioc-in-android/\">Android中是否有必要使用依赖注入的争议</a></p>\n</li>\n</ul>\n<h2 id=\"一个非常容易的错误\"><a href=\"#一个非常容易的错误\" class=\"headerlink\" title=\"一个非常容易的错误\"></a>一个非常容易的错误</h2><p>inject的参数。。。不能是父类，必须是你注入的那个内</p>\n<h2 id=\"一个重要的概念：向子图暴露\"><a href=\"#一个重要的概念：向子图暴露\" class=\"headerlink\" title=\"一个重要的概念：向子图暴露\"></a>一个重要的概念：向子图暴露</h2><p>即在component中写如下方法向把它依赖的component来暴露构造方法，且只能暴露一层。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义ComponentB,modules可以不写，也可以与其他Component依赖的modules相同</span></div><div class=\"line\"><span class=\"meta\">@Component</span>(modules=&#123;××××××××&#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ComponentB</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 必须暴露出来，给A注入的对象用</span></div><div class=\"line\">    <span class=\"function\">Apple <span class=\"title\">apple</span><span class=\"params\">()</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//定义ComponentA，dependencies是A依赖的，区分 extend ComponentB</span></div><div class=\"line\">@<span class=\"title\">Component</span><span class=\"params\">(dependencies=&#123;ComponentB.class&#125;,modules=&#123;××××××××&#125;)</span><span class=\"comment\">//使用dependencies</span></div><div class=\"line\">interface ComponentA</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 注意注入的必须是具体的子类MyApp/XXActivity，不能是父类，如Application/Activity</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(MyApp app)</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<h2 id=\"错误汇总\"><a href=\"#错误汇总\" class=\"headerlink\" title=\"错误汇总\"></a>错误汇总</h2><ol>\n<li><p>错误: com.android.example.devsummit.archdemo.di.module.Apple is bound multiple times:</p>\n<p> 原因：一个类定义了多个provider：</p>\n<ul>\n<li>component关联的（n个或者1个）module中有重复的provider</li>\n<li><p>component A有dependencies的component B，A关联的Module A中有provider，component B关联的Module B中也有provider，<strong>且在component B中暴露出来了</strong>（不暴露不影响）</p>\n<p>下面的情况<strong>没有</strong>影响：</p>\n</li>\n<li><p>component 关联的module有provider，且类自己的构造函数有Inject标志，不影响，且provider优先。</p>\n</li>\n<li>component A有dependencies的component B， A关联的Module A中有provider，component B关联的Module B中也有provider，但是component B中没有暴露，不影响</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>错误: Types may only contain one @Inject constructor.</p>\n<p> 原因：一个类的构造函数只能有一个有@inject</p>\n</li>\n<li><p>错误: com.android.example.devsummit.archdemo.di.module.Apple cannot be provided without an @Inject constructor or from an @Provides-annotated method.</p>\n<p> 原因：</p>\n<ul>\n<li>没有provider或者inject</li>\n<li>如果component含有dependencies，可能没有向外面暴露</li>\n</ul>\n</li>\n</ol>\n<p>##区分易混淆的概念</p>\n<ol>\n<li>component与module</li>\n<li>component的dependencies与component接口的继承（extend）</li>\n</ol>\n<h2 id=\"关于Scope的粗浅理解\"><a href=\"#关于Scope的粗浅理解\" class=\"headerlink\" title=\"关于Scope的粗浅理解\"></a>关于Scope的粗浅理解</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>scope是范围，标志一个注入器/对象的使用范围，那么可以理解：</p>\n<ul>\n<li>父类（dependencies）有范围，子类必须有，且要小于它</li>\n<li>父类子类范围不能一样？</li>\n<li>component中某一个对象构造有范围（Module中的一个方法有范围），那么该component就有范围。</li>\n</ul>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>作用是允许对象被记录在正确的组件（component）。即module的构造方法用在正确的注入器（component）中，防止用错地方。<strong>因为一个component关联的module中如果有其他的scope的provider会报错，因为component没有这个scope。</strong></p>\n<h3 id=\"自定义scope\"><a href=\"#自定义scope\" class=\"headerlink\" title=\"自定义scope\"></a>自定义scope</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Scope</span></div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Retention</span>(RUNTIME)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Singleton&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"使用scope时规则\"><a href=\"#使用scope时规则\" class=\"headerlink\" title=\"使用scope时规则\"></a>使用scope时规则</h3><p>结合scope的概念理解</p>\n<ul>\n<li><p>component关联的Model中的<strong>任何一个被构造的对象</strong>有scope，则该整个component要加上这个scope。在暴露或者注入时（不暴露且不注入时，既不使用它构造对象时，不报错），会有如下错误</p>\n<blockquote>\n<p>Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) may not reference scoped bindings:<br>@Provides @com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.vo.User com.android.example.devsummit.archdemo.di.module.TestModule.user()</p>\n</blockquote>\n</li>\n<li><p>component的dependencies与component自身的scope不能相同，即组件之间的scope不同</p>\n</li>\n<li>Singleton的组件不能依赖其他scope的组件，只能其他scope的组件依赖Singleton的组件。</li>\n<li><p>没有scope的不能依赖有scope的组件，理解一下。。。</p>\n<blockquote>\n<p>Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) cannot depend on scoped components:<br>@com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.di.component.MyTestComponentX</p>\n</blockquote>\n</li>\n<li><p>一个component不能同时有多个scope(Subcomponent除外)</p>\n<blockquote>\n<p>Error:Execution failed for task ‘:app:compileDebugJavaWithJavac’.<br>java.lang.IllegalArgumentException: com.android.example.devsummit.archdemo.di.component.MyTestComponent was annotated with more than one @Scope annotation</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"其他概念\"><a href=\"#其他概念\" class=\"headerlink\" title=\"其他概念\"></a>其他概念</h2><h3 id=\"Subcomponent\"><a href=\"#Subcomponent\" class=\"headerlink\" title=\"@Subcomponent\"></a>@Subcomponent</h3><p>Subcomponent与dependencies区别：<br>dependencies不会继承范围，Subcomponent会。子component同时具备两种不同生命周期的scope。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><p>dagger使用的目的在于更多的使用面向接口的编程。在Module中构造的对象返回的应当尽量是：<strong>构造具体的类的实现，但是返回接口</strong>，如②中所示，参考<a href=\"http://www.jianshu.com/p/c2feb21064bb\">文章</a>，常用写法如下：</p>\n<pre><code class=\"java\"><span class=\"meta\">@Module</span>\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> </span>{\n    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MyApplication application;\n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppModule</span><span class=\"params\">(MyApplication application)</span> </span>{\n        <span class=\"keyword\">this</span>.application = application;\n    }\n\n    <span class=\"comment\">// ①这种情况是返回module内部保持的变量</span>\n    <span class=\"meta\">@Provides</span>\n    <span class=\"meta\">@Singleton</span>\n    <span class=\"function\">Context <span class=\"title\">provideApplicationContext</span><span class=\"params\">()</span> </span>{ \n       <span class=\"keyword\">return</span> application;\n    }\n\n    <span class=\"comment\">// ②这种含有参数的写法会自动构造参数，前提是provideThreadExecutor，有provider或者@inject，ThreadExecutor是接口，JobExecutor是具体的类</span>\n    <span class=\"comment\">// 注意一种错误:参数和返回值不能是相同的类！！</span>\n    <span class=\"meta\">@Provides</span>\n    <span class=\"meta\">@Singleton</span>\n    <span class=\"function\">ThreadExecutor <span class=\"title\">provideThreadExecutor</span><span class=\"params\">(JobExecutor jobExecutor)</span> </span>{\n        <span class=\"keyword\">return</span> jobExecutor;\n    }\n\n    <span class=\"comment\">// ③这种写法会自动构造参数，前提是RetrofitManager，有provider或者@inject</span>\n    <span class=\"meta\">@Provides</span>\n    <span class=\"meta\">@Singleton</span>\n    <span class=\"function\">ApiService <span class=\"title\">providesApiService</span><span class=\"params\">(RetrofitManager retrofitManager)</span> </span>{\n        <span class=\"keyword\">return</span> retrofitManager.getService();\n    }\n\n    <span class=\"comment\">// ④这种写法是比较常见的，内部new一个对象返回</span>\n    <span class=\"meta\">@Provides</span>\n    <span class=\"meta\">@Singleton</span>\n    <span class=\"function\">DBManager <span class=\"title\">provideDBManager</span><span class=\"params\">()</span> </span>{\n        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DBManager(application);\n    }\n}\n</code></pre>\n"},{"title":"抢红包插件分析以及应用","date":"2016-01-17T08:07:44.000Z","_content":"临近春节，群里的红包又多了（也许仅仅是群多了），由于流行了各种抢红包插件，红包基本是秒没的节奏。在好奇心的驱使下研究了一下抢红包插件的原理，发现既简单又很有意思。还能用来干些其他羞羞的事情😉。。\n\n> 参考Github项目源码  [微信抢红包插件](https://github.com/geeeeeeeeek/WeChatLuckyMoney)\n\n## 基本原理\n\n在没有看Github上的实现的时候，我天真地以为这种插件的原理类似于PC平台上的按键精灵（Android版也有），或者一些测试化工具。这一类软件实现起来应当比较复杂，Too Yang Too Simple。Android已经提供了完备的系统。\n> AccessibilityService 服务（Service），初衷是用于辅助服务，总之它的**功能是根据用户的一些操作给用户相应的提示**，如给残疾人自动读出选择的文字。\n\n我们需要做的是\n1. 继承AccessibilityService，写自定义的辅助服务\n2. 当用户App的界面发送变化时，会触发Service的相关回调，在该回调中可以获取**当前界面中的UI界面元素节点**（不是view本身，是它的一个映射而且可能不是一一映射）。\n3. 根据**关键字/元素id**查找需要的view，处理之,如模拟点击。\n4. done\n\n## 源码分析\n\n### 学习AccessibilityService\n官方文档两篇文章通读之 [Android Train](http://developer.android.com/intl/zh-cn/training/accessibility/service.html) && [Android API指南](http://developer.android.com/intl/zh-cn/guide/topics/ui/accessibility/services.html)\n中文可以学习的文章 [Android中微信抢红包插件原理解析和开发实现](http://blog.csdn.net/jiangwei0910410003/article/details/48895153)\n\n### 关键API\n* Service配置\n\n```xml\n<!--自定义的服务和指定配置文件res/xml/accessible_service_config.xml-->\n<service\n            android:name=\".HongbaoService\"\n            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n            <intent-filter>\n                <action android:name=\"android.accessibilityservice.AccessibilityService\"/>\n            </intent-filter>\n            <meta-data android:name=\"android.accessibilityservice\"\n                       android:resource=\"@xml/accessible_service_config\"/>\n</service>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:description=\"@string/app_name\"\n    android:accessibilityEventTypes=\"typeWindowStateChanged|typeWindowContentChanged\"\n    android:accessibilityFeedbackType=\"feedbackAllMask\"\n    android:packageNames=\"com.tencent.mm\"\n    android:notificationTimeout=\"10\"\n    android:accessibilityFlags=\"\"\n    android:canRetrieveWindowContent=\"true\"/>\n```\n> android:packageNames=\"com.tencent.mm\" 指定要监听的程序的包名\n> android:canRetrieveWindowContent=\"true\" 可以获取具体的内容\n> android:accessibilityEventTypes 监听的事件\n> android:accessibilityFeedbackType=\"feedbackAllMask\" 设置反馈事件（如振动一下提示用户），这里是屏蔽所有反馈。\n\n* Servive回调\n\n```Java\n public void onAccessibilityEvent(AccessibilityEvent event) {\n // 回调\n }\n```\n* 节点查找\n\n```Java \n// 获取所有阶段\nAccessibilityNodeInfo nodeInfo = event.getSource();\n// 查找所有有\"领取红包\"的View\nList<AccessibilityNodeInfo> node1 = nodeInfo.findAccessibilityNodeInfosByText(\"领取红包\");\n// 查找所有id是com.tencent.mm:id/ar6\nList<AccessibilityNodeInfo> node2 = nodeInfo.findAccessibilityNodeInfosByViewId(\"com.tencent.mm:id/ar6\");\n```\n注：可以通过DDMS里的Dump View Hierarchy For UI Automator 分析UI结构来获取id\n\n* 出发操作\n\n```Java\n// 对某个节点操作\ncellNode.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n// 按下手机的后退键\nperformGlobalAction(GLOBAL_ACTION_BACK);\n```\n* 启动Accessibility的系统设置界面，需要用户手动打开服务\n\n```Java\nIntent intent =\n            new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);\nstartActivity(intent);\n```\n\n### 几个注意点\n* AccessibilityService 建议在Android4.0以及以上版本中使用，也有support_v4 向下兼容。\n* Services配置可以通过xml配置，也可以通过代码配置\n* **不同系统的Api可能结果不同**（如API16），如查找不到一些元素\n\n> In Android 4.1 (API Level 16) and higher, the getSource() method, as well as AccessibilityNodeInfo.getChild() and getParent(), return only view objects that are considered important for accessibility (views that draw content or respond to user actions). If your service requires all views, it can request them by setting the flags member of the service's AccessibilityServiceInfo instance to **FLAG_INCLUDE_NOT_IMPORTANT_VIEWS**\n\n* AccessibilityNode可能有一个实例池的设计。获取当前窗体节点树的时候，从一个可重用的实例池中获取一个辅助节点信息 (AccessibilityNodeInfo)实例。在接下来的获取时，仍然从实例池中获取节点实例，这时可能会重用之前的实例。这样的设计是有好处的，可以防止每次返回都创建大量的实例，影响性能。AccessibilityNodeProvider的源码表明了这样的设计。\n\n\n### 抢红包\n\n[微信抢红包插件](https://github.com/geeeeeeeeek/WeChatLuckyMoney)的dev分支的逻辑比较复杂（参考工程的README文件，致力于区分各种状态和不重复抢相同红包），实测不稳定，**stable分支逻辑比较简单也较稳定**。具体代码就不说了。\n\n## Do Something\n抢红包插件网上有很多实现，我所见的都是用AccessibilityService来做的。用这个Service的确可以做一些有趣的事情，打算在后续阶段用这个原理**写一个微信自动聊天程序**，当然是要建立在自己搭建的框架之上的。\n\n","source":"_posts/抢红包插件分析以及应用.md","raw":"title: 抢红包插件分析以及应用\ndate: 2016-01-17 16:07:44\ncategories:\n- 技术\ntags:\n- Android\n- 其他\n---\n临近春节，群里的红包又多了（也许仅仅是群多了），由于流行了各种抢红包插件，红包基本是秒没的节奏。在好奇心的驱使下研究了一下抢红包插件的原理，发现既简单又很有意思。还能用来干些其他羞羞的事情😉。。\n\n> 参考Github项目源码  [微信抢红包插件](https://github.com/geeeeeeeeek/WeChatLuckyMoney)\n\n## 基本原理\n\n在没有看Github上的实现的时候，我天真地以为这种插件的原理类似于PC平台上的按键精灵（Android版也有），或者一些测试化工具。这一类软件实现起来应当比较复杂，Too Yang Too Simple。Android已经提供了完备的系统。\n> AccessibilityService 服务（Service），初衷是用于辅助服务，总之它的**功能是根据用户的一些操作给用户相应的提示**，如给残疾人自动读出选择的文字。\n\n我们需要做的是\n1. 继承AccessibilityService，写自定义的辅助服务\n2. 当用户App的界面发送变化时，会触发Service的相关回调，在该回调中可以获取**当前界面中的UI界面元素节点**（不是view本身，是它的一个映射而且可能不是一一映射）。\n3. 根据**关键字/元素id**查找需要的view，处理之,如模拟点击。\n4. done\n\n## 源码分析\n\n### 学习AccessibilityService\n官方文档两篇文章通读之 [Android Train](http://developer.android.com/intl/zh-cn/training/accessibility/service.html) && [Android API指南](http://developer.android.com/intl/zh-cn/guide/topics/ui/accessibility/services.html)\n中文可以学习的文章 [Android中微信抢红包插件原理解析和开发实现](http://blog.csdn.net/jiangwei0910410003/article/details/48895153)\n\n### 关键API\n* Service配置\n\n```xml\n<!--自定义的服务和指定配置文件res/xml/accessible_service_config.xml-->\n<service\n            android:name=\".HongbaoService\"\n            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n            <intent-filter>\n                <action android:name=\"android.accessibilityservice.AccessibilityService\"/>\n            </intent-filter>\n            <meta-data android:name=\"android.accessibilityservice\"\n                       android:resource=\"@xml/accessible_service_config\"/>\n</service>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:description=\"@string/app_name\"\n    android:accessibilityEventTypes=\"typeWindowStateChanged|typeWindowContentChanged\"\n    android:accessibilityFeedbackType=\"feedbackAllMask\"\n    android:packageNames=\"com.tencent.mm\"\n    android:notificationTimeout=\"10\"\n    android:accessibilityFlags=\"\"\n    android:canRetrieveWindowContent=\"true\"/>\n```\n> android:packageNames=\"com.tencent.mm\" 指定要监听的程序的包名\n> android:canRetrieveWindowContent=\"true\" 可以获取具体的内容\n> android:accessibilityEventTypes 监听的事件\n> android:accessibilityFeedbackType=\"feedbackAllMask\" 设置反馈事件（如振动一下提示用户），这里是屏蔽所有反馈。\n\n* Servive回调\n\n```Java\n public void onAccessibilityEvent(AccessibilityEvent event) {\n // 回调\n }\n```\n* 节点查找\n\n```Java \n// 获取所有阶段\nAccessibilityNodeInfo nodeInfo = event.getSource();\n// 查找所有有\"领取红包\"的View\nList<AccessibilityNodeInfo> node1 = nodeInfo.findAccessibilityNodeInfosByText(\"领取红包\");\n// 查找所有id是com.tencent.mm:id/ar6\nList<AccessibilityNodeInfo> node2 = nodeInfo.findAccessibilityNodeInfosByViewId(\"com.tencent.mm:id/ar6\");\n```\n注：可以通过DDMS里的Dump View Hierarchy For UI Automator 分析UI结构来获取id\n\n* 出发操作\n\n```Java\n// 对某个节点操作\ncellNode.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n// 按下手机的后退键\nperformGlobalAction(GLOBAL_ACTION_BACK);\n```\n* 启动Accessibility的系统设置界面，需要用户手动打开服务\n\n```Java\nIntent intent =\n            new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);\nstartActivity(intent);\n```\n\n### 几个注意点\n* AccessibilityService 建议在Android4.0以及以上版本中使用，也有support_v4 向下兼容。\n* Services配置可以通过xml配置，也可以通过代码配置\n* **不同系统的Api可能结果不同**（如API16），如查找不到一些元素\n\n> In Android 4.1 (API Level 16) and higher, the getSource() method, as well as AccessibilityNodeInfo.getChild() and getParent(), return only view objects that are considered important for accessibility (views that draw content or respond to user actions). If your service requires all views, it can request them by setting the flags member of the service's AccessibilityServiceInfo instance to **FLAG_INCLUDE_NOT_IMPORTANT_VIEWS**\n\n* AccessibilityNode可能有一个实例池的设计。获取当前窗体节点树的时候，从一个可重用的实例池中获取一个辅助节点信息 (AccessibilityNodeInfo)实例。在接下来的获取时，仍然从实例池中获取节点实例，这时可能会重用之前的实例。这样的设计是有好处的，可以防止每次返回都创建大量的实例，影响性能。AccessibilityNodeProvider的源码表明了这样的设计。\n\n\n### 抢红包\n\n[微信抢红包插件](https://github.com/geeeeeeeeek/WeChatLuckyMoney)的dev分支的逻辑比较复杂（参考工程的README文件，致力于区分各种状态和不重复抢相同红包），实测不稳定，**stable分支逻辑比较简单也较稳定**。具体代码就不说了。\n\n## Do Something\n抢红包插件网上有很多实现，我所见的都是用AccessibilityService来做的。用这个Service的确可以做一些有趣的事情，打算在后续阶段用这个原理**写一个微信自动聊天程序**，当然是要建立在自己搭建的框架之上的。\n\n","slug":"抢红包插件分析以及应用","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbcy0019nac9hqdioba2","content":"<p>临近春节，群里的红包又多了（也许仅仅是群多了），由于流行了各种抢红包插件，红包基本是秒没的节奏。在好奇心的驱使下研究了一下抢红包插件的原理，发现既简单又很有意思。还能用来干些其他羞羞的事情😉。。</p>\n<blockquote>\n<p>参考Github项目源码  <a href=\"https://github.com/geeeeeeeeek/WeChatLuckyMoney\" target=\"_blank\" rel=\"external\">微信抢红包插件</a></p>\n</blockquote>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>在没有看Github上的实现的时候，我天真地以为这种插件的原理类似于PC平台上的按键精灵（Android版也有），或者一些测试化工具。这一类软件实现起来应当比较复杂，Too Yang Too Simple。Android已经提供了完备的系统。</p>\n<blockquote>\n<p>AccessibilityService 服务（Service），初衷是用于辅助服务，总之它的<strong>功能是根据用户的一些操作给用户相应的提示</strong>，如给残疾人自动读出选择的文字。</p>\n</blockquote>\n<p>我们需要做的是</p>\n<ol>\n<li>继承AccessibilityService，写自定义的辅助服务</li>\n<li>当用户App的界面发送变化时，会触发Service的相关回调，在该回调中可以获取<strong>当前界面中的UI界面元素节点</strong>（不是view本身，是它的一个映射而且可能不是一一映射）。</li>\n<li>根据<strong>关键字/元素id</strong>查找需要的view，处理之,如模拟点击。</li>\n<li>done</li>\n</ol>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"学习AccessibilityService\"><a href=\"#学习AccessibilityService\" class=\"headerlink\" title=\"学习AccessibilityService\"></a>学习AccessibilityService</h3><p>官方文档两篇文章通读之 <a href=\"http://developer.android.com/intl/zh-cn/training/accessibility/service.html\" target=\"_blank\" rel=\"external\">Android Train</a> &amp;&amp; <a href=\"http://developer.android.com/intl/zh-cn/guide/topics/ui/accessibility/services.html\" target=\"_blank\" rel=\"external\">Android API指南</a><br>中文可以学习的文章 <a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/48895153\" target=\"_blank\" rel=\"external\">Android中微信抢红包插件原理解析和开发实现</a></p>\n<h3 id=\"关键API\"><a href=\"#关键API\" class=\"headerlink\" title=\"关键API\"></a>关键API</h3><ul>\n<li>Service配置</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!--自定义的服务和指定配置文件res/xml/accessible_service_config.xml--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span></span></div><div class=\"line\">            <span class=\"attr\">android:name</span>=<span class=\"string\">\".HongbaoService\"</span></div><div class=\"line\">            <span class=\"attr\">android:permission</span>=<span class=\"string\">\"android.permission.BIND_ACCESSIBILITY_SERVICE\"</span>&gt;</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.accessibilityservice.AccessibilityService\"</span>/&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.accessibilityservice\"</span></span></div><div class=\"line\">                       <span class=\"attr\">android:resource</span>=<span class=\"string\">\"@xml/accessible_service_config\"</span>/&gt;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">service</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"php\"><span class=\"meta\">&lt;?</span>xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"utf-8\"</span><span class=\"meta\">?&gt;</span></span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">accessibility-service</span></span></div><div class=\"line\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></div><div class=\"line\">    <span class=\"attr\">android:description</span>=<span class=\"string\">\"@string/app_name\"</span></div><div class=\"line\">    <span class=\"attr\">android:accessibilityEventTypes</span>=<span class=\"string\">\"typeWindowStateChanged|typeWindowContentChanged\"</span></div><div class=\"line\">    <span class=\"attr\">android:accessibilityFeedbackType</span>=<span class=\"string\">\"feedbackAllMask\"</span></div><div class=\"line\">    <span class=\"attr\">android:packageNames</span>=<span class=\"string\">\"com.tencent.mm\"</span></div><div class=\"line\">    <span class=\"attr\">android:notificationTimeout</span>=<span class=\"string\">\"10\"</span></div><div class=\"line\">    <span class=\"attr\">android:accessibilityFlags</span>=<span class=\"string\">\"\"</span></div><div class=\"line\">    <span class=\"attr\">android:canRetrieveWindowContent</span>=<span class=\"string\">\"true\"</span>/&gt;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>android:packageNames=”com.tencent.mm” 指定要监听的程序的包名<br>android:canRetrieveWindowContent=”true” 可以获取具体的内容<br>android:accessibilityEventTypes 监听的事件<br>android:accessibilityFeedbackType=”feedbackAllMask” 设置反馈事件（如振动一下提示用户），这里是屏蔽所有反馈。</p>\n</blockquote>\n<ul>\n<li>Servive回调</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAccessibilityEvent</span><span class=\"params\">(AccessibilityEvent event)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">// 回调</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>节点查找</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取所有阶段</span></div><div class=\"line\">AccessibilityNodeInfo nodeInfo = event.getSource();</div><div class=\"line\"><span class=\"comment\">// 查找所有有\"领取红包\"的View</span></div><div class=\"line\">List&lt;AccessibilityNodeInfo&gt; node1 = nodeInfo.findAccessibilityNodeInfosByText(<span class=\"string\">\"领取红包\"</span>);</div><div class=\"line\"><span class=\"comment\">// 查找所有id是com.tencent.mm:id/ar6</span></div><div class=\"line\">List&lt;AccessibilityNodeInfo&gt; node2 = nodeInfo.findAccessibilityNodeInfosByViewId(<span class=\"string\">\"com.tencent.mm:id/ar6\"</span>);</div></pre></td></tr></table></figure>\n<p>注：可以通过DDMS里的Dump View Hierarchy For UI Automator 分析UI结构来获取id</p>\n<ul>\n<li>出发操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 对某个节点操作</span></div><div class=\"line\">cellNode.performAction(AccessibilityNodeInfo.ACTION_CLICK);</div><div class=\"line\"><span class=\"comment\">// 按下手机的后退键</span></div><div class=\"line\">performGlobalAction(GLOBAL_ACTION_BACK);</div></pre></td></tr></table></figure>\n<ul>\n<li>启动Accessibility的系统设置界面，需要用户手动打开服务</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent =</div><div class=\"line\">            <span class=\"keyword\">new</span> Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<h3 id=\"几个注意点\"><a href=\"#几个注意点\" class=\"headerlink\" title=\"几个注意点\"></a>几个注意点</h3><ul>\n<li>AccessibilityService 建议在Android4.0以及以上版本中使用，也有support_v4 向下兼容。</li>\n<li>Services配置可以通过xml配置，也可以通过代码配置</li>\n<li><strong>不同系统的Api可能结果不同</strong>（如API16），如查找不到一些元素</li>\n</ul>\n<blockquote>\n<p>In Android 4.1 (API Level 16) and higher, the getSource() method, as well as AccessibilityNodeInfo.getChild() and getParent(), return only view objects that are considered important for accessibility (views that draw content or respond to user actions). If your service requires all views, it can request them by setting the flags member of the service’s AccessibilityServiceInfo instance to <strong>FLAG_INCLUDE_NOT_IMPORTANT_VIEWS</strong></p>\n</blockquote>\n<ul>\n<li>AccessibilityNode可能有一个实例池的设计。获取当前窗体节点树的时候，从一个可重用的实例池中获取一个辅助节点信息 (AccessibilityNodeInfo)实例。在接下来的获取时，仍然从实例池中获取节点实例，这时可能会重用之前的实例。这样的设计是有好处的，可以防止每次返回都创建大量的实例，影响性能。AccessibilityNodeProvider的源码表明了这样的设计。</li>\n</ul>\n<h3 id=\"抢红包\"><a href=\"#抢红包\" class=\"headerlink\" title=\"抢红包\"></a>抢红包</h3><p><a href=\"https://github.com/geeeeeeeeek/WeChatLuckyMoney\" target=\"_blank\" rel=\"external\">微信抢红包插件</a>的dev分支的逻辑比较复杂（参考工程的README文件，致力于区分各种状态和不重复抢相同红包），实测不稳定，<strong>stable分支逻辑比较简单也较稳定</strong>。具体代码就不说了。</p>\n<h2 id=\"Do-Something\"><a href=\"#Do-Something\" class=\"headerlink\" title=\"Do Something\"></a>Do Something</h2><p>抢红包插件网上有很多实现，我所见的都是用AccessibilityService来做的。用这个Service的确可以做一些有趣的事情，打算在后续阶段用这个原理<strong>写一个微信自动聊天程序</strong>，当然是要建立在自己搭建的框架之上的。</p>\n","excerpt":"","more":"<p>临近春节，群里的红包又多了（也许仅仅是群多了），由于流行了各种抢红包插件，红包基本是秒没的节奏。在好奇心的驱使下研究了一下抢红包插件的原理，发现既简单又很有意思。还能用来干些其他羞羞的事情😉。。</p>\n<blockquote>\n<p>参考Github项目源码  <a href=\"https://github.com/geeeeeeeeek/WeChatLuckyMoney\">微信抢红包插件</a></p>\n</blockquote>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>在没有看Github上的实现的时候，我天真地以为这种插件的原理类似于PC平台上的按键精灵（Android版也有），或者一些测试化工具。这一类软件实现起来应当比较复杂，Too Yang Too Simple。Android已经提供了完备的系统。</p>\n<blockquote>\n<p>AccessibilityService 服务（Service），初衷是用于辅助服务，总之它的<strong>功能是根据用户的一些操作给用户相应的提示</strong>，如给残疾人自动读出选择的文字。</p>\n</blockquote>\n<p>我们需要做的是</p>\n<ol>\n<li>继承AccessibilityService，写自定义的辅助服务</li>\n<li>当用户App的界面发送变化时，会触发Service的相关回调，在该回调中可以获取<strong>当前界面中的UI界面元素节点</strong>（不是view本身，是它的一个映射而且可能不是一一映射）。</li>\n<li>根据<strong>关键字/元素id</strong>查找需要的view，处理之,如模拟点击。</li>\n<li>done</li>\n</ol>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"学习AccessibilityService\"><a href=\"#学习AccessibilityService\" class=\"headerlink\" title=\"学习AccessibilityService\"></a>学习AccessibilityService</h3><p>官方文档两篇文章通读之 <a href=\"http://developer.android.com/intl/zh-cn/training/accessibility/service.html\">Android Train</a> &amp;&amp; <a href=\"http://developer.android.com/intl/zh-cn/guide/topics/ui/accessibility/services.html\">Android API指南</a><br>中文可以学习的文章 <a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/48895153\">Android中微信抢红包插件原理解析和开发实现</a></p>\n<h3 id=\"关键API\"><a href=\"#关键API\" class=\"headerlink\" title=\"关键API\"></a>关键API</h3><ul>\n<li>Service配置</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!--自定义的服务和指定配置文件res/xml/accessible_service_config.xml--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span></div><div class=\"line\">            <span class=\"attr\">android:name</span>=<span class=\"string\">\".HongbaoService\"</span></div><div class=\"line\">            <span class=\"attr\">android:permission</span>=<span class=\"string\">\"android.permission.BIND_ACCESSIBILITY_SERVICE\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.accessibilityservice.AccessibilityService\"</span>/&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.accessibilityservice\"</span></div><div class=\"line\">                       <span class=\"attr\">android:resource</span>=<span class=\"string\">\"@xml/accessible_service_config\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">service</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"php\"><span class=\"meta\">&lt;?</span>xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"utf-8\"</span><span class=\"meta\">?&gt;</span></span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">accessibility-service</span></div><div class=\"line\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></div><div class=\"line\">    <span class=\"attr\">android:description</span>=<span class=\"string\">\"@string/app_name\"</span></div><div class=\"line\">    <span class=\"attr\">android:accessibilityEventTypes</span>=<span class=\"string\">\"typeWindowStateChanged|typeWindowContentChanged\"</span></div><div class=\"line\">    <span class=\"attr\">android:accessibilityFeedbackType</span>=<span class=\"string\">\"feedbackAllMask\"</span></div><div class=\"line\">    <span class=\"attr\">android:packageNames</span>=<span class=\"string\">\"com.tencent.mm\"</span></div><div class=\"line\">    <span class=\"attr\">android:notificationTimeout</span>=<span class=\"string\">\"10\"</span></div><div class=\"line\">    <span class=\"attr\">android:accessibilityFlags</span>=<span class=\"string\">\"\"</span></div><div class=\"line\">    <span class=\"attr\">android:canRetrieveWindowContent</span>=<span class=\"string\">\"true\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>android:packageNames=”com.tencent.mm” 指定要监听的程序的包名<br>android:canRetrieveWindowContent=”true” 可以获取具体的内容<br>android:accessibilityEventTypes 监听的事件<br>android:accessibilityFeedbackType=”feedbackAllMask” 设置反馈事件（如振动一下提示用户），这里是屏蔽所有反馈。</p>\n</blockquote>\n<ul>\n<li>Servive回调</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAccessibilityEvent</span><span class=\"params\">(AccessibilityEvent event)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">// 回调</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>节点查找</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取所有阶段</span></div><div class=\"line\">AccessibilityNodeInfo nodeInfo = event.getSource();</div><div class=\"line\"><span class=\"comment\">// 查找所有有\"领取红包\"的View</span></div><div class=\"line\">List&lt;AccessibilityNodeInfo&gt; node1 = nodeInfo.findAccessibilityNodeInfosByText(<span class=\"string\">\"领取红包\"</span>);</div><div class=\"line\"><span class=\"comment\">// 查找所有id是com.tencent.mm:id/ar6</span></div><div class=\"line\">List&lt;AccessibilityNodeInfo&gt; node2 = nodeInfo.findAccessibilityNodeInfosByViewId(<span class=\"string\">\"com.tencent.mm:id/ar6\"</span>);</div></pre></td></tr></table></figure>\n<p>注：可以通过DDMS里的Dump View Hierarchy For UI Automator 分析UI结构来获取id</p>\n<ul>\n<li>出发操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 对某个节点操作</span></div><div class=\"line\">cellNode.performAction(AccessibilityNodeInfo.ACTION_CLICK);</div><div class=\"line\"><span class=\"comment\">// 按下手机的后退键</span></div><div class=\"line\">performGlobalAction(GLOBAL_ACTION_BACK);</div></pre></td></tr></table></figure>\n<ul>\n<li>启动Accessibility的系统设置界面，需要用户手动打开服务</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent =</div><div class=\"line\">            <span class=\"keyword\">new</span> Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<h3 id=\"几个注意点\"><a href=\"#几个注意点\" class=\"headerlink\" title=\"几个注意点\"></a>几个注意点</h3><ul>\n<li>AccessibilityService 建议在Android4.0以及以上版本中使用，也有support_v4 向下兼容。</li>\n<li>Services配置可以通过xml配置，也可以通过代码配置</li>\n<li><strong>不同系统的Api可能结果不同</strong>（如API16），如查找不到一些元素</li>\n</ul>\n<blockquote>\n<p>In Android 4.1 (API Level 16) and higher, the getSource() method, as well as AccessibilityNodeInfo.getChild() and getParent(), return only view objects that are considered important for accessibility (views that draw content or respond to user actions). If your service requires all views, it can request them by setting the flags member of the service’s AccessibilityServiceInfo instance to <strong>FLAG_INCLUDE_NOT_IMPORTANT_VIEWS</strong></p>\n</blockquote>\n<ul>\n<li>AccessibilityNode可能有一个实例池的设计。获取当前窗体节点树的时候，从一个可重用的实例池中获取一个辅助节点信息 (AccessibilityNodeInfo)实例。在接下来的获取时，仍然从实例池中获取节点实例，这时可能会重用之前的实例。这样的设计是有好处的，可以防止每次返回都创建大量的实例，影响性能。AccessibilityNodeProvider的源码表明了这样的设计。</li>\n</ul>\n<h3 id=\"抢红包\"><a href=\"#抢红包\" class=\"headerlink\" title=\"抢红包\"></a>抢红包</h3><p><a href=\"https://github.com/geeeeeeeeek/WeChatLuckyMoney\">微信抢红包插件</a>的dev分支的逻辑比较复杂（参考工程的README文件，致力于区分各种状态和不重复抢相同红包），实测不稳定，<strong>stable分支逻辑比较简单也较稳定</strong>。具体代码就不说了。</p>\n<h2 id=\"Do-Something\"><a href=\"#Do-Something\" class=\"headerlink\" title=\"Do Something\"></a>Do Something</h2><p>抢红包插件网上有很多实现，我所见的都是用AccessibilityService来做的。用这个Service的确可以做一些有趣的事情，打算在后续阶段用这个原理<strong>写一个微信自动聊天程序</strong>，当然是要建立在自己搭建的框架之上的。</p>\n"},{"title":"是时候开始写博客了","date":"2016-01-04T06:03:30.000Z","_content":"## 开写咯\n新的一年又开始啦，和去年一样，每年都要做一件有价值的事情。\n话说写博客真的计划了好久，一直都在计划ing，似乎可以写一个大纪事了。好吧，我承认这是拖延症晚期。\n\n## 大纪事\n\n* 2014-07 刚毕业，计划开始写博客，开通了CSDN，仅仅是开通了。\n* 2015-06 和朋友聊天，决定要写博客，买了域名[limuzhi.com](http://www.limuzhi.com)，折腾了备案那些破事，虚拟机和wordpress，好low，然后就没有然后了。\n* 2015-12 闲逛的时候发现可以用github搭建。一看node.js && hexo && macdown，瞬间高大上，花了半天配置完。\n* 2016-01 正式开始写，目标**至少一周一更**。\n\n## 目标\n\n从大学开始就有做笔记[^1]的习惯 ，可惜发现一些问题，一个是自己看的笔记质量没有保障，本着『大概看懂』就行。其次，很少回去回顾，写了就放那，没有后续收益。希望在线博客这种\"新方式\"能带来一些改变,下面给自己设定一些目标。\n\n* 一周一更，一周一更，一周一更，重要的事情说三遍\n* 干货\n* 信达雅。。。尽力吧\n\n## Enjoy\n\n\n``` java\nSystem.out.println(\"hello world\");\n```\n\n\n\n[^1]: 用wiz笔记，目录+tag的方式，记录的很多且乱，被当成收藏夹用了。","source":"_posts/是时候开始写博客了.md","raw":"title: 是时候开始写博客了\ndate: 2016-01-04 14:03:30\ncategories:\n- 杂谈\ntags:  \n---\n## 开写咯\n新的一年又开始啦，和去年一样，每年都要做一件有价值的事情。\n话说写博客真的计划了好久，一直都在计划ing，似乎可以写一个大纪事了。好吧，我承认这是拖延症晚期。\n\n## 大纪事\n\n* 2014-07 刚毕业，计划开始写博客，开通了CSDN，仅仅是开通了。\n* 2015-06 和朋友聊天，决定要写博客，买了域名[limuzhi.com](http://www.limuzhi.com)，折腾了备案那些破事，虚拟机和wordpress，好low，然后就没有然后了。\n* 2015-12 闲逛的时候发现可以用github搭建。一看node.js && hexo && macdown，瞬间高大上，花了半天配置完。\n* 2016-01 正式开始写，目标**至少一周一更**。\n\n## 目标\n\n从大学开始就有做笔记[^1]的习惯 ，可惜发现一些问题，一个是自己看的笔记质量没有保障，本着『大概看懂』就行。其次，很少回去回顾，写了就放那，没有后续收益。希望在线博客这种\"新方式\"能带来一些改变,下面给自己设定一些目标。\n\n* 一周一更，一周一更，一周一更，重要的事情说三遍\n* 干货\n* 信达雅。。。尽力吧\n\n## Enjoy\n\n\n``` java\nSystem.out.println(\"hello world\");\n```\n\n\n\n[^1]: 用wiz笔记，目录+tag的方式，记录的很多且乱，被当成收藏夹用了。","slug":"是时候开始写博客了","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbd5001cnac9t0j140g9","content":"<h2 id=\"开写咯\"><a href=\"#开写咯\" class=\"headerlink\" title=\"开写咯\"></a>开写咯</h2><p>新的一年又开始啦，和去年一样，每年都要做一件有价值的事情。<br>话说写博客真的计划了好久，一直都在计划ing，似乎可以写一个大纪事了。好吧，我承认这是拖延症晚期。</p>\n<h2 id=\"大纪事\"><a href=\"#大纪事\" class=\"headerlink\" title=\"大纪事\"></a>大纪事</h2><ul>\n<li>2014-07 刚毕业，计划开始写博客，开通了CSDN，仅仅是开通了。</li>\n<li>2015-06 和朋友聊天，决定要写博客，买了域名<a href=\"http://www.limuzhi.com\" target=\"_blank\" rel=\"external\">limuzhi.com</a>，折腾了备案那些破事，虚拟机和wordpress，好low，然后就没有然后了。</li>\n<li>2015-12 闲逛的时候发现可以用github搭建。一看node.js &amp;&amp; hexo &amp;&amp; macdown，瞬间高大上，花了半天配置完。</li>\n<li>2016-01 正式开始写，目标<strong>至少一周一更</strong>。</li>\n</ul>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>从大学开始就有做笔记<a href=\"用wiz笔记，目录+tag的方式，记录的很多且乱，被当成收藏夹用了。\">^1</a>的习惯 ，可惜发现一些问题，一个是自己看的笔记质量没有保障，本着『大概看懂』就行。其次，很少回去回顾，写了就放那，没有后续收益。希望在线博客这种”新方式”能带来一些改变,下面给自己设定一些目标。</p>\n<ul>\n<li>一周一更，一周一更，一周一更，重要的事情说三遍</li>\n<li>干货</li>\n<li>信达雅。。。尽力吧</li>\n</ul>\n<h2 id=\"Enjoy\"><a href=\"#Enjoy\" class=\"headerlink\" title=\"Enjoy\"></a>Enjoy</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.out.println(<span class=\"string\">\"hello world\"</span>);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"开写咯\"><a href=\"#开写咯\" class=\"headerlink\" title=\"开写咯\"></a>开写咯</h2><p>新的一年又开始啦，和去年一样，每年都要做一件有价值的事情。<br>话说写博客真的计划了好久，一直都在计划ing，似乎可以写一个大纪事了。好吧，我承认这是拖延症晚期。</p>\n<h2 id=\"大纪事\"><a href=\"#大纪事\" class=\"headerlink\" title=\"大纪事\"></a>大纪事</h2><ul>\n<li>2014-07 刚毕业，计划开始写博客，开通了CSDN，仅仅是开通了。</li>\n<li>2015-06 和朋友聊天，决定要写博客，买了域名<a href=\"http://www.limuzhi.com\">limuzhi.com</a>，折腾了备案那些破事，虚拟机和wordpress，好low，然后就没有然后了。</li>\n<li>2015-12 闲逛的时候发现可以用github搭建。一看node.js &amp;&amp; hexo &amp;&amp; macdown，瞬间高大上，花了半天配置完。</li>\n<li>2016-01 正式开始写，目标<strong>至少一周一更</strong>。</li>\n</ul>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>从大学开始就有做笔记<a href=\"用wiz笔记，目录+tag的方式，记录的很多且乱，被当成收藏夹用了。\">^1</a>的习惯 ，可惜发现一些问题，一个是自己看的笔记质量没有保障，本着『大概看懂』就行。其次，很少回去回顾，写了就放那，没有后续收益。希望在线博客这种”新方式”能带来一些改变,下面给自己设定一些目标。</p>\n<ul>\n<li>一周一更，一周一更，一周一更，重要的事情说三遍</li>\n<li>干货</li>\n<li>信达雅。。。尽力吧</li>\n</ul>\n<h2 id=\"Enjoy\"><a href=\"#Enjoy\" class=\"headerlink\" title=\"Enjoy\"></a>Enjoy</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.out.println(<span class=\"string\">\"hello world\"</span>);</div></pre></td></tr></table></figure>\n"},{"title":"版本控制工具Git入门实践","date":"2016-06-25T01:25:19.000Z","_content":"\n在软件开发中有一些是**通用技能**，无论从事什么项目，C、Java、前段、后台，都必须掌握的（甚至产品设计与UI设计都需要）：\n\n* 操作系统的使用：MacOs/Linux/Win\n* 版本协作工具：SVN/**Git**\n* 文本工具：Vim/SublimeText/**MarkDown**\n* IDE：Eclipse/Idea\n* 效率工具：Alfred\n\n这些技能应当优先熟练掌握，今天聊一聊版本控制工具Git。之前一直使用的是SVN，也仅仅停留在工作中使用，甚至不会使用svn命令，只能使用SVN Tortoise，也就是拉代码，解决冲突，提交代码这三个步骤，偶尔拉一下分支（甚至都没有亲自合并过分支。。）。\n\n对于Git使用，说来已久，从一开始在Github上面copy代码（clone），到背git命令，了解git flow开发模型，都是理论大于实践，以至于最近工作的代码使用了Git后，\b一脸的蒙逼。本质来说没有理解Git的核心思想。\n\n老规矩，下面是学习的一些资料，这次没有找英文的原始资料，因为这方面国内很多资料，就不折腾翻译了：\n\n* [走进git时代系列一、二、三](https://yq.aliyun.com/articles/5843?spm=5176.100239.blogcont7441.8.GnX3p9)：基本够了\n\n\n* [使用原理视角看 Git](https://segmentfault.com/a/1190000005695097)\n\n\n\n## 概念理解\n\n### 核心概念：**分支开发**\n\n这是Git中最最重要的一个概念，也是与SVN等其他工具最核心的不同。\n\n在Git的开发中，分支是一个轻量级的概念，因此新建分支，合并分支，删除分支在开发中十分常见，我们开发时应当遵循这样的基于分支的开发流程：\n\n1. 当有一个新需求、bug需要开发时，从origin/master新建一个分支,feature01/bugfix01。\n2. 切换到该分支上，开发。。修复a1，add，修复a2，add。。。\n3. 开发完成后commit（一般保持一个commit记录）\n4. git fetch origin master 从origin master更新代码(从网络更新代码到FETCH_HEAD,可以更新到master)\n5. rebase到当前分支上\n6. push\n\n\n\n### 理解远程分支与本地分支\n\n* 本质上，他们都是分支！\n\n\n* 本地分支中的默认分支`master`也是分支，它是以`origin/master分支`初始化的一个普通分支。\n\n\n* **分支本质是n个commit的list**。如果本地`master`与`origin/master`同步（不在本地master上commit，修改可以，不要提交），更新之后，那么master与origin/master就是一样的。\n\n一个新的项目clone后有哪些分支：\n\n![all branch](images/git_branch_all.png)\n\n* `master` 当前的默认分支，第一次取下来后与`origin/master `指向相同，但是后续可以在上面开发\n\n\n* `origin/master` 远程分支，内容是**最后一次从远程origin获取的所有commit**的分支，无法修改数据，本地数据，但含义是\n\n  > `remotes/origin/master`和`origin/master`的指向是相同的\n  >\n  > - `master` is a local branch\n  > - `origin/master` is a remote branch (which is a *local copy* of the branch named \"master\" on the remote named \"origin\")\n\n哪些指针：\n\n* `HEAD`\n* `FETCH_HEAD `\n* `origin/master/HEAD` 指向`origin/master`的提交，与`HEAD`区分\n\n\n### 理解本地的三个工作区\n\n#### 1. 工作目录workspace\n\n这个可以直接理解成**普通的文件夹，文件**， 这几个角度：\n\n* 工作区全局只有一个，没有多个备份，它不会保存完整的状态。\n\n* 不commit就切换分支会污染工作目录！（不commit，**且有冲突**的情况下，Git不会让你切换的，**如果没有冲突，则会合并！**）\n\n  > error: Your local changes to the following files would be overwritten by checkout:\n  >\n  > **建议：切换分支前先commit**，养成commit的习惯\n\n* 从其他分支合并，或者从网络fetch后merge（pull），都是合入工作区。因此要注意在此之前add/commit操作。\n\n  > 泛化的理解：Git的所有操作都是先针对工作区修改，因此在执行例如合并之类的操作必须要add或者commit\n\n#### 2. 暂存区 Stage/Index\n\n暂存区是Git维护的，用户手动添加，暂存区只对当前分支有效，\n\n* 工作区全局只有一个，没有多个备份，它不会保存完整的状态。\n* 因此，在切换分支时，暂存区也会被污染！具体情况与上面第二点相同（不commit，**且有冲突**的情况下，Git不会让你切换的，**如果没有冲突，则会合并！**）。\n* 与工作区不同，在从合入分支时，它不受影响，这也是暂存区的作用。\n\n#### 3. 本地仓库\n\n**分支本质是n个commit的list**。\n\n* 本地仓库中含有n个分支。包括一个默认的本地master（映射到origin/maser）和其他本地分支（可能没有映射，也可能映射到远程对于的分支）。\n\n* 切换分支时，只是指针切换，仓库内容不受影响，**只会更新工作目录（文件的删除添加）与暂存区（一般是清空，如果暂存区非空，且不冲突也会保留）**\n\n* 合并操作，会修复被合入的分支内容（某个commit的提交内容，或者commit的list）\n\n\n\n\n### 工作目录中文件的三种状态\n\n* 已提交（committed）：该文件被安全地保存在了本地数据库\n\n* 已暂存（staged）：把已修改的文件放下下次保存的清单中\n\n* 已修改（modified）：修改了某个文件，但还没有保存，此外还有从没有add过的新文件，**未追踪untracked**\n\n  参考下图学习：\n\n  ![git status](images/git_status_capture.png)\n\n几个关注点：\n\n* 红色表示在工作目录的文件，绿色表示在暂存区的文件\n* `Changes to be committed:`下的`new file`表示，暂存区与仓库对比，他们是新文件（如果有`modified`表示，暂存区与仓库对比是修改的）\n* `Changes not staged for commit:`下的`modified`表示，工作区与暂存区/仓库对比是修改的\n* `Untracked files:`下的是没有加入过暂存区的内容（在暂存区/仓库找不到对比对象）\n* 注意有两个hell3.txt，一个是工作目录的，一个是暂存区的，这说明**加入暂存区后该文件被修改过。**\n\n\n\n### HEAD\n\n`HEAD`是一个指针，指向的是**本地仓库**中**当前分支**的一个commit记录！该commit是当前正在工作的commit。\n什么时机HEAD会移动：\n\n* git checkout后指向新分支的commit（跨分支）\n* git commit后HEAD移动指向的commit（同一分支，向前）\n* merge，rebase，fast-forward\n\n注意：它指向的内容与工作目录和暂存区可能都不同，因此可以用HEAD来执行恢复操作。\n\n\n### fast-forward merge\n\n快进模式 一个常用概念，指的是谁forward呢？是**HEAD的快速向前移动**。\n\n出现的情况：\n\n* merge完成时，被合入分支的最后一个commit在待合入分支之中，移动HEAD到最后一个commit。如下图所示：\n\n  ![fast forward](images/git_fast_forward_merge.png)\n\n* rebase完成后，commit记录合入后，HEAD指针直接向前移动多个commit。\n\n总之，当前分支是master，执行`git merge branch1`。master分支最好的commit是目标分支branch1的祖先commit节点时，会发生Fast-forward的merge。\n\n> 有时为了时每一次merge都有记录，要禁用fast-forward,需要使用`git merge —no-ff`命令合并。\n\n### merge/rebase/cherry-pick 区别与使用场景\n\n- rebase：一般只用在本地分支上，把远程分支rebase过来。\n\n\n- merge：一般用在远程分支上，把本地分支merge到远程主干上。\n- cherry-pick：从其他分支拿(pick)一个commit到某个分支\n\n顺序，先rebase orgin 再切换到主分支 merge 过去，前向合并(fast-forward merge，分支是目标分支的祖先commit节点时，会发生Fast-forward的merge)\n\n参考这篇文章理解：http://pinkyjie.com/2014/08/10/git-notes-part-3/\n\n### reset与revert\n\n这两个都是后悔药，区别如下\n\n* reset：使用撤销commit的方式恢复，使用在本地分支的恢复上（推送之前）。\n\n\n* revert：使用添加commit的方式恢复，用在远程分支的恢复上。原因参考『场景分析』\n\n\n\n### stage与stash\n\n* stage，是暂存区，既我们git add之后存储的地方\n* stash，是一个独立的存储区域，可以存放保存的文件，\n  * `git stash`：存储\n  * `git stash apply`： 还原\n\n\n\n\n\n## 场景分析\n\n### commit多次，只保留一个commit，\n\n两种方案：\n\n* commit修改，使用git commit —amend 提交commit，会在之前一个commit的基础上修改（记录内容），不增加新的commit节点。\n* commit合并，使用git rebase 的交互模式来合并多个commit：参考：http://zerodie.github.io/blog/2012/01/19/git-rebase-i/\n\n\n### 保存某个文件，要跨分支使用它。\n\n`git stash` 命令可以满足这个需求，相当于一个存储箱。\n\n### commit错分支\n\ncherry-pick：\n一种常见的场景就是，比如我在A分支做了几次commit以后，发现其实我并不应该在A分支上工作，应该在B分支上工作，这就需要将这些commit从A分支复制到B分支去了，这时候就需要cherry-pick命令了。\n\n参考：http://pinkyjie.com/2014/08/10/git-notes-part-3/\n\n\n### 各种场景恢复的使用reset\n\n下面三种恢复的越来越多。\n\n* `git reset —soft xx`： 仅仅取消commit&&移动HEAD指针到xx，不修改工作目录和暂存区。这个模式的效果是，自从<commit>以来的所有改变都会显示在git status的**\"Changes to be committed\"**中。使用场景：取消commit，一直到某个commit（xx），但是这些修改恢复到暂存区中。\n\n* `git reset xx`：取消commit&&移动HEAD指针到xx，并且恢复暂存区，但是恢复工作目录。这个模式是默认模式，这个模式的效果是，工作目录中的文件的修改都会被保留，不会丢弃，但是也**不会**被标记成\"Changes to be committed\"。使用场景：取消commit，一直到某个commit（xx），但是这些修改恢复到工作目录中。\n\n  > 对比上一个就是少了git add 的过程\n\n* `git reset —hard xx`： 取消commit&&移动HEAD指针到xx，恢复工作目录&&暂存区。使用场景：恢复到xx commit，**丢弃从xx以来的所有修改。**\n\n\n\n### 已经推送到远程分支，但是向回退某个commit\n\n这个使用revert命令，不要使用reset\b取消commit方式恢复，而是应当使用revert添加commit的方式恢复。\n\n原因如下\n\n- 当然如果你想撤销你的修改，可以通过git reset 或 git revert ，但当你的commit已经push到远端，被别人pull了下来， 再reset push 的话，别人再pull 就会出现错误，因为这个commit 节点回退到了你本地的缓存区，不在版本系统内，会很麻烦。\n- 所以这种情况下需要使用 git revert ，**它是撤销某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交。**将需要revert的版本的内容再反向修改回去，版本会递增（添加新的commit记录），不影响之前提交的内容，别人pull的时候不会出问题，这个很重要。\n\n\n\n## 命令分析\n\n我们使用的很多命令都是省略了一下参数的，而使用了默认值，有些情况我们也要认识他们，知道含义。\n\n### git push <repository> <src>:<dst>\n\n如我们常用:\n\n* git push\n* git push origin master\n\norigin指定了你要push到哪个remote，master其实是一个“refspec”，正常的“refspec”的形式为”+<src>:<dst>”，**冒号前表示local branch的名字，冒号后表示remote repository下 branch的名字。**注意，如果你省略了<dst>，git就认为你想push到remote repository下和local branch相同名字的branch。\n\n### git fetch <repository> <src>:<dst>\n\n* git fetch == **git fetch origin master:master** == **fetch到本地master分支**\n* git fetch origin master == **git fetch origin master:** == **fetch到本地FETCH_HEAD上****\n\n与push命令类似，但是注意：**冒号前表示remote repository下 branch的名字，冒号后表示local branch的名字。**上面第一个命令是第二个命令不是fetch到本地master分支，而是FETCH_HEAD上\n\n>  参考：\n>\n>  * [如何配置默认值&&git getch 与git fetch origin master 区别](http://stackoverflow.com/questions/11892517/git-fetch-vs-git-fetch-origin-master-have-different-effects-on-tracking-branch)\n>  * [什么是FETCH_HEAD](http://stackoverflow.com/questions/9237348/what-does-fetch-head-in-git-mean)\n\n### git pull  <repository> <src>:<dst>\n\n* [git pull ==git fetch+git merge FETCH_HEAD]( https://ruby-china.org/topics/4768)\n\n* git pull origin master 从网络获取origin分支的master，合入当前分支（没指定<dst>）\n\n* git pull origin/master 本地操作，合并最后一次获取的远程master分支到当前分支（没指定<src>:<dst>）\n\n  > 参考：http://stackoverflow.com/questions/2883840/differences-between-git-pull-origin-master-git-pull-origin-master\n\n重难点理解\n\n- 理解分支开发模型\n- 理解工作目录，合理使用commit\n- 暂存区，Stash 的运用场景\n- reset 和 revert的差别\n- merge，rebase， check-pick 的差别和运用\n- [理解 master origin/master origin](http://stackoverflow.com/questions/18137175/in-git-what-is-the-difference-between-origin-master-vs-origin-master)\n\n\n\n\n\n","source":"_posts/版本控制工具git入门实践.md","raw":"title: 版本控制工具Git入门实践\ndate: 2016-06-25 09:25:19\ncategories:\n- 技术\n\ntags:\n- Tools \n---\n\n在软件开发中有一些是**通用技能**，无论从事什么项目，C、Java、前段、后台，都必须掌握的（甚至产品设计与UI设计都需要）：\n\n* 操作系统的使用：MacOs/Linux/Win\n* 版本协作工具：SVN/**Git**\n* 文本工具：Vim/SublimeText/**MarkDown**\n* IDE：Eclipse/Idea\n* 效率工具：Alfred\n\n这些技能应当优先熟练掌握，今天聊一聊版本控制工具Git。之前一直使用的是SVN，也仅仅停留在工作中使用，甚至不会使用svn命令，只能使用SVN Tortoise，也就是拉代码，解决冲突，提交代码这三个步骤，偶尔拉一下分支（甚至都没有亲自合并过分支。。）。\n\n对于Git使用，说来已久，从一开始在Github上面copy代码（clone），到背git命令，了解git flow开发模型，都是理论大于实践，以至于最近工作的代码使用了Git后，\b一脸的蒙逼。本质来说没有理解Git的核心思想。\n\n老规矩，下面是学习的一些资料，这次没有找英文的原始资料，因为这方面国内很多资料，就不折腾翻译了：\n\n* [走进git时代系列一、二、三](https://yq.aliyun.com/articles/5843?spm=5176.100239.blogcont7441.8.GnX3p9)：基本够了\n\n\n* [使用原理视角看 Git](https://segmentfault.com/a/1190000005695097)\n\n\n\n## 概念理解\n\n### 核心概念：**分支开发**\n\n这是Git中最最重要的一个概念，也是与SVN等其他工具最核心的不同。\n\n在Git的开发中，分支是一个轻量级的概念，因此新建分支，合并分支，删除分支在开发中十分常见，我们开发时应当遵循这样的基于分支的开发流程：\n\n1. 当有一个新需求、bug需要开发时，从origin/master新建一个分支,feature01/bugfix01。\n2. 切换到该分支上，开发。。修复a1，add，修复a2，add。。。\n3. 开发完成后commit（一般保持一个commit记录）\n4. git fetch origin master 从origin master更新代码(从网络更新代码到FETCH_HEAD,可以更新到master)\n5. rebase到当前分支上\n6. push\n\n\n\n### 理解远程分支与本地分支\n\n* 本质上，他们都是分支！\n\n\n* 本地分支中的默认分支`master`也是分支，它是以`origin/master分支`初始化的一个普通分支。\n\n\n* **分支本质是n个commit的list**。如果本地`master`与`origin/master`同步（不在本地master上commit，修改可以，不要提交），更新之后，那么master与origin/master就是一样的。\n\n一个新的项目clone后有哪些分支：\n\n![all branch](images/git_branch_all.png)\n\n* `master` 当前的默认分支，第一次取下来后与`origin/master `指向相同，但是后续可以在上面开发\n\n\n* `origin/master` 远程分支，内容是**最后一次从远程origin获取的所有commit**的分支，无法修改数据，本地数据，但含义是\n\n  > `remotes/origin/master`和`origin/master`的指向是相同的\n  >\n  > - `master` is a local branch\n  > - `origin/master` is a remote branch (which is a *local copy* of the branch named \"master\" on the remote named \"origin\")\n\n哪些指针：\n\n* `HEAD`\n* `FETCH_HEAD `\n* `origin/master/HEAD` 指向`origin/master`的提交，与`HEAD`区分\n\n\n### 理解本地的三个工作区\n\n#### 1. 工作目录workspace\n\n这个可以直接理解成**普通的文件夹，文件**， 这几个角度：\n\n* 工作区全局只有一个，没有多个备份，它不会保存完整的状态。\n\n* 不commit就切换分支会污染工作目录！（不commit，**且有冲突**的情况下，Git不会让你切换的，**如果没有冲突，则会合并！**）\n\n  > error: Your local changes to the following files would be overwritten by checkout:\n  >\n  > **建议：切换分支前先commit**，养成commit的习惯\n\n* 从其他分支合并，或者从网络fetch后merge（pull），都是合入工作区。因此要注意在此之前add/commit操作。\n\n  > 泛化的理解：Git的所有操作都是先针对工作区修改，因此在执行例如合并之类的操作必须要add或者commit\n\n#### 2. 暂存区 Stage/Index\n\n暂存区是Git维护的，用户手动添加，暂存区只对当前分支有效，\n\n* 工作区全局只有一个，没有多个备份，它不会保存完整的状态。\n* 因此，在切换分支时，暂存区也会被污染！具体情况与上面第二点相同（不commit，**且有冲突**的情况下，Git不会让你切换的，**如果没有冲突，则会合并！**）。\n* 与工作区不同，在从合入分支时，它不受影响，这也是暂存区的作用。\n\n#### 3. 本地仓库\n\n**分支本质是n个commit的list**。\n\n* 本地仓库中含有n个分支。包括一个默认的本地master（映射到origin/maser）和其他本地分支（可能没有映射，也可能映射到远程对于的分支）。\n\n* 切换分支时，只是指针切换，仓库内容不受影响，**只会更新工作目录（文件的删除添加）与暂存区（一般是清空，如果暂存区非空，且不冲突也会保留）**\n\n* 合并操作，会修复被合入的分支内容（某个commit的提交内容，或者commit的list）\n\n\n\n\n### 工作目录中文件的三种状态\n\n* 已提交（committed）：该文件被安全地保存在了本地数据库\n\n* 已暂存（staged）：把已修改的文件放下下次保存的清单中\n\n* 已修改（modified）：修改了某个文件，但还没有保存，此外还有从没有add过的新文件，**未追踪untracked**\n\n  参考下图学习：\n\n  ![git status](images/git_status_capture.png)\n\n几个关注点：\n\n* 红色表示在工作目录的文件，绿色表示在暂存区的文件\n* `Changes to be committed:`下的`new file`表示，暂存区与仓库对比，他们是新文件（如果有`modified`表示，暂存区与仓库对比是修改的）\n* `Changes not staged for commit:`下的`modified`表示，工作区与暂存区/仓库对比是修改的\n* `Untracked files:`下的是没有加入过暂存区的内容（在暂存区/仓库找不到对比对象）\n* 注意有两个hell3.txt，一个是工作目录的，一个是暂存区的，这说明**加入暂存区后该文件被修改过。**\n\n\n\n### HEAD\n\n`HEAD`是一个指针，指向的是**本地仓库**中**当前分支**的一个commit记录！该commit是当前正在工作的commit。\n什么时机HEAD会移动：\n\n* git checkout后指向新分支的commit（跨分支）\n* git commit后HEAD移动指向的commit（同一分支，向前）\n* merge，rebase，fast-forward\n\n注意：它指向的内容与工作目录和暂存区可能都不同，因此可以用HEAD来执行恢复操作。\n\n\n### fast-forward merge\n\n快进模式 一个常用概念，指的是谁forward呢？是**HEAD的快速向前移动**。\n\n出现的情况：\n\n* merge完成时，被合入分支的最后一个commit在待合入分支之中，移动HEAD到最后一个commit。如下图所示：\n\n  ![fast forward](images/git_fast_forward_merge.png)\n\n* rebase完成后，commit记录合入后，HEAD指针直接向前移动多个commit。\n\n总之，当前分支是master，执行`git merge branch1`。master分支最好的commit是目标分支branch1的祖先commit节点时，会发生Fast-forward的merge。\n\n> 有时为了时每一次merge都有记录，要禁用fast-forward,需要使用`git merge —no-ff`命令合并。\n\n### merge/rebase/cherry-pick 区别与使用场景\n\n- rebase：一般只用在本地分支上，把远程分支rebase过来。\n\n\n- merge：一般用在远程分支上，把本地分支merge到远程主干上。\n- cherry-pick：从其他分支拿(pick)一个commit到某个分支\n\n顺序，先rebase orgin 再切换到主分支 merge 过去，前向合并(fast-forward merge，分支是目标分支的祖先commit节点时，会发生Fast-forward的merge)\n\n参考这篇文章理解：http://pinkyjie.com/2014/08/10/git-notes-part-3/\n\n### reset与revert\n\n这两个都是后悔药，区别如下\n\n* reset：使用撤销commit的方式恢复，使用在本地分支的恢复上（推送之前）。\n\n\n* revert：使用添加commit的方式恢复，用在远程分支的恢复上。原因参考『场景分析』\n\n\n\n### stage与stash\n\n* stage，是暂存区，既我们git add之后存储的地方\n* stash，是一个独立的存储区域，可以存放保存的文件，\n  * `git stash`：存储\n  * `git stash apply`： 还原\n\n\n\n\n\n## 场景分析\n\n### commit多次，只保留一个commit，\n\n两种方案：\n\n* commit修改，使用git commit —amend 提交commit，会在之前一个commit的基础上修改（记录内容），不增加新的commit节点。\n* commit合并，使用git rebase 的交互模式来合并多个commit：参考：http://zerodie.github.io/blog/2012/01/19/git-rebase-i/\n\n\n### 保存某个文件，要跨分支使用它。\n\n`git stash` 命令可以满足这个需求，相当于一个存储箱。\n\n### commit错分支\n\ncherry-pick：\n一种常见的场景就是，比如我在A分支做了几次commit以后，发现其实我并不应该在A分支上工作，应该在B分支上工作，这就需要将这些commit从A分支复制到B分支去了，这时候就需要cherry-pick命令了。\n\n参考：http://pinkyjie.com/2014/08/10/git-notes-part-3/\n\n\n### 各种场景恢复的使用reset\n\n下面三种恢复的越来越多。\n\n* `git reset —soft xx`： 仅仅取消commit&&移动HEAD指针到xx，不修改工作目录和暂存区。这个模式的效果是，自从<commit>以来的所有改变都会显示在git status的**\"Changes to be committed\"**中。使用场景：取消commit，一直到某个commit（xx），但是这些修改恢复到暂存区中。\n\n* `git reset xx`：取消commit&&移动HEAD指针到xx，并且恢复暂存区，但是恢复工作目录。这个模式是默认模式，这个模式的效果是，工作目录中的文件的修改都会被保留，不会丢弃，但是也**不会**被标记成\"Changes to be committed\"。使用场景：取消commit，一直到某个commit（xx），但是这些修改恢复到工作目录中。\n\n  > 对比上一个就是少了git add 的过程\n\n* `git reset —hard xx`： 取消commit&&移动HEAD指针到xx，恢复工作目录&&暂存区。使用场景：恢复到xx commit，**丢弃从xx以来的所有修改。**\n\n\n\n### 已经推送到远程分支，但是向回退某个commit\n\n这个使用revert命令，不要使用reset\b取消commit方式恢复，而是应当使用revert添加commit的方式恢复。\n\n原因如下\n\n- 当然如果你想撤销你的修改，可以通过git reset 或 git revert ，但当你的commit已经push到远端，被别人pull了下来， 再reset push 的话，别人再pull 就会出现错误，因为这个commit 节点回退到了你本地的缓存区，不在版本系统内，会很麻烦。\n- 所以这种情况下需要使用 git revert ，**它是撤销某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交。**将需要revert的版本的内容再反向修改回去，版本会递增（添加新的commit记录），不影响之前提交的内容，别人pull的时候不会出问题，这个很重要。\n\n\n\n## 命令分析\n\n我们使用的很多命令都是省略了一下参数的，而使用了默认值，有些情况我们也要认识他们，知道含义。\n\n### git push <repository> <src>:<dst>\n\n如我们常用:\n\n* git push\n* git push origin master\n\norigin指定了你要push到哪个remote，master其实是一个“refspec”，正常的“refspec”的形式为”+<src>:<dst>”，**冒号前表示local branch的名字，冒号后表示remote repository下 branch的名字。**注意，如果你省略了<dst>，git就认为你想push到remote repository下和local branch相同名字的branch。\n\n### git fetch <repository> <src>:<dst>\n\n* git fetch == **git fetch origin master:master** == **fetch到本地master分支**\n* git fetch origin master == **git fetch origin master:** == **fetch到本地FETCH_HEAD上****\n\n与push命令类似，但是注意：**冒号前表示remote repository下 branch的名字，冒号后表示local branch的名字。**上面第一个命令是第二个命令不是fetch到本地master分支，而是FETCH_HEAD上\n\n>  参考：\n>\n>  * [如何配置默认值&&git getch 与git fetch origin master 区别](http://stackoverflow.com/questions/11892517/git-fetch-vs-git-fetch-origin-master-have-different-effects-on-tracking-branch)\n>  * [什么是FETCH_HEAD](http://stackoverflow.com/questions/9237348/what-does-fetch-head-in-git-mean)\n\n### git pull  <repository> <src>:<dst>\n\n* [git pull ==git fetch+git merge FETCH_HEAD]( https://ruby-china.org/topics/4768)\n\n* git pull origin master 从网络获取origin分支的master，合入当前分支（没指定<dst>）\n\n* git pull origin/master 本地操作，合并最后一次获取的远程master分支到当前分支（没指定<src>:<dst>）\n\n  > 参考：http://stackoverflow.com/questions/2883840/differences-between-git-pull-origin-master-git-pull-origin-master\n\n重难点理解\n\n- 理解分支开发模型\n- 理解工作目录，合理使用commit\n- 暂存区，Stash 的运用场景\n- reset 和 revert的差别\n- merge，rebase， check-pick 的差别和运用\n- [理解 master origin/master origin](http://stackoverflow.com/questions/18137175/in-git-what-is-the-difference-between-origin-master-vs-origin-master)\n\n\n\n\n\n","slug":"版本控制工具git入门实践","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbd8001gnac9cmdzx4cd","content":"<p>在软件开发中有一些是<strong>通用技能</strong>，无论从事什么项目，C、Java、前段、后台，都必须掌握的（甚至产品设计与UI设计都需要）：</p>\n<ul>\n<li>操作系统的使用：MacOs/Linux/Win</li>\n<li>版本协作工具：SVN/<strong>Git</strong></li>\n<li>文本工具：Vim/SublimeText/<strong>MarkDown</strong></li>\n<li>IDE：Eclipse/Idea</li>\n<li>效率工具：Alfred</li>\n</ul>\n<p>这些技能应当优先熟练掌握，今天聊一聊版本控制工具Git。之前一直使用的是SVN，也仅仅停留在工作中使用，甚至不会使用svn命令，只能使用SVN Tortoise，也就是拉代码，解决冲突，提交代码这三个步骤，偶尔拉一下分支（甚至都没有亲自合并过分支。。）。</p>\n<p>对于Git使用，说来已久，从一开始在Github上面copy代码（clone），到背git命令，了解git flow开发模型，都是理论大于实践，以至于最近工作的代码使用了Git后，\b一脸的蒙逼。本质来说没有理解Git的核心思想。</p>\n<p>老规矩，下面是学习的一些资料，这次没有找英文的原始资料，因为这方面国内很多资料，就不折腾翻译了：</p>\n<ul>\n<li><a href=\"https://yq.aliyun.com/articles/5843?spm=5176.100239.blogcont7441.8.GnX3p9\" target=\"_blank\" rel=\"external\">走进git时代系列一、二、三</a>：基本够了</li>\n</ul>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000005695097\" target=\"_blank\" rel=\"external\">使用原理视角看 Git</a></li>\n</ul>\n<h2 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h2><h3 id=\"核心概念：分支开发\"><a href=\"#核心概念：分支开发\" class=\"headerlink\" title=\"核心概念：分支开发\"></a>核心概念：<strong>分支开发</strong></h3><p>这是Git中最最重要的一个概念，也是与SVN等其他工具最核心的不同。</p>\n<p>在Git的开发中，分支是一个轻量级的概念，因此新建分支，合并分支，删除分支在开发中十分常见，我们开发时应当遵循这样的基于分支的开发流程：</p>\n<ol>\n<li>当有一个新需求、bug需要开发时，从origin/master新建一个分支,feature01/bugfix01。</li>\n<li>切换到该分支上，开发。。修复a1，add，修复a2，add。。。</li>\n<li>开发完成后commit（一般保持一个commit记录）</li>\n<li>git fetch origin master 从origin master更新代码(从网络更新代码到FETCH_HEAD,可以更新到master)</li>\n<li>rebase到当前分支上</li>\n<li>push</li>\n</ol>\n<h3 id=\"理解远程分支与本地分支\"><a href=\"#理解远程分支与本地分支\" class=\"headerlink\" title=\"理解远程分支与本地分支\"></a>理解远程分支与本地分支</h3><ul>\n<li>本质上，他们都是分支！</li>\n</ul>\n<ul>\n<li>本地分支中的默认分支<code>master</code>也是分支，它是以<code>origin/master分支</code>初始化的一个普通分支。</li>\n</ul>\n<ul>\n<li><strong>分支本质是n个commit的list</strong>。如果本地<code>master</code>与<code>origin/master</code>同步（不在本地master上commit，修改可以，不要提交），更新之后，那么master与origin/master就是一样的。</li>\n</ul>\n<p>一个新的项目clone后有哪些分支：</p>\n<p><img src=\"images/git_branch_all.png\" alt=\"all branch\"></p>\n<ul>\n<li><code>master</code> 当前的默认分支，第一次取下来后与<code>origin/master</code>指向相同，但是后续可以在上面开发</li>\n</ul>\n<ul>\n<li><p><code>origin/master</code> 远程分支，内容是<strong>最后一次从远程origin获取的所有commit</strong>的分支，无法修改数据，本地数据，但含义是</p>\n<blockquote>\n<p><code>remotes/origin/master</code>和<code>origin/master</code>的指向是相同的</p>\n<ul>\n<li><code>master</code> is a local branch</li>\n<li><code>origin/master</code> is a remote branch (which is a <em>local copy</em> of the branch named “master” on the remote named “origin”)</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>哪些指针：</p>\n<ul>\n<li><code>HEAD</code></li>\n<li><code>FETCH_HEAD</code></li>\n<li><code>origin/master/HEAD</code> 指向<code>origin/master</code>的提交，与<code>HEAD</code>区分</li>\n</ul>\n<h3 id=\"理解本地的三个工作区\"><a href=\"#理解本地的三个工作区\" class=\"headerlink\" title=\"理解本地的三个工作区\"></a>理解本地的三个工作区</h3><h4 id=\"1-工作目录workspace\"><a href=\"#1-工作目录workspace\" class=\"headerlink\" title=\"1. 工作目录workspace\"></a>1. 工作目录workspace</h4><p>这个可以直接理解成<strong>普通的文件夹，文件</strong>， 这几个角度：</p>\n<ul>\n<li><p>工作区全局只有一个，没有多个备份，它不会保存完整的状态。</p>\n</li>\n<li><p>不commit就切换分支会污染工作目录！（不commit，<strong>且有冲突</strong>的情况下，Git不会让你切换的，<strong>如果没有冲突，则会合并！</strong>）</p>\n<blockquote>\n<p>error: Your local changes to the following files would be overwritten by checkout:</p>\n<p><strong>建议：切换分支前先commit</strong>，养成commit的习惯</p>\n</blockquote>\n</li>\n<li><p>从其他分支合并，或者从网络fetch后merge（pull），都是合入工作区。因此要注意在此之前add/commit操作。</p>\n<blockquote>\n<p>泛化的理解：Git的所有操作都是先针对工作区修改，因此在执行例如合并之类的操作必须要add或者commit</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"2-暂存区-Stage-Index\"><a href=\"#2-暂存区-Stage-Index\" class=\"headerlink\" title=\"2. 暂存区 Stage/Index\"></a>2. 暂存区 Stage/Index</h4><p>暂存区是Git维护的，用户手动添加，暂存区只对当前分支有效，</p>\n<ul>\n<li>工作区全局只有一个，没有多个备份，它不会保存完整的状态。</li>\n<li>因此，在切换分支时，暂存区也会被污染！具体情况与上面第二点相同（不commit，<strong>且有冲突</strong>的情况下，Git不会让你切换的，<strong>如果没有冲突，则会合并！</strong>）。</li>\n<li>与工作区不同，在从合入分支时，它不受影响，这也是暂存区的作用。</li>\n</ul>\n<h4 id=\"3-本地仓库\"><a href=\"#3-本地仓库\" class=\"headerlink\" title=\"3. 本地仓库\"></a>3. 本地仓库</h4><p><strong>分支本质是n个commit的list</strong>。</p>\n<ul>\n<li><p>本地仓库中含有n个分支。包括一个默认的本地master（映射到origin/maser）和其他本地分支（可能没有映射，也可能映射到远程对于的分支）。</p>\n</li>\n<li><p>切换分支时，只是指针切换，仓库内容不受影响，<strong>只会更新工作目录（文件的删除添加）与暂存区（一般是清空，如果暂存区非空，且不冲突也会保留）</strong></p>\n</li>\n<li><p>合并操作，会修复被合入的分支内容（某个commit的提交内容，或者commit的list）</p>\n</li>\n</ul>\n<h3 id=\"工作目录中文件的三种状态\"><a href=\"#工作目录中文件的三种状态\" class=\"headerlink\" title=\"工作目录中文件的三种状态\"></a>工作目录中文件的三种状态</h3><ul>\n<li><p>已提交（committed）：该文件被安全地保存在了本地数据库</p>\n</li>\n<li><p>已暂存（staged）：把已修改的文件放下下次保存的清单中</p>\n</li>\n<li><p>已修改（modified）：修改了某个文件，但还没有保存，此外还有从没有add过的新文件，<strong>未追踪untracked</strong></p>\n<p>参考下图学习：</p>\n<p><img src=\"images/git_status_capture.png\" alt=\"git status\"></p>\n</li>\n</ul>\n<p>几个关注点：</p>\n<ul>\n<li>红色表示在工作目录的文件，绿色表示在暂存区的文件</li>\n<li><code>Changes to be committed:</code>下的<code>new file</code>表示，暂存区与仓库对比，他们是新文件（如果有<code>modified</code>表示，暂存区与仓库对比是修改的）</li>\n<li><code>Changes not staged for commit:</code>下的<code>modified</code>表示，工作区与暂存区/仓库对比是修改的</li>\n<li><code>Untracked files:</code>下的是没有加入过暂存区的内容（在暂存区/仓库找不到对比对象）</li>\n<li>注意有两个hell3.txt，一个是工作目录的，一个是暂存区的，这说明<strong>加入暂存区后该文件被修改过。</strong></li>\n</ul>\n<h3 id=\"HEAD\"><a href=\"#HEAD\" class=\"headerlink\" title=\"HEAD\"></a>HEAD</h3><p><code>HEAD</code>是一个指针，指向的是<strong>本地仓库</strong>中<strong>当前分支</strong>的一个commit记录！该commit是当前正在工作的commit。<br>什么时机HEAD会移动：</p>\n<ul>\n<li>git checkout后指向新分支的commit（跨分支）</li>\n<li>git commit后HEAD移动指向的commit（同一分支，向前）</li>\n<li>merge，rebase，fast-forward</li>\n</ul>\n<p>注意：它指向的内容与工作目录和暂存区可能都不同，因此可以用HEAD来执行恢复操作。</p>\n<h3 id=\"fast-forward-merge\"><a href=\"#fast-forward-merge\" class=\"headerlink\" title=\"fast-forward merge\"></a>fast-forward merge</h3><p>快进模式 一个常用概念，指的是谁forward呢？是<strong>HEAD的快速向前移动</strong>。</p>\n<p>出现的情况：</p>\n<ul>\n<li><p>merge完成时，被合入分支的最后一个commit在待合入分支之中，移动HEAD到最后一个commit。如下图所示：</p>\n<p><img src=\"images/git_fast_forward_merge.png\" alt=\"fast forward\"></p>\n</li>\n<li><p>rebase完成后，commit记录合入后，HEAD指针直接向前移动多个commit。</p>\n</li>\n</ul>\n<p>总之，当前分支是master，执行<code>git merge branch1</code>。master分支最好的commit是目标分支branch1的祖先commit节点时，会发生Fast-forward的merge。</p>\n<blockquote>\n<p>有时为了时每一次merge都有记录，要禁用fast-forward,需要使用<code>git merge —no-ff</code>命令合并。</p>\n</blockquote>\n<h3 id=\"merge-rebase-cherry-pick-区别与使用场景\"><a href=\"#merge-rebase-cherry-pick-区别与使用场景\" class=\"headerlink\" title=\"merge/rebase/cherry-pick 区别与使用场景\"></a>merge/rebase/cherry-pick 区别与使用场景</h3><ul>\n<li>rebase：一般只用在本地分支上，把远程分支rebase过来。</li>\n</ul>\n<ul>\n<li>merge：一般用在远程分支上，把本地分支merge到远程主干上。</li>\n<li>cherry-pick：从其他分支拿(pick)一个commit到某个分支</li>\n</ul>\n<p>顺序，先rebase orgin 再切换到主分支 merge 过去，前向合并(fast-forward merge，分支是目标分支的祖先commit节点时，会发生Fast-forward的merge)</p>\n<p>参考这篇文章理解：<a href=\"http://pinkyjie.com/2014/08/10/git-notes-part-3/\" target=\"_blank\" rel=\"external\">http://pinkyjie.com/2014/08/10/git-notes-part-3/</a></p>\n<h3 id=\"reset与revert\"><a href=\"#reset与revert\" class=\"headerlink\" title=\"reset与revert\"></a>reset与revert</h3><p>这两个都是后悔药，区别如下</p>\n<ul>\n<li>reset：使用撤销commit的方式恢复，使用在本地分支的恢复上（推送之前）。</li>\n</ul>\n<ul>\n<li>revert：使用添加commit的方式恢复，用在远程分支的恢复上。原因参考『场景分析』</li>\n</ul>\n<h3 id=\"stage与stash\"><a href=\"#stage与stash\" class=\"headerlink\" title=\"stage与stash\"></a>stage与stash</h3><ul>\n<li>stage，是暂存区，既我们git add之后存储的地方</li>\n<li>stash，是一个独立的存储区域，可以存放保存的文件，<ul>\n<li><code>git stash</code>：存储</li>\n<li><code>git stash apply</code>： 还原</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h2><h3 id=\"commit多次，只保留一个commit，\"><a href=\"#commit多次，只保留一个commit，\" class=\"headerlink\" title=\"commit多次，只保留一个commit，\"></a>commit多次，只保留一个commit，</h3><p>两种方案：</p>\n<ul>\n<li>commit修改，使用git commit —amend 提交commit，会在之前一个commit的基础上修改（记录内容），不增加新的commit节点。</li>\n<li>commit合并，使用git rebase 的交互模式来合并多个commit：参考：<a href=\"http://zerodie.github.io/blog/2012/01/19/git-rebase-i/\" target=\"_blank\" rel=\"external\">http://zerodie.github.io/blog/2012/01/19/git-rebase-i/</a></li>\n</ul>\n<h3 id=\"保存某个文件，要跨分支使用它。\"><a href=\"#保存某个文件，要跨分支使用它。\" class=\"headerlink\" title=\"保存某个文件，要跨分支使用它。\"></a>保存某个文件，要跨分支使用它。</h3><p><code>git stash</code> 命令可以满足这个需求，相当于一个存储箱。</p>\n<h3 id=\"commit错分支\"><a href=\"#commit错分支\" class=\"headerlink\" title=\"commit错分支\"></a>commit错分支</h3><p>cherry-pick：<br>一种常见的场景就是，比如我在A分支做了几次commit以后，发现其实我并不应该在A分支上工作，应该在B分支上工作，这就需要将这些commit从A分支复制到B分支去了，这时候就需要cherry-pick命令了。</p>\n<p>参考：<a href=\"http://pinkyjie.com/2014/08/10/git-notes-part-3/\" target=\"_blank\" rel=\"external\">http://pinkyjie.com/2014/08/10/git-notes-part-3/</a></p>\n<h3 id=\"各种场景恢复的使用reset\"><a href=\"#各种场景恢复的使用reset\" class=\"headerlink\" title=\"各种场景恢复的使用reset\"></a>各种场景恢复的使用reset</h3><p>下面三种恢复的越来越多。</p>\n<ul>\n<li><p><code>git reset —soft xx</code>： 仅仅取消commit&amp;&amp;移动HEAD指针到xx，不修改工作目录和暂存区。这个模式的效果是，自从<commit>以来的所有改变都会显示在git status的<strong>“Changes to be committed”</strong>中。使用场景：取消commit，一直到某个commit（xx），但是这些修改恢复到暂存区中。</commit></p>\n</li>\n<li><p><code>git reset xx</code>：取消commit&amp;&amp;移动HEAD指针到xx，并且恢复暂存区，但是恢复工作目录。这个模式是默认模式，这个模式的效果是，工作目录中的文件的修改都会被保留，不会丢弃，但是也<strong>不会</strong>被标记成”Changes to be committed”。使用场景：取消commit，一直到某个commit（xx），但是这些修改恢复到工作目录中。</p>\n<blockquote>\n<p>对比上一个就是少了git add 的过程</p>\n</blockquote>\n</li>\n<li><p><code>git reset —hard xx</code>： 取消commit&amp;&amp;移动HEAD指针到xx，恢复工作目录&amp;&amp;暂存区。使用场景：恢复到xx commit，<strong>丢弃从xx以来的所有修改。</strong></p>\n</li>\n</ul>\n<h3 id=\"已经推送到远程分支，但是向回退某个commit\"><a href=\"#已经推送到远程分支，但是向回退某个commit\" class=\"headerlink\" title=\"已经推送到远程分支，但是向回退某个commit\"></a>已经推送到远程分支，但是向回退某个commit</h3><p>这个使用revert命令，不要使用reset\b取消commit方式恢复，而是应当使用revert添加commit的方式恢复。</p>\n<p>原因如下</p>\n<ul>\n<li>当然如果你想撤销你的修改，可以通过git reset 或 git revert ，但当你的commit已经push到远端，被别人pull了下来， 再reset push 的话，别人再pull 就会出现错误，因为这个commit 节点回退到了你本地的缓存区，不在版本系统内，会很麻烦。</li>\n<li>所以这种情况下需要使用 git revert ，<strong>它是撤销某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交。</strong>将需要revert的版本的内容再反向修改回去，版本会递增（添加新的commit记录），不影响之前提交的内容，别人pull的时候不会出问题，这个很重要。</li>\n</ul>\n<h2 id=\"命令分析\"><a href=\"#命令分析\" class=\"headerlink\" title=\"命令分析\"></a>命令分析</h2><p>我们使用的很多命令都是省略了一下参数的，而使用了默认值，有些情况我们也要认识他们，知道含义。</p>\n<h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push  :\"></a>git push <repository> <src>:<dst></dst></src></repository></h3><p>如我们常用:</p>\n<ul>\n<li>git push</li>\n<li>git push origin master</li>\n</ul>\n<p>origin指定了你要push到哪个remote，master其实是一个“refspec”，正常的“refspec”的形式为”+<src>:<dst>”，<strong>冒号前表示local branch的名字，冒号后表示remote repository下 branch的名字。</strong>注意，如果你省略了<dst>，git就认为你想push到remote repository下和local branch相同名字的branch。</dst></dst></src></p>\n<h3 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch  :\"></a>git fetch <repository> <src>:<dst></dst></src></repository></h3><ul>\n<li>git fetch == <strong>git fetch origin master:master</strong> == <strong>fetch到本地master分支</strong></li>\n<li>git fetch origin master == <strong>git fetch origin master:</strong> == <strong>fetch到本地FETCH_HEAD上**</strong></li>\n</ul>\n<p>与push命令类似，但是注意：<strong>冒号前表示remote repository下 branch的名字，冒号后表示local branch的名字。</strong>上面第一个命令是第二个命令不是fetch到本地master分支，而是FETCH_HEAD上</p>\n<blockquote>\n<p> 参考：</p>\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/11892517/git-fetch-vs-git-fetch-origin-master-have-different-effects-on-tracking-branch\" target=\"_blank\" rel=\"external\">如何配置默认值&amp;&amp;git getch 与git fetch origin master 区别</a></li>\n<li><a href=\"http://stackoverflow.com/questions/9237348/what-does-fetch-head-in-git-mean\" target=\"_blank\" rel=\"external\">什么是FETCH_HEAD</a></li>\n</ul>\n</blockquote>\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull   :\"></a>git pull  <repository> <src>:<dst></dst></src></repository></h3><ul>\n<li><p><a href=\"https://ruby-china.org/topics/4768\" target=\"_blank\" rel=\"external\">git pull ==git fetch+git merge FETCH_HEAD</a></p>\n</li>\n<li><p>git pull origin master 从网络获取origin分支的master，合入当前分支（没指定<dst>）</dst></p>\n</li>\n<li><p>git pull origin/master 本地操作，合并最后一次获取的远程master分支到当前分支（没指定<src>:<dst>）</dst></src></p>\n<blockquote>\n<p>参考：<a href=\"http://stackoverflow.com/questions/2883840/differences-between-git-pull-origin-master-git-pull-origin-master\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/2883840/differences-between-git-pull-origin-master-git-pull-origin-master</a></p>\n</blockquote>\n</li>\n</ul>\n<p>重难点理解</p>\n<ul>\n<li>理解分支开发模型</li>\n<li>理解工作目录，合理使用commit</li>\n<li>暂存区，Stash 的运用场景</li>\n<li>reset 和 revert的差别</li>\n<li>merge，rebase， check-pick 的差别和运用</li>\n<li><a href=\"http://stackoverflow.com/questions/18137175/in-git-what-is-the-difference-between-origin-master-vs-origin-master\" target=\"_blank\" rel=\"external\">理解 master origin/master origin</a></li>\n</ul>\n","excerpt":"","more":"<p>在软件开发中有一些是<strong>通用技能</strong>，无论从事什么项目，C、Java、前段、后台，都必须掌握的（甚至产品设计与UI设计都需要）：</p>\n<ul>\n<li>操作系统的使用：MacOs/Linux/Win</li>\n<li>版本协作工具：SVN/<strong>Git</strong></li>\n<li>文本工具：Vim/SublimeText/<strong>MarkDown</strong></li>\n<li>IDE：Eclipse/Idea</li>\n<li>效率工具：Alfred</li>\n</ul>\n<p>这些技能应当优先熟练掌握，今天聊一聊版本控制工具Git。之前一直使用的是SVN，也仅仅停留在工作中使用，甚至不会使用svn命令，只能使用SVN Tortoise，也就是拉代码，解决冲突，提交代码这三个步骤，偶尔拉一下分支（甚至都没有亲自合并过分支。。）。</p>\n<p>对于Git使用，说来已久，从一开始在Github上面copy代码（clone），到背git命令，了解git flow开发模型，都是理论大于实践，以至于最近工作的代码使用了Git后，\b一脸的蒙逼。本质来说没有理解Git的核心思想。</p>\n<p>老规矩，下面是学习的一些资料，这次没有找英文的原始资料，因为这方面国内很多资料，就不折腾翻译了：</p>\n<ul>\n<li><a href=\"https://yq.aliyun.com/articles/5843?spm=5176.100239.blogcont7441.8.GnX3p9\">走进git时代系列一、二、三</a>：基本够了</li>\n</ul>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000005695097\">使用原理视角看 Git</a></li>\n</ul>\n<h2 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h2><h3 id=\"核心概念：分支开发\"><a href=\"#核心概念：分支开发\" class=\"headerlink\" title=\"核心概念：分支开发\"></a>核心概念：<strong>分支开发</strong></h3><p>这是Git中最最重要的一个概念，也是与SVN等其他工具最核心的不同。</p>\n<p>在Git的开发中，分支是一个轻量级的概念，因此新建分支，合并分支，删除分支在开发中十分常见，我们开发时应当遵循这样的基于分支的开发流程：</p>\n<ol>\n<li>当有一个新需求、bug需要开发时，从origin/master新建一个分支,feature01/bugfix01。</li>\n<li>切换到该分支上，开发。。修复a1，add，修复a2，add。。。</li>\n<li>开发完成后commit（一般保持一个commit记录）</li>\n<li>git fetch origin master 从origin master更新代码(从网络更新代码到FETCH_HEAD,可以更新到master)</li>\n<li>rebase到当前分支上</li>\n<li>push</li>\n</ol>\n<h3 id=\"理解远程分支与本地分支\"><a href=\"#理解远程分支与本地分支\" class=\"headerlink\" title=\"理解远程分支与本地分支\"></a>理解远程分支与本地分支</h3><ul>\n<li>本质上，他们都是分支！</li>\n</ul>\n<ul>\n<li>本地分支中的默认分支<code>master</code>也是分支，它是以<code>origin/master分支</code>初始化的一个普通分支。</li>\n</ul>\n<ul>\n<li><strong>分支本质是n个commit的list</strong>。如果本地<code>master</code>与<code>origin/master</code>同步（不在本地master上commit，修改可以，不要提交），更新之后，那么master与origin/master就是一样的。</li>\n</ul>\n<p>一个新的项目clone后有哪些分支：</p>\n<p><img src=\"images/git_branch_all.png\" alt=\"all branch\"></p>\n<ul>\n<li><code>master</code> 当前的默认分支，第一次取下来后与<code>origin/master</code>指向相同，但是后续可以在上面开发</li>\n</ul>\n<ul>\n<li><p><code>origin/master</code> 远程分支，内容是<strong>最后一次从远程origin获取的所有commit</strong>的分支，无法修改数据，本地数据，但含义是</p>\n<blockquote>\n<p><code>remotes/origin/master</code>和<code>origin/master</code>的指向是相同的</p>\n<ul>\n<li><code>master</code> is a local branch</li>\n<li><code>origin/master</code> is a remote branch (which is a <em>local copy</em> of the branch named “master” on the remote named “origin”)</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>哪些指针：</p>\n<ul>\n<li><code>HEAD</code></li>\n<li><code>FETCH_HEAD</code></li>\n<li><code>origin/master/HEAD</code> 指向<code>origin/master</code>的提交，与<code>HEAD</code>区分</li>\n</ul>\n<h3 id=\"理解本地的三个工作区\"><a href=\"#理解本地的三个工作区\" class=\"headerlink\" title=\"理解本地的三个工作区\"></a>理解本地的三个工作区</h3><h4 id=\"1-工作目录workspace\"><a href=\"#1-工作目录workspace\" class=\"headerlink\" title=\"1. 工作目录workspace\"></a>1. 工作目录workspace</h4><p>这个可以直接理解成<strong>普通的文件夹，文件</strong>， 这几个角度：</p>\n<ul>\n<li><p>工作区全局只有一个，没有多个备份，它不会保存完整的状态。</p>\n</li>\n<li><p>不commit就切换分支会污染工作目录！（不commit，<strong>且有冲突</strong>的情况下，Git不会让你切换的，<strong>如果没有冲突，则会合并！</strong>）</p>\n<blockquote>\n<p>error: Your local changes to the following files would be overwritten by checkout:</p>\n<p><strong>建议：切换分支前先commit</strong>，养成commit的习惯</p>\n</blockquote>\n</li>\n<li><p>从其他分支合并，或者从网络fetch后merge（pull），都是合入工作区。因此要注意在此之前add/commit操作。</p>\n<blockquote>\n<p>泛化的理解：Git的所有操作都是先针对工作区修改，因此在执行例如合并之类的操作必须要add或者commit</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"2-暂存区-Stage-Index\"><a href=\"#2-暂存区-Stage-Index\" class=\"headerlink\" title=\"2. 暂存区 Stage/Index\"></a>2. 暂存区 Stage/Index</h4><p>暂存区是Git维护的，用户手动添加，暂存区只对当前分支有效，</p>\n<ul>\n<li>工作区全局只有一个，没有多个备份，它不会保存完整的状态。</li>\n<li>因此，在切换分支时，暂存区也会被污染！具体情况与上面第二点相同（不commit，<strong>且有冲突</strong>的情况下，Git不会让你切换的，<strong>如果没有冲突，则会合并！</strong>）。</li>\n<li>与工作区不同，在从合入分支时，它不受影响，这也是暂存区的作用。</li>\n</ul>\n<h4 id=\"3-本地仓库\"><a href=\"#3-本地仓库\" class=\"headerlink\" title=\"3. 本地仓库\"></a>3. 本地仓库</h4><p><strong>分支本质是n个commit的list</strong>。</p>\n<ul>\n<li><p>本地仓库中含有n个分支。包括一个默认的本地master（映射到origin/maser）和其他本地分支（可能没有映射，也可能映射到远程对于的分支）。</p>\n</li>\n<li><p>切换分支时，只是指针切换，仓库内容不受影响，<strong>只会更新工作目录（文件的删除添加）与暂存区（一般是清空，如果暂存区非空，且不冲突也会保留）</strong></p>\n</li>\n<li><p>合并操作，会修复被合入的分支内容（某个commit的提交内容，或者commit的list）</p>\n</li>\n</ul>\n<h3 id=\"工作目录中文件的三种状态\"><a href=\"#工作目录中文件的三种状态\" class=\"headerlink\" title=\"工作目录中文件的三种状态\"></a>工作目录中文件的三种状态</h3><ul>\n<li><p>已提交（committed）：该文件被安全地保存在了本地数据库</p>\n</li>\n<li><p>已暂存（staged）：把已修改的文件放下下次保存的清单中</p>\n</li>\n<li><p>已修改（modified）：修改了某个文件，但还没有保存，此外还有从没有add过的新文件，<strong>未追踪untracked</strong></p>\n<p>参考下图学习：</p>\n<p><img src=\"images/git_status_capture.png\" alt=\"git status\"></p>\n</li>\n</ul>\n<p>几个关注点：</p>\n<ul>\n<li>红色表示在工作目录的文件，绿色表示在暂存区的文件</li>\n<li><code>Changes to be committed:</code>下的<code>new file</code>表示，暂存区与仓库对比，他们是新文件（如果有<code>modified</code>表示，暂存区与仓库对比是修改的）</li>\n<li><code>Changes not staged for commit:</code>下的<code>modified</code>表示，工作区与暂存区/仓库对比是修改的</li>\n<li><code>Untracked files:</code>下的是没有加入过暂存区的内容（在暂存区/仓库找不到对比对象）</li>\n<li>注意有两个hell3.txt，一个是工作目录的，一个是暂存区的，这说明<strong>加入暂存区后该文件被修改过。</strong></li>\n</ul>\n<h3 id=\"HEAD\"><a href=\"#HEAD\" class=\"headerlink\" title=\"HEAD\"></a>HEAD</h3><p><code>HEAD</code>是一个指针，指向的是<strong>本地仓库</strong>中<strong>当前分支</strong>的一个commit记录！该commit是当前正在工作的commit。<br>什么时机HEAD会移动：</p>\n<ul>\n<li>git checkout后指向新分支的commit（跨分支）</li>\n<li>git commit后HEAD移动指向的commit（同一分支，向前）</li>\n<li>merge，rebase，fast-forward</li>\n</ul>\n<p>注意：它指向的内容与工作目录和暂存区可能都不同，因此可以用HEAD来执行恢复操作。</p>\n<h3 id=\"fast-forward-merge\"><a href=\"#fast-forward-merge\" class=\"headerlink\" title=\"fast-forward merge\"></a>fast-forward merge</h3><p>快进模式 一个常用概念，指的是谁forward呢？是<strong>HEAD的快速向前移动</strong>。</p>\n<p>出现的情况：</p>\n<ul>\n<li><p>merge完成时，被合入分支的最后一个commit在待合入分支之中，移动HEAD到最后一个commit。如下图所示：</p>\n<p><img src=\"images/git_fast_forward_merge.png\" alt=\"fast forward\"></p>\n</li>\n<li><p>rebase完成后，commit记录合入后，HEAD指针直接向前移动多个commit。</p>\n</li>\n</ul>\n<p>总之，当前分支是master，执行<code>git merge branch1</code>。master分支最好的commit是目标分支branch1的祖先commit节点时，会发生Fast-forward的merge。</p>\n<blockquote>\n<p>有时为了时每一次merge都有记录，要禁用fast-forward,需要使用<code>git merge —no-ff</code>命令合并。</p>\n</blockquote>\n<h3 id=\"merge-rebase-cherry-pick-区别与使用场景\"><a href=\"#merge-rebase-cherry-pick-区别与使用场景\" class=\"headerlink\" title=\"merge/rebase/cherry-pick 区别与使用场景\"></a>merge/rebase/cherry-pick 区别与使用场景</h3><ul>\n<li>rebase：一般只用在本地分支上，把远程分支rebase过来。</li>\n</ul>\n<ul>\n<li>merge：一般用在远程分支上，把本地分支merge到远程主干上。</li>\n<li>cherry-pick：从其他分支拿(pick)一个commit到某个分支</li>\n</ul>\n<p>顺序，先rebase orgin 再切换到主分支 merge 过去，前向合并(fast-forward merge，分支是目标分支的祖先commit节点时，会发生Fast-forward的merge)</p>\n<p>参考这篇文章理解：<a href=\"http://pinkyjie.com/2014/08/10/git-notes-part-3/\">http://pinkyjie.com/2014/08/10/git-notes-part-3/</a></p>\n<h3 id=\"reset与revert\"><a href=\"#reset与revert\" class=\"headerlink\" title=\"reset与revert\"></a>reset与revert</h3><p>这两个都是后悔药，区别如下</p>\n<ul>\n<li>reset：使用撤销commit的方式恢复，使用在本地分支的恢复上（推送之前）。</li>\n</ul>\n<ul>\n<li>revert：使用添加commit的方式恢复，用在远程分支的恢复上。原因参考『场景分析』</li>\n</ul>\n<h3 id=\"stage与stash\"><a href=\"#stage与stash\" class=\"headerlink\" title=\"stage与stash\"></a>stage与stash</h3><ul>\n<li>stage，是暂存区，既我们git add之后存储的地方</li>\n<li>stash，是一个独立的存储区域，可以存放保存的文件，<ul>\n<li><code>git stash</code>：存储</li>\n<li><code>git stash apply</code>： 还原</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h2><h3 id=\"commit多次，只保留一个commit，\"><a href=\"#commit多次，只保留一个commit，\" class=\"headerlink\" title=\"commit多次，只保留一个commit，\"></a>commit多次，只保留一个commit，</h3><p>两种方案：</p>\n<ul>\n<li>commit修改，使用git commit —amend 提交commit，会在之前一个commit的基础上修改（记录内容），不增加新的commit节点。</li>\n<li>commit合并，使用git rebase 的交互模式来合并多个commit：参考：<a href=\"http://zerodie.github.io/blog/2012/01/19/git-rebase-i/\">http://zerodie.github.io/blog/2012/01/19/git-rebase-i/</a></li>\n</ul>\n<h3 id=\"保存某个文件，要跨分支使用它。\"><a href=\"#保存某个文件，要跨分支使用它。\" class=\"headerlink\" title=\"保存某个文件，要跨分支使用它。\"></a>保存某个文件，要跨分支使用它。</h3><p><code>git stash</code> 命令可以满足这个需求，相当于一个存储箱。</p>\n<h3 id=\"commit错分支\"><a href=\"#commit错分支\" class=\"headerlink\" title=\"commit错分支\"></a>commit错分支</h3><p>cherry-pick：<br>一种常见的场景就是，比如我在A分支做了几次commit以后，发现其实我并不应该在A分支上工作，应该在B分支上工作，这就需要将这些commit从A分支复制到B分支去了，这时候就需要cherry-pick命令了。</p>\n<p>参考：<a href=\"http://pinkyjie.com/2014/08/10/git-notes-part-3/\">http://pinkyjie.com/2014/08/10/git-notes-part-3/</a></p>\n<h3 id=\"各种场景恢复的使用reset\"><a href=\"#各种场景恢复的使用reset\" class=\"headerlink\" title=\"各种场景恢复的使用reset\"></a>各种场景恢复的使用reset</h3><p>下面三种恢复的越来越多。</p>\n<ul>\n<li><p><code>git reset —soft xx</code>： 仅仅取消commit&amp;&amp;移动HEAD指针到xx，不修改工作目录和暂存区。这个模式的效果是，自从<commit>以来的所有改变都会显示在git status的<strong>“Changes to be committed”</strong>中。使用场景：取消commit，一直到某个commit（xx），但是这些修改恢复到暂存区中。</p>\n</li>\n<li><p><code>git reset xx</code>：取消commit&amp;&amp;移动HEAD指针到xx，并且恢复暂存区，但是恢复工作目录。这个模式是默认模式，这个模式的效果是，工作目录中的文件的修改都会被保留，不会丢弃，但是也<strong>不会</strong>被标记成”Changes to be committed”。使用场景：取消commit，一直到某个commit（xx），但是这些修改恢复到工作目录中。</p>\n<blockquote>\n<p>对比上一个就是少了git add 的过程</p>\n</blockquote>\n</li>\n<li><p><code>git reset —hard xx</code>： 取消commit&amp;&amp;移动HEAD指针到xx，恢复工作目录&amp;&amp;暂存区。使用场景：恢复到xx commit，<strong>丢弃从xx以来的所有修改。</strong></p>\n</li>\n</ul>\n<h3 id=\"已经推送到远程分支，但是向回退某个commit\"><a href=\"#已经推送到远程分支，但是向回退某个commit\" class=\"headerlink\" title=\"已经推送到远程分支，但是向回退某个commit\"></a>已经推送到远程分支，但是向回退某个commit</h3><p>这个使用revert命令，不要使用reset\b取消commit方式恢复，而是应当使用revert添加commit的方式恢复。</p>\n<p>原因如下</p>\n<ul>\n<li>当然如果你想撤销你的修改，可以通过git reset 或 git revert ，但当你的commit已经push到远端，被别人pull了下来， 再reset push 的话，别人再pull 就会出现错误，因为这个commit 节点回退到了你本地的缓存区，不在版本系统内，会很麻烦。</li>\n<li>所以这种情况下需要使用 git revert ，<strong>它是撤销某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交。</strong>将需要revert的版本的内容再反向修改回去，版本会递增（添加新的commit记录），不影响之前提交的内容，别人pull的时候不会出问题，这个很重要。</li>\n</ul>\n<h2 id=\"命令分析\"><a href=\"#命令分析\" class=\"headerlink\" title=\"命令分析\"></a>命令分析</h2><p>我们使用的很多命令都是省略了一下参数的，而使用了默认值，有些情况我们也要认识他们，知道含义。</p>\n<h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push  :\"></a>git push <repository> <src>:<dst></h3><p>如我们常用:</p>\n<ul>\n<li>git push</li>\n<li>git push origin master</li>\n</ul>\n<p>origin指定了你要push到哪个remote，master其实是一个“refspec”，正常的“refspec”的形式为”+<src>:<dst>”，<strong>冒号前表示local branch的名字，冒号后表示remote repository下 branch的名字。</strong>注意，如果你省略了<dst>，git就认为你想push到remote repository下和local branch相同名字的branch。</p>\n<h3 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch  :\"></a>git fetch <repository> <src>:<dst></h3><ul>\n<li>git fetch == <strong>git fetch origin master:master</strong> == <strong>fetch到本地master分支</strong></li>\n<li>git fetch origin master == <strong>git fetch origin master:</strong> == <strong>fetch到本地FETCH_HEAD上**</strong></li>\n</ul>\n<p>与push命令类似，但是注意：<strong>冒号前表示remote repository下 branch的名字，冒号后表示local branch的名字。</strong>上面第一个命令是第二个命令不是fetch到本地master分支，而是FETCH_HEAD上</p>\n<blockquote>\n<p> 参考：</p>\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/11892517/git-fetch-vs-git-fetch-origin-master-have-different-effects-on-tracking-branch\">如何配置默认值&amp;&amp;git getch 与git fetch origin master 区别</a></li>\n<li><a href=\"http://stackoverflow.com/questions/9237348/what-does-fetch-head-in-git-mean\">什么是FETCH_HEAD</a></li>\n</ul>\n</blockquote>\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull   :\"></a>git pull  <repository> <src>:<dst></h3><ul>\n<li><p><a href=\"https://ruby-china.org/topics/4768\">git pull ==git fetch+git merge FETCH_HEAD</a></p>\n</li>\n<li><p>git pull origin master 从网络获取origin分支的master，合入当前分支（没指定<dst>）</p>\n</li>\n<li><p>git pull origin/master 本地操作，合并最后一次获取的远程master分支到当前分支（没指定<src>:<dst>）</p>\n<blockquote>\n<p>参考：<a href=\"http://stackoverflow.com/questions/2883840/differences-between-git-pull-origin-master-git-pull-origin-master\">http://stackoverflow.com/questions/2883840/differences-between-git-pull-origin-master-git-pull-origin-master</a></p>\n</blockquote>\n</li>\n</ul>\n<p>重难点理解</p>\n<ul>\n<li>理解分支开发模型</li>\n<li>理解工作目录，合理使用commit</li>\n<li>暂存区，Stash 的运用场景</li>\n<li>reset 和 revert的差别</li>\n<li>merge，rebase， check-pick 的差别和运用</li>\n<li><a href=\"http://stackoverflow.com/questions/18137175/in-git-what-is-the-difference-between-origin-master-vs-origin-master\">理解 master origin/master origin</a></li>\n</ul>\n"},{"title":"理财：量化分析平台，一个定投策略的实现","date":"2016-03-20T09:27:13.000Z","_content":"\n不得不说理财是一项基本的能力，从工作开始有意识地买了很多理财产品，股票，基金，p2p。仅仅基金就买过股票型，指数型，还有比较复杂的分级基金A/B。之前的购买大部分是尝试性的，漫无目的，更没有任何仔细的思量。似乎这叫做**赌博**更加合适。\n经过这一年的尝试，渐渐确定了我的理财目标。几个原则：\n\n* 作为非专业人员，不会花大量时间在这上面，如股票看盘\n* 为自己风险可以偏大，为父母，风险可控。基本公式：\n\n\t> 理财资产（非固定收益类）/总资产=100-年龄\n> 在此基础上微调：\n> \n> * 自己:比例 > 75% --> 85%左右,40%回撤\n> * 父母:比例 < 45% --> 40%，18%回撤\n\n* 不投资不了解的产品，**必须经过数据计算**后投资\n\n目标：\n\n* 追求 > 10%的年化收益，目标为15%\n\n这篇文章讲讲最近了解的金融数据的**回测**平台。简单来说就是指定策略然后使用历史数据技术模拟投资，查看结果。\n\n## 国内的量化平台\n基本了解了一下国内的策略平台功能比较弱，但是由于数据原因也没有其他好的选择。基本是两个平台\n\n* UQER-优矿\n* 聚宽\n\n这两个平台十分相似，我怀疑是互相抄袭的，或者抄的国外的某平台，可是。。。。他们的数据也不全，很多数据只有2013年以后。\n\n## 使用\n这没什么可说的，其实就是Python语法+常用的数据处理lib+平台API，\n对我而言，python使用的比较少，基本语法没有问题，但是一些输出处理的库就是否生疏了，比如numpy，spicy，panda等，这些库大大的方便我们进行数据运算和整合：\n\n### 分析常用的lib\n* [numpy](https://uqer.io/community/share/54ca15f9f9f06c276f651a56):主要提供了array数据结构(多纬度)，与元组/列表最大的区别是，它约束数组内的数据类型要相同，一些细微的操作也不通\n\n\t```py\n[4]*4 -->  [4,4,4,4]\nnp.array([4])*4 --> array([16])\n```\n* [spicy](https://uqer.io/community/share/54d83bb3f9f06c276f651a6e)：向量和矩阵的相关操作，基本上算是一个高级的科学计算器,如计算逆矩阵，特征值等等功能,与线性代数相关。\n* [panda](https://uqer.io/community/share/54ffd96ef9f06c276f651aac):金融计算的高级库，提供了Series和DataFrame两种高级的数据结果，前者理解成列，后者理解成表（一个表是由n个列组成的）。\n* 高级的有：机器学习算法库等，这就不懂了\n* 其他的自定义绘图库matplotlib等\n\n### 基本功能\n这两个平台都基于**ipython**提供了两种基本的功能：code和strategy。\n> jupyter与ipython：这个东西很有用，jupyter是一个网页交互器，对于脚本语言可以即可写，即可得到结果。ipython是一个接口可以让jupyter支持python的编译执行，可以缓存其他的语言如ruby。这个东西是学习python这些语言的强力助手，提供自动不全的公共，适合边学习边实验。\n\n简单地说：\n\n* code：纯洁的python运行环境，可以调用各种api，包括python自己的lib和金融平台提供的api。一个常见的流程是：使用平台api获取数据-->用python的数据处理工具处理-->写一下模板方法和变量（具体逻辑）-->import平台提供的回测库，调用回测api（需要把刚才写的模板方法和变量作为参数传入）-->拿到结果，用python的数据处理工具处理-->用python的绘图工具如matplotlib画出结果。优点是自由度高，缺点，必须要自己各种处理数据画图。\n\n\t```py\nbt, acct = quartz.backtest(start = start,end = end,\\\n             benchmark = benchmark,\\\n             universe = universe,\\\n             capital_base = capital_base,\\\n             initialize = initialize,\\\n             handle_data = handle_data,\\\n             refresh_rate = refresh_rate)\n# 下面绘图\n```\n* strategy：一个模板化的python环境，实现一下模板的方法和变量（与上面类似）：如在handle_data中判断然后下单，但是你不需要手动应用回测库开始回测，点击运行自动调研模板方法，绘制出图。\n\n\t```py\nstart = '2014-01-01'                       # 回测起始时间\nend = '2015-01-01'                         # 回测结束时间\nbenchmark = 'HS300'                        # 策略参考标准\nuniverse = ['000001.XSHE', '600000.XSHG']  # 证券池，支持股票和基金\ncapital_base = 100000                      # 起始资金\nfreq = 'd'                                 # 策略类型，'d'表示日间策略使用日线回测，'m'表示日内策略使用分钟线回测\nrefresh_rate = 1                           # 调仓频率，表示执行handle_data的时间间隔，若freq = 'd'时间间隔的单位为交易日，若freq = 'm'时间间隔为分钟\ndef initialize(account):                   # 初始化虚拟账户状态\n    pass\ndef handle_data(account):                  # 每个交易日的买入卖出指令\n    return\n```\n\n核心的概念，就是在某个时机下单。\n时机：\n\n* 日间策略 -- 函数每个交易日调用一次，注意，此时下单价格是开盘价格（优矿），框架一般认为必然**成功**\n* 分钟策略 -- 每一分钟调用一次，以市价（当前价格）/限价（限定某个）来下单，**未必能买的到**\n\n下单：\n\n* order(stk,100) 以当前价格买100股\n* order_to(stk,100) 以当前价格买/卖，最后剩余100股\n* 其他，按比例什么的，有些平台可以用价格去下单，如买1000块的股票。（内部应该也处理了取整）\n\n### 一些坑\n优矿平台：\n\n* handle_data里下了单，但是账户信息不会离开变化（比如余额，持股），要下次调用handle_data的时候才变，注意理解！但是其他平台未必。\n* account.universe中的股票的顺序个数都可能被修改！不是你传入的，他会过滤去重排序。\n* 无法增加cash，记追加投资，就是**不好实现定投**（用策略不行，用code可以自己来）\n* 只支持：股票，场内etf基金，一些场内债券，其他的如分级基金、普通的开放式基金都不支持。\n* secID和ticker证券代码：前者是内部id，因为同一个证券号码可能有多个对应的东西\n* 下单失败努力找原因。。比如，cash太少买不了一手\n\n聚宽：\n数据太少，比如etf，只有2014年12月的。。\n优点是api比优矿完善的多！\n\n## 实践\n我使用code模式，实现了**按月定投**逻辑和**定期按比例重新分配**资产。[这里下载](./codes/定投分析.py)。这里面用到一个很有用的库dateutil，可以方便的[产生时间序列](http://www.andyvenet.com/using-dateutil-generate-recurring-dates/)，比如每个月的最后一天，每年第几天等\n分析结果用图表的形式表现出来：\n![分析结果](./images/financial_quant_analyse.jpg)\n\n## 总结\n这些只是入门的内容，还有很多数据层面的东西要学习以及金融知识，比如那些指标是什么含义。今年有计划看一本金融类的入门书籍。理财是一个长期需要坚持的事情，从简单的策略做起，不断学习，优化，认识到不足，再优化。期望能脱离盲目，我相信，**所谓坚持不懈，毫不动摇必须要有强大的学识基础。**","source":"_posts/理财：量化分析平台，一个定投策略的实现.md","raw":"title: 理财：量化分析平台，一个定投策略的实现\ndate: 2016-03-20 17:27:13\ncategories:\n- 杂谈\ntags:\n- 理财\n---\n\n不得不说理财是一项基本的能力，从工作开始有意识地买了很多理财产品，股票，基金，p2p。仅仅基金就买过股票型，指数型，还有比较复杂的分级基金A/B。之前的购买大部分是尝试性的，漫无目的，更没有任何仔细的思量。似乎这叫做**赌博**更加合适。\n经过这一年的尝试，渐渐确定了我的理财目标。几个原则：\n\n* 作为非专业人员，不会花大量时间在这上面，如股票看盘\n* 为自己风险可以偏大，为父母，风险可控。基本公式：\n\n\t> 理财资产（非固定收益类）/总资产=100-年龄\n> 在此基础上微调：\n> \n> * 自己:比例 > 75% --> 85%左右,40%回撤\n> * 父母:比例 < 45% --> 40%，18%回撤\n\n* 不投资不了解的产品，**必须经过数据计算**后投资\n\n目标：\n\n* 追求 > 10%的年化收益，目标为15%\n\n这篇文章讲讲最近了解的金融数据的**回测**平台。简单来说就是指定策略然后使用历史数据技术模拟投资，查看结果。\n\n## 国内的量化平台\n基本了解了一下国内的策略平台功能比较弱，但是由于数据原因也没有其他好的选择。基本是两个平台\n\n* UQER-优矿\n* 聚宽\n\n这两个平台十分相似，我怀疑是互相抄袭的，或者抄的国外的某平台，可是。。。。他们的数据也不全，很多数据只有2013年以后。\n\n## 使用\n这没什么可说的，其实就是Python语法+常用的数据处理lib+平台API，\n对我而言，python使用的比较少，基本语法没有问题，但是一些输出处理的库就是否生疏了，比如numpy，spicy，panda等，这些库大大的方便我们进行数据运算和整合：\n\n### 分析常用的lib\n* [numpy](https://uqer.io/community/share/54ca15f9f9f06c276f651a56):主要提供了array数据结构(多纬度)，与元组/列表最大的区别是，它约束数组内的数据类型要相同，一些细微的操作也不通\n\n\t```py\n[4]*4 -->  [4,4,4,4]\nnp.array([4])*4 --> array([16])\n```\n* [spicy](https://uqer.io/community/share/54d83bb3f9f06c276f651a6e)：向量和矩阵的相关操作，基本上算是一个高级的科学计算器,如计算逆矩阵，特征值等等功能,与线性代数相关。\n* [panda](https://uqer.io/community/share/54ffd96ef9f06c276f651aac):金融计算的高级库，提供了Series和DataFrame两种高级的数据结果，前者理解成列，后者理解成表（一个表是由n个列组成的）。\n* 高级的有：机器学习算法库等，这就不懂了\n* 其他的自定义绘图库matplotlib等\n\n### 基本功能\n这两个平台都基于**ipython**提供了两种基本的功能：code和strategy。\n> jupyter与ipython：这个东西很有用，jupyter是一个网页交互器，对于脚本语言可以即可写，即可得到结果。ipython是一个接口可以让jupyter支持python的编译执行，可以缓存其他的语言如ruby。这个东西是学习python这些语言的强力助手，提供自动不全的公共，适合边学习边实验。\n\n简单地说：\n\n* code：纯洁的python运行环境，可以调用各种api，包括python自己的lib和金融平台提供的api。一个常见的流程是：使用平台api获取数据-->用python的数据处理工具处理-->写一下模板方法和变量（具体逻辑）-->import平台提供的回测库，调用回测api（需要把刚才写的模板方法和变量作为参数传入）-->拿到结果，用python的数据处理工具处理-->用python的绘图工具如matplotlib画出结果。优点是自由度高，缺点，必须要自己各种处理数据画图。\n\n\t```py\nbt, acct = quartz.backtest(start = start,end = end,\\\n             benchmark = benchmark,\\\n             universe = universe,\\\n             capital_base = capital_base,\\\n             initialize = initialize,\\\n             handle_data = handle_data,\\\n             refresh_rate = refresh_rate)\n# 下面绘图\n```\n* strategy：一个模板化的python环境，实现一下模板的方法和变量（与上面类似）：如在handle_data中判断然后下单，但是你不需要手动应用回测库开始回测，点击运行自动调研模板方法，绘制出图。\n\n\t```py\nstart = '2014-01-01'                       # 回测起始时间\nend = '2015-01-01'                         # 回测结束时间\nbenchmark = 'HS300'                        # 策略参考标准\nuniverse = ['000001.XSHE', '600000.XSHG']  # 证券池，支持股票和基金\ncapital_base = 100000                      # 起始资金\nfreq = 'd'                                 # 策略类型，'d'表示日间策略使用日线回测，'m'表示日内策略使用分钟线回测\nrefresh_rate = 1                           # 调仓频率，表示执行handle_data的时间间隔，若freq = 'd'时间间隔的单位为交易日，若freq = 'm'时间间隔为分钟\ndef initialize(account):                   # 初始化虚拟账户状态\n    pass\ndef handle_data(account):                  # 每个交易日的买入卖出指令\n    return\n```\n\n核心的概念，就是在某个时机下单。\n时机：\n\n* 日间策略 -- 函数每个交易日调用一次，注意，此时下单价格是开盘价格（优矿），框架一般认为必然**成功**\n* 分钟策略 -- 每一分钟调用一次，以市价（当前价格）/限价（限定某个）来下单，**未必能买的到**\n\n下单：\n\n* order(stk,100) 以当前价格买100股\n* order_to(stk,100) 以当前价格买/卖，最后剩余100股\n* 其他，按比例什么的，有些平台可以用价格去下单，如买1000块的股票。（内部应该也处理了取整）\n\n### 一些坑\n优矿平台：\n\n* handle_data里下了单，但是账户信息不会离开变化（比如余额，持股），要下次调用handle_data的时候才变，注意理解！但是其他平台未必。\n* account.universe中的股票的顺序个数都可能被修改！不是你传入的，他会过滤去重排序。\n* 无法增加cash，记追加投资，就是**不好实现定投**（用策略不行，用code可以自己来）\n* 只支持：股票，场内etf基金，一些场内债券，其他的如分级基金、普通的开放式基金都不支持。\n* secID和ticker证券代码：前者是内部id，因为同一个证券号码可能有多个对应的东西\n* 下单失败努力找原因。。比如，cash太少买不了一手\n\n聚宽：\n数据太少，比如etf，只有2014年12月的。。\n优点是api比优矿完善的多！\n\n## 实践\n我使用code模式，实现了**按月定投**逻辑和**定期按比例重新分配**资产。[这里下载](./codes/定投分析.py)。这里面用到一个很有用的库dateutil，可以方便的[产生时间序列](http://www.andyvenet.com/using-dateutil-generate-recurring-dates/)，比如每个月的最后一天，每年第几天等\n分析结果用图表的形式表现出来：\n![分析结果](./images/financial_quant_analyse.jpg)\n\n## 总结\n这些只是入门的内容，还有很多数据层面的东西要学习以及金融知识，比如那些指标是什么含义。今年有计划看一本金融类的入门书籍。理财是一个长期需要坚持的事情，从简单的策略做起，不断学习，优化，认识到不足，再优化。期望能脱离盲目，我相信，**所谓坚持不懈，毫不动摇必须要有强大的学识基础。**","slug":"理财：量化分析平台，一个定投策略的实现","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbd9001jnac989kiz97z","content":"<p>不得不说理财是一项基本的能力，从工作开始有意识地买了很多理财产品，股票，基金，p2p。仅仅基金就买过股票型，指数型，还有比较复杂的分级基金A/B。之前的购买大部分是尝试性的，漫无目的，更没有任何仔细的思量。似乎这叫做<strong>赌博</strong>更加合适。<br>经过这一年的尝试，渐渐确定了我的理财目标。几个原则：</p>\n<ul>\n<li>作为非专业人员，不会花大量时间在这上面，如股票看盘</li>\n<li><p>为自己风险可以偏大，为父母，风险可控。基本公式：</p>\n<blockquote>\n<p>理财资产（非固定收益类）/总资产=100-年龄<br>在此基础上微调：</p>\n<ul>\n<li>自己:比例 &gt; 75% –&gt; 85%左右,40%回撤</li>\n<li>父母:比例 &lt; 45% –&gt; 40%，18%回撤</li>\n</ul>\n</blockquote>\n</li>\n<li><p>不投资不了解的产品，<strong>必须经过数据计算</strong>后投资</p>\n</li>\n</ul>\n<p>目标：</p>\n<ul>\n<li>追求 &gt; 10%的年化收益，目标为15%</li>\n</ul>\n<p>这篇文章讲讲最近了解的金融数据的<strong>回测</strong>平台。简单来说就是指定策略然后使用历史数据技术模拟投资，查看结果。</p>\n<h2 id=\"国内的量化平台\"><a href=\"#国内的量化平台\" class=\"headerlink\" title=\"国内的量化平台\"></a>国内的量化平台</h2><p>基本了解了一下国内的策略平台功能比较弱，但是由于数据原因也没有其他好的选择。基本是两个平台</p>\n<ul>\n<li>UQER-优矿</li>\n<li>聚宽</li>\n</ul>\n<p>这两个平台十分相似，我怀疑是互相抄袭的，或者抄的国外的某平台，可是。。。。他们的数据也不全，很多数据只有2013年以后。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>这没什么可说的，其实就是Python语法+常用的数据处理lib+平台API，<br>对我而言，python使用的比较少，基本语法没有问题，但是一些输出处理的库就是否生疏了，比如numpy，spicy，panda等，这些库大大的方便我们进行数据运算和整合：</p>\n<h3 id=\"分析常用的lib\"><a href=\"#分析常用的lib\" class=\"headerlink\" title=\"分析常用的lib\"></a>分析常用的lib</h3><ul>\n<li><p><a href=\"https://uqer.io/community/share/54ca15f9f9f06c276f651a56\" target=\"_blank\" rel=\"external\">numpy</a>:主要提供了array数据结构(多纬度)，与元组/列表最大的区别是，它约束数组内的数据类型要相同，一些细微的操作也不通</p>\n  <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[4]*4 --&gt;  [4,4,4,4]</div><div class=\"line\">np.array([4])*4 --&gt; array([16])</div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://uqer.io/community/share/54d83bb3f9f06c276f651a6e\" target=\"_blank\" rel=\"external\">spicy</a>：向量和矩阵的相关操作，基本上算是一个高级的科学计算器,如计算逆矩阵，特征值等等功能,与线性代数相关。</p>\n</li>\n<li><a href=\"https://uqer.io/community/share/54ffd96ef9f06c276f651aac\" target=\"_blank\" rel=\"external\">panda</a>:金融计算的高级库，提供了Series和DataFrame两种高级的数据结果，前者理解成列，后者理解成表（一个表是由n个列组成的）。</li>\n<li>高级的有：机器学习算法库等，这就不懂了</li>\n<li>其他的自定义绘图库matplotlib等</li>\n</ul>\n<h3 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h3><p>这两个平台都基于<strong>ipython</strong>提供了两种基本的功能：code和strategy。</p>\n<blockquote>\n<p>jupyter与ipython：这个东西很有用，jupyter是一个网页交互器，对于脚本语言可以即可写，即可得到结果。ipython是一个接口可以让jupyter支持python的编译执行，可以缓存其他的语言如ruby。这个东西是学习python这些语言的强力助手，提供自动不全的公共，适合边学习边实验。</p>\n</blockquote>\n<p>简单地说：</p>\n<ul>\n<li><p>code：纯洁的python运行环境，可以调用各种api，包括python自己的lib和金融平台提供的api。一个常见的流程是：使用平台api获取数据–&gt;用python的数据处理工具处理–&gt;写一下模板方法和变量（具体逻辑）–&gt;import平台提供的回测库，调用回测api（需要把刚才写的模板方法和变量作为参数传入）–&gt;拿到结果，用python的数据处理工具处理–&gt;用python的绘图工具如matplotlib画出结果。优点是自由度高，缺点，必须要自己各种处理数据画图。</p>\n  <figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">bt, acct = quartz.backtest(start = start,end = end,\\</div><div class=\"line\">             benchmark = benchmark,\\</div><div class=\"line\">             universe = universe,\\</div><div class=\"line\">             capital_base = capital_base,\\</div><div class=\"line\">             initialize = initialize,\\</div><div class=\"line\">             handle_data = handle_data,\\</div><div class=\"line\">             refresh_rate = refresh_rate)</div><div class=\"line\"><span class=\"comment\"># 下面绘图</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>strategy：一个模板化的python环境，实现一下模板的方法和变量（与上面类似）：如在handle_data中判断然后下单，但是你不需要手动应用回测库开始回测，点击运行自动调研模板方法，绘制出图。</p>\n  <figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">start = <span class=\"string\">'2014-01-01'</span>                       <span class=\"comment\"># 回测起始时间</span></div><div class=\"line\">end = <span class=\"string\">'2015-01-01'</span>                         <span class=\"comment\"># 回测结束时间</span></div><div class=\"line\">benchmark = <span class=\"string\">'HS300'</span>                        <span class=\"comment\"># 策略参考标准</span></div><div class=\"line\">universe = [<span class=\"string\">'000001.XSHE'</span>, <span class=\"string\">'600000.XSHG'</span>]  <span class=\"comment\"># 证券池，支持股票和基金</span></div><div class=\"line\">capital_base = <span class=\"number\">100000</span>                      <span class=\"comment\"># 起始资金</span></div><div class=\"line\">freq = <span class=\"string\">'d'</span>                                 <span class=\"comment\"># 策略类型，'d'表示日间策略使用日线回测，'m'表示日内策略使用分钟线回测</span></div><div class=\"line\">refresh_rate = <span class=\"number\">1</span>                           <span class=\"comment\"># 调仓频率，表示执行handle_data的时间间隔，若freq = 'd'时间间隔的单位为交易日，若freq = 'm'时间间隔为分钟</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">initialize</span><span class=\"params\">(account)</span>:</span>                   <span class=\"comment\"># 初始化虚拟账户状态</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_data</span><span class=\"params\">(account)</span>:</span>                  <span class=\"comment\"># 每个交易日的买入卖出指令</span></div><div class=\"line\">    <span class=\"keyword\">return</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>核心的概念，就是在某个时机下单。<br>时机：</p>\n<ul>\n<li>日间策略 – 函数每个交易日调用一次，注意，此时下单价格是开盘价格（优矿），框架一般认为必然<strong>成功</strong></li>\n<li>分钟策略 – 每一分钟调用一次，以市价（当前价格）/限价（限定某个）来下单，<strong>未必能买的到</strong></li>\n</ul>\n<p>下单：</p>\n<ul>\n<li>order(stk,100) 以当前价格买100股</li>\n<li>order_to(stk,100) 以当前价格买/卖，最后剩余100股</li>\n<li>其他，按比例什么的，有些平台可以用价格去下单，如买1000块的股票。（内部应该也处理了取整）</li>\n</ul>\n<h3 id=\"一些坑\"><a href=\"#一些坑\" class=\"headerlink\" title=\"一些坑\"></a>一些坑</h3><p>优矿平台：</p>\n<ul>\n<li>handle_data里下了单，但是账户信息不会离开变化（比如余额，持股），要下次调用handle_data的时候才变，注意理解！但是其他平台未必。</li>\n<li>account.universe中的股票的顺序个数都可能被修改！不是你传入的，他会过滤去重排序。</li>\n<li>无法增加cash，记追加投资，就是<strong>不好实现定投</strong>（用策略不行，用code可以自己来）</li>\n<li>只支持：股票，场内etf基金，一些场内债券，其他的如分级基金、普通的开放式基金都不支持。</li>\n<li>secID和ticker证券代码：前者是内部id，因为同一个证券号码可能有多个对应的东西</li>\n<li>下单失败努力找原因。。比如，cash太少买不了一手</li>\n</ul>\n<p>聚宽：<br>数据太少，比如etf，只有2014年12月的。。<br>优点是api比优矿完善的多！</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>我使用code模式，实现了<strong>按月定投</strong>逻辑和<strong>定期按比例重新分配</strong>资产。<a href=\"./codes/定投分析.py\">这里下载</a>。这里面用到一个很有用的库dateutil，可以方便的<a href=\"http://www.andyvenet.com/using-dateutil-generate-recurring-dates/\" target=\"_blank\" rel=\"external\">产生时间序列</a>，比如每个月的最后一天，每年第几天等<br>分析结果用图表的形式表现出来：<br><img src=\"./images/financial_quant_analyse.jpg\" alt=\"分析结果\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这些只是入门的内容，还有很多数据层面的东西要学习以及金融知识，比如那些指标是什么含义。今年有计划看一本金融类的入门书籍。理财是一个长期需要坚持的事情，从简单的策略做起，不断学习，优化，认识到不足，再优化。期望能脱离盲目，我相信，<strong>所谓坚持不懈，毫不动摇必须要有强大的学识基础。</strong></p>\n","excerpt":"","more":"<p>不得不说理财是一项基本的能力，从工作开始有意识地买了很多理财产品，股票，基金，p2p。仅仅基金就买过股票型，指数型，还有比较复杂的分级基金A/B。之前的购买大部分是尝试性的，漫无目的，更没有任何仔细的思量。似乎这叫做<strong>赌博</strong>更加合适。<br>经过这一年的尝试，渐渐确定了我的理财目标。几个原则：</p>\n<ul>\n<li>作为非专业人员，不会花大量时间在这上面，如股票看盘</li>\n<li><p>为自己风险可以偏大，为父母，风险可控。基本公式：</p>\n<blockquote>\n<p>理财资产（非固定收益类）/总资产=100-年龄<br>在此基础上微调：</p>\n<ul>\n<li>自己:比例 &gt; 75% –&gt; 85%左右,40%回撤</li>\n<li>父母:比例 &lt; 45% –&gt; 40%，18%回撤</li>\n</ul>\n</blockquote>\n</li>\n<li><p>不投资不了解的产品，<strong>必须经过数据计算</strong>后投资</p>\n</li>\n</ul>\n<p>目标：</p>\n<ul>\n<li>追求 &gt; 10%的年化收益，目标为15%</li>\n</ul>\n<p>这篇文章讲讲最近了解的金融数据的<strong>回测</strong>平台。简单来说就是指定策略然后使用历史数据技术模拟投资，查看结果。</p>\n<h2 id=\"国内的量化平台\"><a href=\"#国内的量化平台\" class=\"headerlink\" title=\"国内的量化平台\"></a>国内的量化平台</h2><p>基本了解了一下国内的策略平台功能比较弱，但是由于数据原因也没有其他好的选择。基本是两个平台</p>\n<ul>\n<li>UQER-优矿</li>\n<li>聚宽</li>\n</ul>\n<p>这两个平台十分相似，我怀疑是互相抄袭的，或者抄的国外的某平台，可是。。。。他们的数据也不全，很多数据只有2013年以后。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>这没什么可说的，其实就是Python语法+常用的数据处理lib+平台API，<br>对我而言，python使用的比较少，基本语法没有问题，但是一些输出处理的库就是否生疏了，比如numpy，spicy，panda等，这些库大大的方便我们进行数据运算和整合：</p>\n<h3 id=\"分析常用的lib\"><a href=\"#分析常用的lib\" class=\"headerlink\" title=\"分析常用的lib\"></a>分析常用的lib</h3><ul>\n<li><p><a href=\"https://uqer.io/community/share/54ca15f9f9f06c276f651a56\">numpy</a>:主要提供了array数据结构(多纬度)，与元组/列表最大的区别是，它约束数组内的数据类型要相同，一些细微的操作也不通</p>\n  <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[4]*4 --&gt;  [4,4,4,4]</div><div class=\"line\">np.array([4])*4 --&gt; array([16])</div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://uqer.io/community/share/54d83bb3f9f06c276f651a6e\">spicy</a>：向量和矩阵的相关操作，基本上算是一个高级的科学计算器,如计算逆矩阵，特征值等等功能,与线性代数相关。</p>\n</li>\n<li><a href=\"https://uqer.io/community/share/54ffd96ef9f06c276f651aac\">panda</a>:金融计算的高级库，提供了Series和DataFrame两种高级的数据结果，前者理解成列，后者理解成表（一个表是由n个列组成的）。</li>\n<li>高级的有：机器学习算法库等，这就不懂了</li>\n<li>其他的自定义绘图库matplotlib等</li>\n</ul>\n<h3 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h3><p>这两个平台都基于<strong>ipython</strong>提供了两种基本的功能：code和strategy。</p>\n<blockquote>\n<p>jupyter与ipython：这个东西很有用，jupyter是一个网页交互器，对于脚本语言可以即可写，即可得到结果。ipython是一个接口可以让jupyter支持python的编译执行，可以缓存其他的语言如ruby。这个东西是学习python这些语言的强力助手，提供自动不全的公共，适合边学习边实验。</p>\n</blockquote>\n<p>简单地说：</p>\n<ul>\n<li><p>code：纯洁的python运行环境，可以调用各种api，包括python自己的lib和金融平台提供的api。一个常见的流程是：使用平台api获取数据–&gt;用python的数据处理工具处理–&gt;写一下模板方法和变量（具体逻辑）–&gt;import平台提供的回测库，调用回测api（需要把刚才写的模板方法和变量作为参数传入）–&gt;拿到结果，用python的数据处理工具处理–&gt;用python的绘图工具如matplotlib画出结果。优点是自由度高，缺点，必须要自己各种处理数据画图。</p>\n  <figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">bt, acct = quartz.backtest(start = start,end = end,\\</div><div class=\"line\">             benchmark = benchmark,\\</div><div class=\"line\">             universe = universe,\\</div><div class=\"line\">             capital_base = capital_base,\\</div><div class=\"line\">             initialize = initialize,\\</div><div class=\"line\">             handle_data = handle_data,\\</div><div class=\"line\">             refresh_rate = refresh_rate)</div><div class=\"line\"><span class=\"comment\"># 下面绘图</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>strategy：一个模板化的python环境，实现一下模板的方法和变量（与上面类似）：如在handle_data中判断然后下单，但是你不需要手动应用回测库开始回测，点击运行自动调研模板方法，绘制出图。</p>\n  <figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">start = <span class=\"string\">'2014-01-01'</span>                       <span class=\"comment\"># 回测起始时间</span></div><div class=\"line\">end = <span class=\"string\">'2015-01-01'</span>                         <span class=\"comment\"># 回测结束时间</span></div><div class=\"line\">benchmark = <span class=\"string\">'HS300'</span>                        <span class=\"comment\"># 策略参考标准</span></div><div class=\"line\">universe = [<span class=\"string\">'000001.XSHE'</span>, <span class=\"string\">'600000.XSHG'</span>]  <span class=\"comment\"># 证券池，支持股票和基金</span></div><div class=\"line\">capital_base = <span class=\"number\">100000</span>                      <span class=\"comment\"># 起始资金</span></div><div class=\"line\">freq = <span class=\"string\">'d'</span>                                 <span class=\"comment\"># 策略类型，'d'表示日间策略使用日线回测，'m'表示日内策略使用分钟线回测</span></div><div class=\"line\">refresh_rate = <span class=\"number\">1</span>                           <span class=\"comment\"># 调仓频率，表示执行handle_data的时间间隔，若freq = 'd'时间间隔的单位为交易日，若freq = 'm'时间间隔为分钟</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">initialize</span><span class=\"params\">(account)</span>:</span>                   <span class=\"comment\"># 初始化虚拟账户状态</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_data</span><span class=\"params\">(account)</span>:</span>                  <span class=\"comment\"># 每个交易日的买入卖出指令</span></div><div class=\"line\">    <span class=\"keyword\">return</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>核心的概念，就是在某个时机下单。<br>时机：</p>\n<ul>\n<li>日间策略 – 函数每个交易日调用一次，注意，此时下单价格是开盘价格（优矿），框架一般认为必然<strong>成功</strong></li>\n<li>分钟策略 – 每一分钟调用一次，以市价（当前价格）/限价（限定某个）来下单，<strong>未必能买的到</strong></li>\n</ul>\n<p>下单：</p>\n<ul>\n<li>order(stk,100) 以当前价格买100股</li>\n<li>order_to(stk,100) 以当前价格买/卖，最后剩余100股</li>\n<li>其他，按比例什么的，有些平台可以用价格去下单，如买1000块的股票。（内部应该也处理了取整）</li>\n</ul>\n<h3 id=\"一些坑\"><a href=\"#一些坑\" class=\"headerlink\" title=\"一些坑\"></a>一些坑</h3><p>优矿平台：</p>\n<ul>\n<li>handle_data里下了单，但是账户信息不会离开变化（比如余额，持股），要下次调用handle_data的时候才变，注意理解！但是其他平台未必。</li>\n<li>account.universe中的股票的顺序个数都可能被修改！不是你传入的，他会过滤去重排序。</li>\n<li>无法增加cash，记追加投资，就是<strong>不好实现定投</strong>（用策略不行，用code可以自己来）</li>\n<li>只支持：股票，场内etf基金，一些场内债券，其他的如分级基金、普通的开放式基金都不支持。</li>\n<li>secID和ticker证券代码：前者是内部id，因为同一个证券号码可能有多个对应的东西</li>\n<li>下单失败努力找原因。。比如，cash太少买不了一手</li>\n</ul>\n<p>聚宽：<br>数据太少，比如etf，只有2014年12月的。。<br>优点是api比优矿完善的多！</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>我使用code模式，实现了<strong>按月定投</strong>逻辑和<strong>定期按比例重新分配</strong>资产。<a href=\"./codes/定投分析.py\">这里下载</a>。这里面用到一个很有用的库dateutil，可以方便的<a href=\"http://www.andyvenet.com/using-dateutil-generate-recurring-dates/\">产生时间序列</a>，比如每个月的最后一天，每年第几天等<br>分析结果用图表的形式表现出来：<br><img src=\"./images/financial_quant_analyse.jpg\" alt=\"分析结果\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这些只是入门的内容，还有很多数据层面的东西要学习以及金融知识，比如那些指标是什么含义。今年有计划看一本金融类的入门书籍。理财是一个长期需要坚持的事情，从简单的策略做起，不断学习，优化，认识到不足，再优化。期望能脱离盲目，我相信，<strong>所谓坚持不懈，毫不动摇必须要有强大的学识基础。</strong></p>\n"},{"title":"Android构架系列之二--常见框架分析(一）","date":"2016-04-04T02:09:42.000Z","_content":"\n在搭建新项目的过程中，调研了一些常用的开发框架，恰好近日Google公布了[一系列框架的梳理](https://github.com/googlesamples/android-architecture)（未完成），对Android开发者给出了一些指导，颇有裨益。总结了如下几种模式：\n\n1. 纯MVP开发\n2. MVP+Loader\n3. MVP+Databinding\n4. MVP+ContentProvider\n5. MVP+Dagger\n6. MVP+Clean构架\n\n总体而言，基本涵盖了Android中的流行的开发构架方式。这些开发框架是以MVP为基础，再结合其他工具，或者再次细分某些层，实现更好的复用。这里首先简介一下MVP，然后将上述6个框架按照我的理解（可能不完备）进行归类总结。\n\n## MVP分析\nMVP是上述六个框架的基础，对于MVP的认识，最好结合MVC、MVVM这两个框架进行学习，一个基本的理解参考阮一峰先生的[这篇文章](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)。\n我总结几点：\n\n* M层，即`model`，负责数据部分，如网络请求、数据库，获取数据。\n* V层，即`view`，负责数据展示，Android的View或者Fragemnt\n* P层，即`presenter`,核心，负责从M获取数据，然后控制V更新。\n* **核心：M与V不直接交互数据，必须通过P**\n* 具体而言：V实现某个UIController接口，暴露自己实现的UI功能，如显示Progress等，P持有V的接口。V同时也会持有P，他们相互依赖（最好V/P都是通过接口依赖）。\n\n\t> 流程是：V收到用户操作-->调用P的某方法-->P去M获取数据-->获取成功-->P调用V暴露的接口去更新界面\n\t> 注意：有些框架可能把Activity看着`Presenter`，这可能导致Activity中有过多的代码，建议还是抽出一个Presenter类，Activity仅仅看做一个View层实体。\n\n## 构架分析\n\n### MVP+Loader/MVP+ContentProvider\n\n这两个构架都是在P层与数据M层之间进行优化，主要**优化了P层从M层获取数据的方式**，使用Android原生（3.0开始）提供的`Loader`异步加载机制，从数据库/网络等地方加载数据。`CotentProvider`思想类似，使用了`CotentProvider`方式，分离数据部分，实现解耦。\n\n### MVP+Databinding\n\n这个框架可以看着是MVVM框架了。Databinding是利用Android提供的一个库实现了数据绑定的功能，即某个`Entity`内容可以直接反应到`View`中，同样`View`一旦修改，`Entity`也会变换。**本质上，这种方式简化了MVP中P层与V层的关系**，P层处理完的数据，放入某个实体中就可以显示在界面上。当然也有其缺陷。\n\n### MVP+Dagger\n这就比较好理解了，将MVP中对象的构造使用Dagger2代替，是一种强制性解耦的措施，具体可以参加[之前的文章](http://limuzhi.com/2016/03/06/Android%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Dagger2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)。\n\n### MVP+Clean构架\n这里主要讲解一下Clean构架，什么是Clean构架，这在网上有很多介绍的文章，其实就是一种基于MVP再次分层的构架，历史比较悠久了（2012年？）。下面详细介绍。\n\n#### Clean学习\n\n基本的学习看Clean构架的文章：\n\n* [原始文章](http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html)\n：比较抽象，难以理解，不建议首先学习！\n* Clean构架详细的解析文章，[原文](http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)，[中文翻译](http://zhuanlan.zhihu.com/p/20001838)：可以直接学习这一篇文章，GitHub有详细的[代码和讲解](https://github.com/android10/Android-CleanArchitecture)，注意作者迭代了两个版本,第一版是没有依赖注入，RxJava那些框架的，相对比较好理解。\n* [国人讲解的Clean框架](http://blog.chengdazhi.com/index.php/101)：建议优先学习这篇文章，构架在在一个工程Module中，代码干净，比较好理解，但是可能对Clean的理解并不透彻。\n\n#### Clean基本思想\n总结一下Clean的基本思想：\n首先，我们应该**从MVP出发理解Clean构架**。\nClean构架中，把整个项目分成3个模块，`presentation`（表现层），`domain`（领域层），`data`（数据层）。\n\n* 表现层中，就已经包含了完整的MVP构架，但是与传统的MVP不同的是：\n\t* 这里的M，更加倾向于ViewModel，即仅仅用来存放展示数据的`Model`，与数据库等无关！『从数据源获取数据』的功能被剥离出去，形成了`data`层。\n\t* 这里的P，是不完整的P，它的核心功能，『调用M从数据源（真正的M）获取数据&&处理数据』的逻辑被剥离了出去！形成了`domain`层。\n\t* 这里的V，是完整意义上的`View`\n* 领域层中，即以前MVP中P剥离处理的调用M和数据处理的逻辑。在Clean种，一个`domain`中有n个`usecase`，一个`usecase`相对独立，处理单独的业务逻辑，其设计模式参考**『命令模式』**。\n* 数据层中，是真正的从数据源获取数据，`domain`层会调用它，获取数据，注意：**domain层并不关心数据的来源（网络/本地文件/数据缓存）**，至于内存cache的处理，是放在`domain`还是`data`，需要再研究。（server端看法：放在`domain`中，因为数据层更倾向于io操作）\n\n#### Clean的数据流\npresentation（V）--> presentation（P）--> domain(usecase) -->data-->domain(usecase,数据回调)--> presentation(P，结果回调) -->presentation（V,P调用V的UIController接口）\n\n#### 几个注意点与疑惑\n* 多个model实体，即`presentation`、`domain`、`data`需要三层独立的Model，思考：**为什么，如何优化？**\n* `domain`层是纯java层，**理想状态是纯java module**，与android无关。如果多module项目，这需要考虑，使用纯`java module`后，`presentation`无法直接访问`data`（跨层访问），`domain`也无法访问`presentation`和`data`（**只能通过放在domain层的接口来访问**）。虽然也好处是强制解耦，开发人员也不会误操作，但是限制很大。这也直接导致了第一个问题。\n* 太多的接口，总结一下在尽量接口设计且`domain`是纯java层时，需要这些接口\n\t* `presentation`内部，VP之间一组（两个，ui，presenter）\n\t* `presentation`与`domain`之间一组（两个，调用`usecase`与回调，必须放在`domain`中）\n\t* `domain`与`data`之间一组（两个，调用repository与回调，必须放在domain中）\n\t* `data`内部，调用网络异步（一组）、数据库异步（一组）\n\t\n\t> 如何解决：1.通用接口设计，而不是更具业务不同（如各种callback）2.能不使用接口的地方直接调用，但会丧失Clean的优势（在纯domain，java层时有些接口不可避免） 3.**用Rxjava不仅能减少接口，还能避免深层次的回调逻辑**\n* 关于`domain`的理解，一个`usecase`的粒度是多大？只做一件事，然后通过usecase组合来实现新的`usecase`来完成业务？还是在一个`usecase`中写n个逻辑与回调，来实现（内存缓存数据处理大大方便，这也涉及内存缓存数据存放的问题）。尝试从『命令模式』角度思考。\n* Clean的一大优势是，可以强制所有的`usecase`必须在非UI线程完成，只有`presentation`在UI线程，大大的减少了阻塞UI线程的可能性，即`domain`层在非UI完成，那么data层的接口是否还需要异步接口，还是直接使用同步接口？\n\n## 总结\n上面介绍了Google推荐了几种构架，主要说明了MVP与Clean构架。基本上MVP是现在项目的标配，虽然Clean清晰，可维护性高，可复用性强，但是是否使用Clean，则看具体情况，也可能对其适当的简化后使用。\n这里Clean构架的[demo](https://github.com/android10/Android-CleanArchitecture)是一个比较高级的样例，综合了Rxjava，Dagger2，OkHttp/Retrofit。混合使用这些技术学习曲线还是比较陡峭的，在实际的构架中，综合团队人员水平，往往用接口代替Rxjava，不使用Dagger2。\n其次，Clean构架可能显得臃肿，**尤其实际中业务逻辑复用的程度并不高**，所以，我们需要简化Clean构架以符合我们的业务需求。\n","source":"_posts/Android构架系列之二-常见框架分析.md","raw":"title: Android构架系列之二--常见框架分析(一）\ndate: 2016-04-04 10:09:42\ncategories:\n- 技术\ntags:\n- Android\n- 主框架\n---\n\n在搭建新项目的过程中，调研了一些常用的开发框架，恰好近日Google公布了[一系列框架的梳理](https://github.com/googlesamples/android-architecture)（未完成），对Android开发者给出了一些指导，颇有裨益。总结了如下几种模式：\n\n1. 纯MVP开发\n2. MVP+Loader\n3. MVP+Databinding\n4. MVP+ContentProvider\n5. MVP+Dagger\n6. MVP+Clean构架\n\n总体而言，基本涵盖了Android中的流行的开发构架方式。这些开发框架是以MVP为基础，再结合其他工具，或者再次细分某些层，实现更好的复用。这里首先简介一下MVP，然后将上述6个框架按照我的理解（可能不完备）进行归类总结。\n\n## MVP分析\nMVP是上述六个框架的基础，对于MVP的认识，最好结合MVC、MVVM这两个框架进行学习，一个基本的理解参考阮一峰先生的[这篇文章](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)。\n我总结几点：\n\n* M层，即`model`，负责数据部分，如网络请求、数据库，获取数据。\n* V层，即`view`，负责数据展示，Android的View或者Fragemnt\n* P层，即`presenter`,核心，负责从M获取数据，然后控制V更新。\n* **核心：M与V不直接交互数据，必须通过P**\n* 具体而言：V实现某个UIController接口，暴露自己实现的UI功能，如显示Progress等，P持有V的接口。V同时也会持有P，他们相互依赖（最好V/P都是通过接口依赖）。\n\n\t> 流程是：V收到用户操作-->调用P的某方法-->P去M获取数据-->获取成功-->P调用V暴露的接口去更新界面\n\t> 注意：有些框架可能把Activity看着`Presenter`，这可能导致Activity中有过多的代码，建议还是抽出一个Presenter类，Activity仅仅看做一个View层实体。\n\n## 构架分析\n\n### MVP+Loader/MVP+ContentProvider\n\n这两个构架都是在P层与数据M层之间进行优化，主要**优化了P层从M层获取数据的方式**，使用Android原生（3.0开始）提供的`Loader`异步加载机制，从数据库/网络等地方加载数据。`CotentProvider`思想类似，使用了`CotentProvider`方式，分离数据部分，实现解耦。\n\n### MVP+Databinding\n\n这个框架可以看着是MVVM框架了。Databinding是利用Android提供的一个库实现了数据绑定的功能，即某个`Entity`内容可以直接反应到`View`中，同样`View`一旦修改，`Entity`也会变换。**本质上，这种方式简化了MVP中P层与V层的关系**，P层处理完的数据，放入某个实体中就可以显示在界面上。当然也有其缺陷。\n\n### MVP+Dagger\n这就比较好理解了，将MVP中对象的构造使用Dagger2代替，是一种强制性解耦的措施，具体可以参加[之前的文章](http://limuzhi.com/2016/03/06/Android%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Dagger2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)。\n\n### MVP+Clean构架\n这里主要讲解一下Clean构架，什么是Clean构架，这在网上有很多介绍的文章，其实就是一种基于MVP再次分层的构架，历史比较悠久了（2012年？）。下面详细介绍。\n\n#### Clean学习\n\n基本的学习看Clean构架的文章：\n\n* [原始文章](http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html)\n：比较抽象，难以理解，不建议首先学习！\n* Clean构架详细的解析文章，[原文](http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)，[中文翻译](http://zhuanlan.zhihu.com/p/20001838)：可以直接学习这一篇文章，GitHub有详细的[代码和讲解](https://github.com/android10/Android-CleanArchitecture)，注意作者迭代了两个版本,第一版是没有依赖注入，RxJava那些框架的，相对比较好理解。\n* [国人讲解的Clean框架](http://blog.chengdazhi.com/index.php/101)：建议优先学习这篇文章，构架在在一个工程Module中，代码干净，比较好理解，但是可能对Clean的理解并不透彻。\n\n#### Clean基本思想\n总结一下Clean的基本思想：\n首先，我们应该**从MVP出发理解Clean构架**。\nClean构架中，把整个项目分成3个模块，`presentation`（表现层），`domain`（领域层），`data`（数据层）。\n\n* 表现层中，就已经包含了完整的MVP构架，但是与传统的MVP不同的是：\n\t* 这里的M，更加倾向于ViewModel，即仅仅用来存放展示数据的`Model`，与数据库等无关！『从数据源获取数据』的功能被剥离出去，形成了`data`层。\n\t* 这里的P，是不完整的P，它的核心功能，『调用M从数据源（真正的M）获取数据&&处理数据』的逻辑被剥离了出去！形成了`domain`层。\n\t* 这里的V，是完整意义上的`View`\n* 领域层中，即以前MVP中P剥离处理的调用M和数据处理的逻辑。在Clean种，一个`domain`中有n个`usecase`，一个`usecase`相对独立，处理单独的业务逻辑，其设计模式参考**『命令模式』**。\n* 数据层中，是真正的从数据源获取数据，`domain`层会调用它，获取数据，注意：**domain层并不关心数据的来源（网络/本地文件/数据缓存）**，至于内存cache的处理，是放在`domain`还是`data`，需要再研究。（server端看法：放在`domain`中，因为数据层更倾向于io操作）\n\n#### Clean的数据流\npresentation（V）--> presentation（P）--> domain(usecase) -->data-->domain(usecase,数据回调)--> presentation(P，结果回调) -->presentation（V,P调用V的UIController接口）\n\n#### 几个注意点与疑惑\n* 多个model实体，即`presentation`、`domain`、`data`需要三层独立的Model，思考：**为什么，如何优化？**\n* `domain`层是纯java层，**理想状态是纯java module**，与android无关。如果多module项目，这需要考虑，使用纯`java module`后，`presentation`无法直接访问`data`（跨层访问），`domain`也无法访问`presentation`和`data`（**只能通过放在domain层的接口来访问**）。虽然也好处是强制解耦，开发人员也不会误操作，但是限制很大。这也直接导致了第一个问题。\n* 太多的接口，总结一下在尽量接口设计且`domain`是纯java层时，需要这些接口\n\t* `presentation`内部，VP之间一组（两个，ui，presenter）\n\t* `presentation`与`domain`之间一组（两个，调用`usecase`与回调，必须放在`domain`中）\n\t* `domain`与`data`之间一组（两个，调用repository与回调，必须放在domain中）\n\t* `data`内部，调用网络异步（一组）、数据库异步（一组）\n\t\n\t> 如何解决：1.通用接口设计，而不是更具业务不同（如各种callback）2.能不使用接口的地方直接调用，但会丧失Clean的优势（在纯domain，java层时有些接口不可避免） 3.**用Rxjava不仅能减少接口，还能避免深层次的回调逻辑**\n* 关于`domain`的理解，一个`usecase`的粒度是多大？只做一件事，然后通过usecase组合来实现新的`usecase`来完成业务？还是在一个`usecase`中写n个逻辑与回调，来实现（内存缓存数据处理大大方便，这也涉及内存缓存数据存放的问题）。尝试从『命令模式』角度思考。\n* Clean的一大优势是，可以强制所有的`usecase`必须在非UI线程完成，只有`presentation`在UI线程，大大的减少了阻塞UI线程的可能性，即`domain`层在非UI完成，那么data层的接口是否还需要异步接口，还是直接使用同步接口？\n\n## 总结\n上面介绍了Google推荐了几种构架，主要说明了MVP与Clean构架。基本上MVP是现在项目的标配，虽然Clean清晰，可维护性高，可复用性强，但是是否使用Clean，则看具体情况，也可能对其适当的简化后使用。\n这里Clean构架的[demo](https://github.com/android10/Android-CleanArchitecture)是一个比较高级的样例，综合了Rxjava，Dagger2，OkHttp/Retrofit。混合使用这些技术学习曲线还是比较陡峭的，在实际的构架中，综合团队人员水平，往往用接口代替Rxjava，不使用Dagger2。\n其次，Clean构架可能显得臃肿，**尤其实际中业务逻辑复用的程度并不高**，所以，我们需要简化Clean构架以符合我们的业务需求。\n","slug":"Android构架系列之二-常见框架分析","published":1,"updated":"2016-07-15T03:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciqn9tbdd001nnac9oxvm5mos","content":"<p>在搭建新项目的过程中，调研了一些常用的开发框架，恰好近日Google公布了<a href=\"https://github.com/googlesamples/android-architecture\" target=\"_blank\" rel=\"external\">一系列框架的梳理</a>（未完成），对Android开发者给出了一些指导，颇有裨益。总结了如下几种模式：</p>\n<ol>\n<li>纯MVP开发</li>\n<li>MVP+Loader</li>\n<li>MVP+Databinding</li>\n<li>MVP+ContentProvider</li>\n<li>MVP+Dagger</li>\n<li>MVP+Clean构架</li>\n</ol>\n<p>总体而言，基本涵盖了Android中的流行的开发构架方式。这些开发框架是以MVP为基础，再结合其他工具，或者再次细分某些层，实现更好的复用。这里首先简介一下MVP，然后将上述6个框架按照我的理解（可能不完备）进行归类总结。</p>\n<h2 id=\"MVP分析\"><a href=\"#MVP分析\" class=\"headerlink\" title=\"MVP分析\"></a>MVP分析</h2><p>MVP是上述六个框架的基础，对于MVP的认识，最好结合MVC、MVVM这两个框架进行学习，一个基本的理解参考阮一峰先生的<a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\" target=\"_blank\" rel=\"external\">这篇文章</a>。<br>我总结几点：</p>\n<ul>\n<li>M层，即<code>model</code>，负责数据部分，如网络请求、数据库，获取数据。</li>\n<li>V层，即<code>view</code>，负责数据展示，Android的View或者Fragemnt</li>\n<li>P层，即<code>presenter</code>,核心，负责从M获取数据，然后控制V更新。</li>\n<li><strong>核心：M与V不直接交互数据，必须通过P</strong></li>\n<li><p>具体而言：V实现某个UIController接口，暴露自己实现的UI功能，如显示Progress等，P持有V的接口。V同时也会持有P，他们相互依赖（最好V/P都是通过接口依赖）。</p>\n<blockquote>\n<p>流程是：V收到用户操作–&gt;调用P的某方法–&gt;P去M获取数据–&gt;获取成功–&gt;P调用V暴露的接口去更新界面<br>注意：有些框架可能把Activity看着<code>Presenter</code>，这可能导致Activity中有过多的代码，建议还是抽出一个Presenter类，Activity仅仅看做一个View层实体。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"构架分析\"><a href=\"#构架分析\" class=\"headerlink\" title=\"构架分析\"></a>构架分析</h2><h3 id=\"MVP-Loader-MVP-ContentProvider\"><a href=\"#MVP-Loader-MVP-ContentProvider\" class=\"headerlink\" title=\"MVP+Loader/MVP+ContentProvider\"></a>MVP+Loader/MVP+ContentProvider</h3><p>这两个构架都是在P层与数据M层之间进行优化，主要<strong>优化了P层从M层获取数据的方式</strong>，使用Android原生（3.0开始）提供的<code>Loader</code>异步加载机制，从数据库/网络等地方加载数据。<code>CotentProvider</code>思想类似，使用了<code>CotentProvider</code>方式，分离数据部分，实现解耦。</p>\n<h3 id=\"MVP-Databinding\"><a href=\"#MVP-Databinding\" class=\"headerlink\" title=\"MVP+Databinding\"></a>MVP+Databinding</h3><p>这个框架可以看着是MVVM框架了。Databinding是利用Android提供的一个库实现了数据绑定的功能，即某个<code>Entity</code>内容可以直接反应到<code>View</code>中，同样<code>View</code>一旦修改，<code>Entity</code>也会变换。<strong>本质上，这种方式简化了MVP中P层与V层的关系</strong>，P层处理完的数据，放入某个实体中就可以显示在界面上。当然也有其缺陷。</p>\n<h3 id=\"MVP-Dagger\"><a href=\"#MVP-Dagger\" class=\"headerlink\" title=\"MVP+Dagger\"></a>MVP+Dagger</h3><p>这就比较好理解了，将MVP中对象的构造使用Dagger2代替，是一种强制性解耦的措施，具体可以参加<a href=\"http://limuzhi.com/2016/03/06/Android%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Dagger2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\">之前的文章</a>。</p>\n<h3 id=\"MVP-Clean构架\"><a href=\"#MVP-Clean构架\" class=\"headerlink\" title=\"MVP+Clean构架\"></a>MVP+Clean构架</h3><p>这里主要讲解一下Clean构架，什么是Clean构架，这在网上有很多介绍的文章，其实就是一种基于MVP再次分层的构架，历史比较悠久了（2012年？）。下面详细介绍。</p>\n<h4 id=\"Clean学习\"><a href=\"#Clean学习\" class=\"headerlink\" title=\"Clean学习\"></a>Clean学习</h4><p>基本的学习看Clean构架的文章：</p>\n<ul>\n<li><a href=\"http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html\" target=\"_blank\" rel=\"external\">原始文章</a><br>：比较抽象，难以理解，不建议首先学习！</li>\n<li>Clean构架详细的解析文章，<a href=\"http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/\" target=\"_blank\" rel=\"external\">原文</a>，<a href=\"http://zhuanlan.zhihu.com/p/20001838\" target=\"_blank\" rel=\"external\">中文翻译</a>：可以直接学习这一篇文章，GitHub有详细的<a href=\"https://github.com/android10/Android-CleanArchitecture\" target=\"_blank\" rel=\"external\">代码和讲解</a>，注意作者迭代了两个版本,第一版是没有依赖注入，RxJava那些框架的，相对比较好理解。</li>\n<li><a href=\"http://blog.chengdazhi.com/index.php/101\" target=\"_blank\" rel=\"external\">国人讲解的Clean框架</a>：建议优先学习这篇文章，构架在在一个工程Module中，代码干净，比较好理解，但是可能对Clean的理解并不透彻。</li>\n</ul>\n<h4 id=\"Clean基本思想\"><a href=\"#Clean基本思想\" class=\"headerlink\" title=\"Clean基本思想\"></a>Clean基本思想</h4><p>总结一下Clean的基本思想：<br>首先，我们应该<strong>从MVP出发理解Clean构架</strong>。<br>Clean构架中，把整个项目分成3个模块，<code>presentation</code>（表现层），<code>domain</code>（领域层），<code>data</code>（数据层）。</p>\n<ul>\n<li>表现层中，就已经包含了完整的MVP构架，但是与传统的MVP不同的是：<ul>\n<li>这里的M，更加倾向于ViewModel，即仅仅用来存放展示数据的<code>Model</code>，与数据库等无关！『从数据源获取数据』的功能被剥离出去，形成了<code>data</code>层。</li>\n<li>这里的P，是不完整的P，它的核心功能，『调用M从数据源（真正的M）获取数据&amp;&amp;处理数据』的逻辑被剥离了出去！形成了<code>domain</code>层。</li>\n<li>这里的V，是完整意义上的<code>View</code></li>\n</ul>\n</li>\n<li>领域层中，即以前MVP中P剥离处理的调用M和数据处理的逻辑。在Clean种，一个<code>domain</code>中有n个<code>usecase</code>，一个<code>usecase</code>相对独立，处理单独的业务逻辑，其设计模式参考<strong>『命令模式』</strong>。</li>\n<li>数据层中，是真正的从数据源获取数据，<code>domain</code>层会调用它，获取数据，注意：<strong>domain层并不关心数据的来源（网络/本地文件/数据缓存）</strong>，至于内存cache的处理，是放在<code>domain</code>还是<code>data</code>，需要再研究。（server端看法：放在<code>domain</code>中，因为数据层更倾向于io操作）</li>\n</ul>\n<h4 id=\"Clean的数据流\"><a href=\"#Clean的数据流\" class=\"headerlink\" title=\"Clean的数据流\"></a>Clean的数据流</h4><p>presentation（V）–&gt; presentation（P）–&gt; domain(usecase) –&gt;data–&gt;domain(usecase,数据回调)–&gt; presentation(P，结果回调) –&gt;presentation（V,P调用V的UIController接口）</p>\n<h4 id=\"几个注意点与疑惑\"><a href=\"#几个注意点与疑惑\" class=\"headerlink\" title=\"几个注意点与疑惑\"></a>几个注意点与疑惑</h4><ul>\n<li>多个model实体，即<code>presentation</code>、<code>domain</code>、<code>data</code>需要三层独立的Model，思考：<strong>为什么，如何优化？</strong></li>\n<li><code>domain</code>层是纯java层，<strong>理想状态是纯java module</strong>，与android无关。如果多module项目，这需要考虑，使用纯<code>java module</code>后，<code>presentation</code>无法直接访问<code>data</code>（跨层访问），<code>domain</code>也无法访问<code>presentation</code>和<code>data</code>（<strong>只能通过放在domain层的接口来访问</strong>）。虽然也好处是强制解耦，开发人员也不会误操作，但是限制很大。这也直接导致了第一个问题。</li>\n<li><p>太多的接口，总结一下在尽量接口设计且<code>domain</code>是纯java层时，需要这些接口</p>\n<ul>\n<li><code>presentation</code>内部，VP之间一组（两个，ui，presenter）</li>\n<li><code>presentation</code>与<code>domain</code>之间一组（两个，调用<code>usecase</code>与回调，必须放在<code>domain</code>中）</li>\n<li><code>domain</code>与<code>data</code>之间一组（两个，调用repository与回调，必须放在domain中）</li>\n<li><p><code>data</code>内部，调用网络异步（一组）、数据库异步（一组）</p>\n<blockquote>\n<p>如何解决：1.通用接口设计，而不是更具业务不同（如各种callback）2.能不使用接口的地方直接调用，但会丧失Clean的优势（在纯domain，java层时有些接口不可避免） 3.<strong>用Rxjava不仅能减少接口，还能避免深层次的回调逻辑</strong></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>关于<code>domain</code>的理解，一个<code>usecase</code>的粒度是多大？只做一件事，然后通过usecase组合来实现新的<code>usecase</code>来完成业务？还是在一个<code>usecase</code>中写n个逻辑与回调，来实现（内存缓存数据处理大大方便，这也涉及内存缓存数据存放的问题）。尝试从『命令模式』角度思考。</li>\n<li>Clean的一大优势是，可以强制所有的<code>usecase</code>必须在非UI线程完成，只有<code>presentation</code>在UI线程，大大的减少了阻塞UI线程的可能性，即<code>domain</code>层在非UI完成，那么data层的接口是否还需要异步接口，还是直接使用同步接口？</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面介绍了Google推荐了几种构架，主要说明了MVP与Clean构架。基本上MVP是现在项目的标配，虽然Clean清晰，可维护性高，可复用性强，但是是否使用Clean，则看具体情况，也可能对其适当的简化后使用。<br>这里Clean构架的<a href=\"https://github.com/android10/Android-CleanArchitecture\" target=\"_blank\" rel=\"external\">demo</a>是一个比较高级的样例，综合了Rxjava，Dagger2，OkHttp/Retrofit。混合使用这些技术学习曲线还是比较陡峭的，在实际的构架中，综合团队人员水平，往往用接口代替Rxjava，不使用Dagger2。<br>其次，Clean构架可能显得臃肿，<strong>尤其实际中业务逻辑复用的程度并不高</strong>，所以，我们需要简化Clean构架以符合我们的业务需求。</p>\n","excerpt":"","more":"<p>在搭建新项目的过程中，调研了一些常用的开发框架，恰好近日Google公布了<a href=\"https://github.com/googlesamples/android-architecture\">一系列框架的梳理</a>（未完成），对Android开发者给出了一些指导，颇有裨益。总结了如下几种模式：</p>\n<ol>\n<li>纯MVP开发</li>\n<li>MVP+Loader</li>\n<li>MVP+Databinding</li>\n<li>MVP+ContentProvider</li>\n<li>MVP+Dagger</li>\n<li>MVP+Clean构架</li>\n</ol>\n<p>总体而言，基本涵盖了Android中的流行的开发构架方式。这些开发框架是以MVP为基础，再结合其他工具，或者再次细分某些层，实现更好的复用。这里首先简介一下MVP，然后将上述6个框架按照我的理解（可能不完备）进行归类总结。</p>\n<h2 id=\"MVP分析\"><a href=\"#MVP分析\" class=\"headerlink\" title=\"MVP分析\"></a>MVP分析</h2><p>MVP是上述六个框架的基础，对于MVP的认识，最好结合MVC、MVVM这两个框架进行学习，一个基本的理解参考阮一峰先生的<a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\">这篇文章</a>。<br>我总结几点：</p>\n<ul>\n<li>M层，即<code>model</code>，负责数据部分，如网络请求、数据库，获取数据。</li>\n<li>V层，即<code>view</code>，负责数据展示，Android的View或者Fragemnt</li>\n<li>P层，即<code>presenter</code>,核心，负责从M获取数据，然后控制V更新。</li>\n<li><strong>核心：M与V不直接交互数据，必须通过P</strong></li>\n<li><p>具体而言：V实现某个UIController接口，暴露自己实现的UI功能，如显示Progress等，P持有V的接口。V同时也会持有P，他们相互依赖（最好V/P都是通过接口依赖）。</p>\n<blockquote>\n<p>流程是：V收到用户操作–&gt;调用P的某方法–&gt;P去M获取数据–&gt;获取成功–&gt;P调用V暴露的接口去更新界面<br>注意：有些框架可能把Activity看着<code>Presenter</code>，这可能导致Activity中有过多的代码，建议还是抽出一个Presenter类，Activity仅仅看做一个View层实体。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"构架分析\"><a href=\"#构架分析\" class=\"headerlink\" title=\"构架分析\"></a>构架分析</h2><h3 id=\"MVP-Loader-MVP-ContentProvider\"><a href=\"#MVP-Loader-MVP-ContentProvider\" class=\"headerlink\" title=\"MVP+Loader/MVP+ContentProvider\"></a>MVP+Loader/MVP+ContentProvider</h3><p>这两个构架都是在P层与数据M层之间进行优化，主要<strong>优化了P层从M层获取数据的方式</strong>，使用Android原生（3.0开始）提供的<code>Loader</code>异步加载机制，从数据库/网络等地方加载数据。<code>CotentProvider</code>思想类似，使用了<code>CotentProvider</code>方式，分离数据部分，实现解耦。</p>\n<h3 id=\"MVP-Databinding\"><a href=\"#MVP-Databinding\" class=\"headerlink\" title=\"MVP+Databinding\"></a>MVP+Databinding</h3><p>这个框架可以看着是MVVM框架了。Databinding是利用Android提供的一个库实现了数据绑定的功能，即某个<code>Entity</code>内容可以直接反应到<code>View</code>中，同样<code>View</code>一旦修改，<code>Entity</code>也会变换。<strong>本质上，这种方式简化了MVP中P层与V层的关系</strong>，P层处理完的数据，放入某个实体中就可以显示在界面上。当然也有其缺陷。</p>\n<h3 id=\"MVP-Dagger\"><a href=\"#MVP-Dagger\" class=\"headerlink\" title=\"MVP+Dagger\"></a>MVP+Dagger</h3><p>这就比较好理解了，将MVP中对象的构造使用Dagger2代替，是一种强制性解耦的措施，具体可以参加<a href=\"http://limuzhi.com/2016/03/06/Android%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Dagger2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\">之前的文章</a>。</p>\n<h3 id=\"MVP-Clean构架\"><a href=\"#MVP-Clean构架\" class=\"headerlink\" title=\"MVP+Clean构架\"></a>MVP+Clean构架</h3><p>这里主要讲解一下Clean构架，什么是Clean构架，这在网上有很多介绍的文章，其实就是一种基于MVP再次分层的构架，历史比较悠久了（2012年？）。下面详细介绍。</p>\n<h4 id=\"Clean学习\"><a href=\"#Clean学习\" class=\"headerlink\" title=\"Clean学习\"></a>Clean学习</h4><p>基本的学习看Clean构架的文章：</p>\n<ul>\n<li><a href=\"http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html\">原始文章</a><br>：比较抽象，难以理解，不建议首先学习！</li>\n<li>Clean构架详细的解析文章，<a href=\"http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/\">原文</a>，<a href=\"http://zhuanlan.zhihu.com/p/20001838\">中文翻译</a>：可以直接学习这一篇文章，GitHub有详细的<a href=\"https://github.com/android10/Android-CleanArchitecture\">代码和讲解</a>，注意作者迭代了两个版本,第一版是没有依赖注入，RxJava那些框架的，相对比较好理解。</li>\n<li><a href=\"http://blog.chengdazhi.com/index.php/101\">国人讲解的Clean框架</a>：建议优先学习这篇文章，构架在在一个工程Module中，代码干净，比较好理解，但是可能对Clean的理解并不透彻。</li>\n</ul>\n<h4 id=\"Clean基本思想\"><a href=\"#Clean基本思想\" class=\"headerlink\" title=\"Clean基本思想\"></a>Clean基本思想</h4><p>总结一下Clean的基本思想：<br>首先，我们应该<strong>从MVP出发理解Clean构架</strong>。<br>Clean构架中，把整个项目分成3个模块，<code>presentation</code>（表现层），<code>domain</code>（领域层），<code>data</code>（数据层）。</p>\n<ul>\n<li>表现层中，就已经包含了完整的MVP构架，但是与传统的MVP不同的是：<ul>\n<li>这里的M，更加倾向于ViewModel，即仅仅用来存放展示数据的<code>Model</code>，与数据库等无关！『从数据源获取数据』的功能被剥离出去，形成了<code>data</code>层。</li>\n<li>这里的P，是不完整的P，它的核心功能，『调用M从数据源（真正的M）获取数据&amp;&amp;处理数据』的逻辑被剥离了出去！形成了<code>domain</code>层。</li>\n<li>这里的V，是完整意义上的<code>View</code></li>\n</ul>\n</li>\n<li>领域层中，即以前MVP中P剥离处理的调用M和数据处理的逻辑。在Clean种，一个<code>domain</code>中有n个<code>usecase</code>，一个<code>usecase</code>相对独立，处理单独的业务逻辑，其设计模式参考<strong>『命令模式』</strong>。</li>\n<li>数据层中，是真正的从数据源获取数据，<code>domain</code>层会调用它，获取数据，注意：<strong>domain层并不关心数据的来源（网络/本地文件/数据缓存）</strong>，至于内存cache的处理，是放在<code>domain</code>还是<code>data</code>，需要再研究。（server端看法：放在<code>domain</code>中，因为数据层更倾向于io操作）</li>\n</ul>\n<h4 id=\"Clean的数据流\"><a href=\"#Clean的数据流\" class=\"headerlink\" title=\"Clean的数据流\"></a>Clean的数据流</h4><p>presentation（V）–&gt; presentation（P）–&gt; domain(usecase) –&gt;data–&gt;domain(usecase,数据回调)–&gt; presentation(P，结果回调) –&gt;presentation（V,P调用V的UIController接口）</p>\n<h4 id=\"几个注意点与疑惑\"><a href=\"#几个注意点与疑惑\" class=\"headerlink\" title=\"几个注意点与疑惑\"></a>几个注意点与疑惑</h4><ul>\n<li>多个model实体，即<code>presentation</code>、<code>domain</code>、<code>data</code>需要三层独立的Model，思考：<strong>为什么，如何优化？</strong></li>\n<li><code>domain</code>层是纯java层，<strong>理想状态是纯java module</strong>，与android无关。如果多module项目，这需要考虑，使用纯<code>java module</code>后，<code>presentation</code>无法直接访问<code>data</code>（跨层访问），<code>domain</code>也无法访问<code>presentation</code>和<code>data</code>（<strong>只能通过放在domain层的接口来访问</strong>）。虽然也好处是强制解耦，开发人员也不会误操作，但是限制很大。这也直接导致了第一个问题。</li>\n<li><p>太多的接口，总结一下在尽量接口设计且<code>domain</code>是纯java层时，需要这些接口</p>\n<ul>\n<li><code>presentation</code>内部，VP之间一组（两个，ui，presenter）</li>\n<li><code>presentation</code>与<code>domain</code>之间一组（两个，调用<code>usecase</code>与回调，必须放在<code>domain</code>中）</li>\n<li><code>domain</code>与<code>data</code>之间一组（两个，调用repository与回调，必须放在domain中）</li>\n<li><p><code>data</code>内部，调用网络异步（一组）、数据库异步（一组）</p>\n<blockquote>\n<p>如何解决：1.通用接口设计，而不是更具业务不同（如各种callback）2.能不使用接口的地方直接调用，但会丧失Clean的优势（在纯domain，java层时有些接口不可避免） 3.<strong>用Rxjava不仅能减少接口，还能避免深层次的回调逻辑</strong></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>关于<code>domain</code>的理解，一个<code>usecase</code>的粒度是多大？只做一件事，然后通过usecase组合来实现新的<code>usecase</code>来完成业务？还是在一个<code>usecase</code>中写n个逻辑与回调，来实现（内存缓存数据处理大大方便，这也涉及内存缓存数据存放的问题）。尝试从『命令模式』角度思考。</li>\n<li>Clean的一大优势是，可以强制所有的<code>usecase</code>必须在非UI线程完成，只有<code>presentation</code>在UI线程，大大的减少了阻塞UI线程的可能性，即<code>domain</code>层在非UI完成，那么data层的接口是否还需要异步接口，还是直接使用同步接口？</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面介绍了Google推荐了几种构架，主要说明了MVP与Clean构架。基本上MVP是现在项目的标配，虽然Clean清晰，可维护性高，可复用性强，但是是否使用Clean，则看具体情况，也可能对其适当的简化后使用。<br>这里Clean构架的<a href=\"https://github.com/android10/Android-CleanArchitecture\">demo</a>是一个比较高级的样例，综合了Rxjava，Dagger2，OkHttp/Retrofit。混合使用这些技术学习曲线还是比较陡峭的，在实际的构架中，综合团队人员水平，往往用接口代替Rxjava，不使用Dagger2。<br>其次，Clean构架可能显得臃肿，<strong>尤其实际中业务逻辑复用的程度并不高</strong>，所以，我们需要简化Clean构架以符合我们的业务需求。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ciqn9tbc20009nac9f0t0phay","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbca000hnac977lkxkc4"},{"post_id":"ciqn9tbbn0001nac9ufn5n3n8","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbch000mnac9r86dkink"},{"post_id":"ciqn9tbc6000cnac9h3ypy1ed","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbck000pnac9697811ne"},{"post_id":"ciqn9tbc9000fnac9fs45vdoc","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbco000tnac95moun6mo"},{"post_id":"ciqn9tbbs0003nac96bgbslhp","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbcq000wnac9embywwe3"},{"post_id":"ciqn9tbcb000inac9f04oio5q","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbcs0011nac94qgz4hal"},{"post_id":"ciqn9tbci000nnac9eg0vadde","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbcv0014nac9gf0gg5es"},{"post_id":"ciqn9tbby0007nac9b0089i20","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbcy0018nac9c1rgxa7x"},{"post_id":"ciqn9tbcm000qnac940h8w6j2","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbd5001bnac91qs1uqa1"},{"post_id":"ciqn9tbcr000xnac91tzln2c4","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbd7001fnac96xi1g6kg"},{"post_id":"ciqn9tbcs0012nac9qwj84y5t","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbd9001inac95u2bwhit"},{"post_id":"ciqn9tbcv0015nac9ip5h9vzu","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbdd001mnac9nfp87kwv"},{"post_id":"ciqn9tbco000unac9sjcr5ggr","category_id":"ciqn9tbcs0010nac93dboesri","_id":"ciqn9tbdg001pnac9whaseqon"},{"post_id":"ciqn9tbcy0019nac9hqdioba2","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbdi001snac911bavvt3"},{"post_id":"ciqn9tbd5001cnac9t0j140g9","category_id":"ciqn9tbcs0010nac93dboesri","_id":"ciqn9tbdj001unac96q8wkj8m"},{"post_id":"ciqn9tbd8001gnac9cmdzx4cd","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbdk001xnac90ikxaiob"},{"post_id":"ciqn9tbd9001jnac989kiz97z","category_id":"ciqn9tbcs0010nac93dboesri","_id":"ciqn9tbdk001znac9pjaogshp"},{"post_id":"ciqn9tbdd001nnac9oxvm5mos","category_id":"ciqn9tbbx0006nac9ycascj3x","_id":"ciqn9tbdm0022nac9b5lv3w6l"}],"PostTag":[{"post_id":"ciqn9tbc9000fnac9fs45vdoc","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbch000lnac9u0vtkv28"},{"post_id":"ciqn9tbc9000fnac9fs45vdoc","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbck000onac9ypkwmi3p"},{"post_id":"ciqn9tbbn0001nac9ufn5n3n8","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbcn000snac9rx4qo8kz"},{"post_id":"ciqn9tbbn0001nac9ufn5n3n8","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbcq000vnac9jdix61oz"},{"post_id":"ciqn9tbcb000inac9f04oio5q","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbcs000znac9iyjyj7e1"},{"post_id":"ciqn9tbcb000inac9f04oio5q","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbcv0013nac99r3lmkcq"},{"post_id":"ciqn9tbci000nnac9eg0vadde","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbcx0017nac90bt5o297"},{"post_id":"ciqn9tbci000nnac9eg0vadde","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbd5001anac9luw1ufzd"},{"post_id":"ciqn9tbcm000qnac940h8w6j2","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbd7001enac9m69llafp"},{"post_id":"ciqn9tbcm000qnac940h8w6j2","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbd9001hnac9s8oi7anx"},{"post_id":"ciqn9tbbs0003nac96bgbslhp","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbdd001lnac9uhclz2zk"},{"post_id":"ciqn9tbbs0003nac96bgbslhp","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbde001onac90rev8i2k"},{"post_id":"ciqn9tbcv0015nac9ip5h9vzu","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbdh001rnac9a2lcfsep"},{"post_id":"ciqn9tbcv0015nac9ip5h9vzu","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbdi001tnac9py7dak1v"},{"post_id":"ciqn9tbby0007nac9b0089i20","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbdk001wnac9xm2iztor"},{"post_id":"ciqn9tbby0007nac9b0089i20","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbdk001ynac9ofeg6phe"},{"post_id":"ciqn9tbc20009nac9f0t0phay","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbdl0020nac9o1twdi6c"},{"post_id":"ciqn9tbc20009nac9f0t0phay","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbdm0023nac9t1yhvb4n"},{"post_id":"ciqn9tbdd001nnac9oxvm5mos","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbdm0024nac9uj48yp9w"},{"post_id":"ciqn9tbdd001nnac9oxvm5mos","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbdn0026nac92gor20hv"},{"post_id":"ciqn9tbc6000cnac9h3ypy1ed","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbdn0027nac9pi5lfy5h"},{"post_id":"ciqn9tbc6000cnac9h3ypy1ed","tag_id":"ciqn9tbc5000bnac9q89439wx","_id":"ciqn9tbdo0029nac99m0clvfm"},{"post_id":"ciqn9tbco000unac9sjcr5ggr","tag_id":"ciqn9tbdh001qnac9iipstwjo","_id":"ciqn9tbdo002anac91rg74rvw"},{"post_id":"ciqn9tbcr000xnac91tzln2c4","tag_id":"ciqn9tbdj001vnac9zjdwdtri","_id":"ciqn9tbdo002cnac9qv8tdvcj"},{"post_id":"ciqn9tbcs0012nac9qwj84y5t","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbdp002dnac98s7s4uf3"},{"post_id":"ciqn9tbcs0012nac9qwj84y5t","tag_id":"ciqn9tbdj001vnac9zjdwdtri","_id":"ciqn9tbdp002fnac9meafm8cf"},{"post_id":"ciqn9tbcs0012nac9qwj84y5t","tag_id":"ciqn9tbdm0025nac9rwirrvwh","_id":"ciqn9tbdp002gnac9w2h1khcj"},{"post_id":"ciqn9tbcy0019nac9hqdioba2","tag_id":"ciqn9tbbv0005nac9xol2egf8","_id":"ciqn9tbdp002hnac99b50niep"},{"post_id":"ciqn9tbcy0019nac9hqdioba2","tag_id":"ciqn9tbdn0028nac9e5iwe8ix","_id":"ciqn9tbdp002inac9bkpxfyww"},{"post_id":"ciqn9tbd8001gnac9cmdzx4cd","tag_id":"ciqn9tbdo002bnac926bwlr0z","_id":"ciqn9tbdq002jnac9s9wljtv3"},{"post_id":"ciqn9tbd9001jnac989kiz97z","tag_id":"ciqn9tbdp002enac9dyejzc2t","_id":"ciqn9tbdq002knac9anmey1p9"}],"Tag":[{"name":"Android","_id":"ciqn9tbbv0005nac9xol2egf8"},{"name":"主框架","_id":"ciqn9tbc5000bnac9q89439wx"},{"name":"成长","_id":"ciqn9tbdh001qnac9iipstwjo"},{"name":"Guide","_id":"ciqn9tbdj001vnac9zjdwdtri"},{"name":"最佳实践","_id":"ciqn9tbdm0025nac9rwirrvwh"},{"name":"其他","_id":"ciqn9tbdn0028nac9e5iwe8ix"},{"name":"Tools","_id":"ciqn9tbdo002bnac926bwlr0z"},{"name":"理财","_id":"ciqn9tbdp002enac9dyejzc2t"}]}}
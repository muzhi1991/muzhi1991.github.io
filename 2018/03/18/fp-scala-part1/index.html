<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limuzhi.com","root":"/","scheme":"Mist","version":"7.7.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Overview第一部分主要使用Scala来函数式编程，介绍了核心概念。我们的目标是追求使用『纯函数』编程。  学会写小的函数式程序。（能写一个程序中的小模块）— 第一章 函数式编程中的基本概念以及Scala中的实现：高阶函数，多态函数 — 第二章 使用函数式编程实现函数式数据结构 — 第三章 使用函数式编程进行错误处理 — 第四章 提升函数式编程运行效率：非严格求值的概念 — 第五章 使用函数式">
<meta name="keywords" content="Scala,函数式编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala函数式编程-Part1">
<meta property="og:url" content="http://limuzhi.com/2018/03/18/fp-scala-part1/index.html">
<meta property="og:site_name" content="Night Piece">
<meta property="og:description" content="Overview第一部分主要使用Scala来函数式编程，介绍了核心概念。我们的目标是追求使用『纯函数』编程。  学会写小的函数式程序。（能写一个程序中的小模块）— 第一章 函数式编程中的基本概念以及Scala中的实现：高阶函数，多态函数 — 第二章 使用函数式编程实现函数式数据结构 — 第三章 使用函数式编程进行错误处理 — 第四章 提升函数式编程运行效率：非严格求值的概念 — 第五章 使用函数式">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-02-25T09:44:15.398Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scala函数式编程-Part1">
<meta name="twitter:description" content="Overview第一部分主要使用Scala来函数式编程，介绍了核心概念。我们的目标是追求使用『纯函数』编程。  学会写小的函数式程序。（能写一个程序中的小模块）— 第一章 函数式编程中的基本概念以及Scala中的实现：高阶函数，多态函数 — 第二章 使用函数式编程实现函数式数据结构 — 第三章 使用函数式编程进行错误处理 — 第四章 提升函数式编程运行效率：非严格求值的概念 — 第五章 使用函数式">

<link rel="canonical" href="http://limuzhi.com/2018/03/18/fp-scala-part1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Scala函数式编程-Part1 | Night Piece</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Night Piece</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">white && black</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fa fa-fw fa-wrench"></i>利器</a>

  </li>
        <li class="menu-item menu-item-read">

    <a href="/read/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://limuzhi.com/2018/03/18/fp-scala-part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="limuzhi">
      <meta itemprop="description" content="something about tech, android etc...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Night Piece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Scala函数式编程-Part1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-18 17:29:08" itemprop="dateCreated datePublished" datetime="2018-03-18T17:29:08+08:00">2018-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-25 17:44:15" itemprop="dateModified" datetime="2020-02-25T17:44:15+08:00">2020-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/18/fp-scala-part1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/18/fp-scala-part1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>第一部分主要使用Scala来函数式编程，介绍了核心概念。<br>我们的目标是追求<strong>使用『纯函数』编程</strong>。</p>
<ul>
<li>学会写小的<strong>函数式程序</strong>。（能写一个程序中的小模块）— 第一章</li>
<li>函数式编程中的<strong>基本概念</strong>以及<strong>Scala中的实现</strong>：高阶函数，多态函数 — 第二章</li>
<li>使用函数式编程实现<strong>函数式数据结构</strong> — 第三章</li>
<li>使用函数式编程进行<strong>错误处理</strong> — 第四章</li>
<li>提升函数式编程运行效率：<strong>非严格求值</strong>的概念 — 第五章</li>
<li>使用函数式编程实现<strong>状态处理</strong>（命令式编程） — 第六章</li>
</ul>
<p><a href="https://github.com/muzhi1991/learn-fp-in-scala" target="_blank" rel="noopener">我的练习题</a></p>
<blockquote>
<p>背景知识：Scala是在JVM上运行的一门语言，是带有<strong>自动类型推断</strong>的<strong>静态类型</strong>语言。使用它即可以使用与Java类似的命令式编程（甚至兼容Java库），也可实现纯的函数式编程。</p>
</blockquote>
<h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>核心理解：通过对比命令式编程与函数式编程，来体会函数式编程的优点。<br>场景：实现一个使用咖啡厅付款的程序，实现buyCoffee的功能，输入信用卡，我们对他扣款，最后获得一杯咖啡</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cafe</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buyCoffee</span></span>(cc: <span class="type">CreditCard</span>): <span class="type">Coffee</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> cup = <span class="keyword">new</span> <span class="type">Coffee</span>()</span><br><span class="line">    cc.charge(cup.price) <span class="comment">// 这里发生了状态变化</span></span><br><span class="line">    cup</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者高级一点：使用一个单独的类来支付</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cafe</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buyCoffee</span></span>(cc: <span class="type">CreditCard</span>, p: <span class="type">Payments</span>): <span class="type">Coffee</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> cup = <span class="keyword">new</span> <span class="type">Coffee</span>()</span><br><span class="line">    p.charge(cc,cup.price)  <span class="comment">// 通过p来发起支付，这里也发生了状态变化</span></span><br><span class="line">    cup</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是</p>
<ul>
<li>很难测试：没法判断购买逻辑的准确性，尤其涉及支付，外部payment的状态改变会影响我们buyCoffee运行结果。我们可能需要一个Mock的Payment来做。</li>
<li>很难复用：如果要实现一个函数<code>buyCoffees(n)</code>购买多杯咖啡呢？可以直接调用N次buyCoffee，问题是信用卡付款需要每一笔都支付交易费，我们理想情况是：合并这个12个账单，一次支付。这就没法复用buyCoffee方法了，要重新实现。</li>
</ul>
<p>函数式的方法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数式实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cafe</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有副作用</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buyCoffee</span></span>(cc: <span class="type">CreditCard</span>): (<span class="type">Coffee</span>, <span class="type">Charge</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> cup = <span class="keyword">new</span> <span class="type">Coffee</span>()</span><br><span class="line">    (cup,<span class="type">Charge</span>(cc,cup.price)) <span class="comment">// 没有实际扣款，我们只是把状态变化这个行为封装后输出了。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把支付这个『副作用』推迟。本质上，支付是引起了外部某个状态的变化，我们这种<strong>状态的变化</strong>通过返回值传递出去（把状态变化抽象了）。</p>
<ul>
<li>易于测试：这个函数随便调用，只要输入相同，输出就相同</li>
<li>易于复用：同样实现上面的需求，代码如下：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// charge定义</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Charge</span>(<span class="params">cc: <span class="type">CreditCard</span>, amount: <span class="type">Double</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 合并付款的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">combine</span></span>(other: <span class="type">Charge</span>): <span class="type">Charge</span> = </span><br><span class="line">    <span class="keyword">if</span> (cc == other.cc)</span><br><span class="line">      <span class="type">Charge</span>(cc, amount + other.amount)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"can't combine chareges to different cards"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cafe</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 买多杯咖啡</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buyCoffees</span></span>(cc: <span class="type">CreditCard</span>,n: <span class="type">Int</span>): (<span class="type">List</span>[<span class="type">Coffee</span>], <span class="type">Charge</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> purchases: <span class="type">List</span>[(<span class="type">Coffee</span>, <span class="type">Charge</span>)] = <span class="type">List</span>.fill(n)(buyCoffee(cc))</span><br><span class="line">    <span class="keyword">val</span> (coffees, charges) = purchases.unzip</span><br><span class="line">    <span class="comment">// 合并了付款，依然没有副作用</span></span><br><span class="line">    (coffees,charges.reduce((c1, c2) =&gt; c1.combine(c2))) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更复杂的需求：比如买了N被咖啡，用了多个不同信用卡，合并相同信用卡的付款。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">coalesce</span></span>(charges: <span class="type">List</span>[<span class="type">Charge</span>]): <span class="type">List</span>[<span class="type">Charge</span>]= &#123;</span><br><span class="line">    charges.groupBy(_.cc).values.map(_.reduce(_ combine _)).toList</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们所有操作的目标就是吧副作用去除，这样写出的函数可以叫做『纯函数』<br>由此，我们很容易得到纯函数的几个特点</p>
<ul>
<li>引用透明：任何引用透明的表达式（或者函数）都可以被他的结果取代</li>
<li>替代模型：利用『引用透明』来推导程序求值的过程就是替代模型</li>
<li>纯粹度：表示某个计算是不是纯粹的局部影响。（先忽略这个概念）</li>
</ul>
<blockquote>
<p>纯函数的定义：如果一个<strong>函数的参数</strong>是引用透明且<strong>函数调用</strong>也是引用透明，那么他就纯函数</p>
</blockquote>
<p>纯函数的优点：</p>
<ul>
<li>模块化、可组合、可复用</li>
<li>易于测试</li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>核心理解：</p>
<ul>
<li>使用函数式的方法实现Loop</li>
<li>尾递归：什么情况下是尾递归，尾递归的好处，scala的实现（注解）</li>
<li>高阶函数的概念，应用场景，</li>
<li>匿名函数的作用：常作为高阶函数的参数。</li>
<li>泛型函数的作用，以及一个问题&amp;&amp;解决：必须使用高阶函数。</li>
<li>泛型函数+高阶函数的典型应用：部分应用函数、柯里化、Compose</li>
</ul>
<h3 id="scala的程序的基本组成"><a href="#scala的程序的基本组成" class="headerlink" title="scala的程序的基本组成"></a>scala的程序的基本组成</h3><ul>
<li>模块：我们可以任务scala中的object就是一个模块，广义的说，对象（class的实例）可以看作模块</li>
<li>函数：无副作用的方法，就是我们需要写的函数式程序。就是def定义。</li>
<li>过程：有副作用的方法，如main，典型的<strong>返回值Unit的方法暗示了有副作用</strong>。</li>
</ul>
<blockquote>
<p>一般当我们说模块时，就是指的<code>object xxx {}</code>定义的单例对象，我们<code>import xxx</code>表示导入这个module。在shell中load包含object的文件，系统会提示<code>defined module xxx</code></p>
</blockquote>
<ul>
<li>scala的代码必须在object或者class中</li>
<li>main只能在object中</li>
</ul>
<blockquote>
<p>此外，我们也会<code>import XXX</code> 其中XXX是类<code>class XXX{}</code>。这表示引入类，他不是模块！。在shell中load包含class的文件，系统会提示<code>defined class XXX</code></p>
</blockquote>
<h3 id="模块-amp-amp-对象-amp-amp-命名空间"><a href="#模块-amp-amp-对象-amp-amp-命名空间" class="headerlink" title="模块 &amp;&amp; 对象 &amp;&amp; 命名空间"></a>模块 &amp;&amp; 对象 &amp;&amp; 命名空间</h3><p>理解这三个概念是一个东西，</p>
<ul>
<li>一个对象（object）就是一个模块（module）</li>
<li>一个模块/对象给成员（函数，过程，值）提供了命名空间</li>
</ul>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>核心实现：函数像变量一样，可以再赋值给其他变量，存储在数据结构，当做参数传递<br>用乘积的例子，分别用<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/84199b807cf1a1363efbc3b814a15623c1cdf9b9/src/chapter2/HOF.scala#L12-L18" target="_blank" rel="noopener">普通递归</a>和<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/84199b807cf1a1363efbc3b814a15623c1cdf9b9/src/chapter2/HOF.scala#L21-L38" target="_blank" rel="noopener">尾递归</a>实现。其中尾递归是一种Loop的方式。</p>
<ul>
<li>使用高阶函数实现Loop</li>
<li>Loop与尾递归的关系</li>
<li>尾递归<code>@annotation.tailrec</code>的使用</li>
<li>匿名函数作为高阶函数参数</li>
</ul>
<blockquote>
<p>一个理解『函数也是值』的角度是：Scala中定义匿名函数（也叫<strong>函数字面量</strong>）：<code>(x:Int) =&gt; x==9</code>本质上是定义了一个<code>Function2[Int, Int, Boolean]</code>的对象。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">val</span> lessThan = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Boolean</span>] &#123;</span><br><span class="line">&gt;  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = a &lt; b</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>高阶函数的参数</strong>的命名约定：f g h来命名函数<br>匿名函数作为高阶函数的参数时，匿名函数的参数的类型如果可以自动推到出，即可省略(a,b)=&gt;a&lt;b</p>
</blockquote>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li>实现斐波那契数列（使用尾递归范式），<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/84199b807cf1a1363efbc3b814a15623c1cdf9b9/src/chapter2/HOF.scala#L40-L71" target="_blank" rel="noopener">参考</a></li>
</ul>
<h3 id="多态函数（泛型函数）"><a href="#多态函数（泛型函数）" class="headerlink" title="多态函数（泛型函数）"></a>多态函数（泛型函数）</h3><ul>
<li>单态 vs 多态</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">多态的类型</a>)<ul>
<li>静态多态<ul>
<li><strong>参数化多态</strong></li>
<li>非参数化多态/特设多态（Ad-hoc polymorphism）</li>
</ul>
</li>
<li>动态多态<ul>
<li>子类型多态</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用泛型不可避免地使用高阶函数</strong>：参考下面的参数p，因为A没有类型信息，需要高阶高阶函数来判断状态。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个多态的例子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findFirst</span></span>[<span class="type">A</span>](as: <span class="type">Array</span>[<span class="type">A</span>], p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>):<span class="type">Int</span>=&#123;</span><br><span class="line">  <span class="meta">@annotation</span>.tailrec</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span>=&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= as.length) <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p(as(n))) n</span><br><span class="line">    <span class="keyword">else</span> loop(n+<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  loop(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>习惯上，用大写字母[A,B,C]表示泛型参数</p>
</blockquote>
<h3 id="通过类型实现多态"><a href="#通过类型实现多态" class="headerlink" title="通过类型实现多态"></a>通过类型实现多态</h3><p>下面是一下常见的函数变换：</p>
<ul>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter2/PolymorphicByType.scala#L8-L15" target="_blank" rel="noopener">部分应用</a>：<code>(A, B) =&gt; C</code> 变成 <code>B =&gt; C</code></li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter2/PolymorphicByType.scala#L17-L36" target="_blank" rel="noopener">柯里化、反柯里化</a>：<code>(A, B) =&gt; C</code> 变成 <code>A =&gt; (B =&gt; C)</code>。反柯里化则相反</li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter2/PolymorphicByType.scala#L39-L48" target="_blank" rel="noopener">Compose</a>：<code>f:B=&gt;C</code> <code>g:A=&gt;B</code> 变成 <code>A=&gt;C</code>。功能是：改变了函数的输入或者输出<ul>
<li>改变了函数f的输入（最常用的视角），在Scala中 <code>f.compose(g)</code>就是这个功能</li>
<li>改变了函数g的输出</li>
<li>多态高阶函数：在高阶函数中加上了多态</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于=&gt;是右结合的操作符，A =&gt; B =&gt; C 与 A =&gt; (B =&gt; C) 等价。含义是输入是一个值，输出是一个函数</p>
</blockquote>
<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><ul>
<li><code>scalac xxx.scala</code> 编译scala生成class文件</li>
<li>在shell中，使用<code>:load xx.scala</code>加载中定义的模块</li>
<li>使用<code>javap xxx.class</code> 反编译,scala生成的java代码</li>
</ul>
<blockquote>
<p>函数与过程：我们一般用『过程』表示有副作用的方法，用函数表示没有副作用的方法</p>
</blockquote>
<h2 id="函数式数据结构"><a href="#函数式数据结构" class="headerlink" title="函数式数据结构"></a>函数式数据结构</h2><p>核心理解：</p>
<ul>
<li>函数式List的数据结构定义：<ul>
<li>Cons &amp;&amp; Nil 这种惯用法</li>
<li>trait和class的继承设计</li>
<li>可以对比后边的Option，Stream，State的设计</li>
</ul>
</li>
<li>函数式数据结构的优点：<ul>
<li>最大优点：不可变性</li>
<li>效率问题：什么是数据共享—》减少复制</li>
</ul>
</li>
<li>List的实现：<ul>
<li>关键技术：<strong>模式匹配</strong>—函数式编程中核心概念</li>
<li>最佳实践：改进高阶函数的<strong>类型推导</strong></li>
<li>简单函数的实现：有了模式匹配和上面的最佳实践，实现普通的List[Int]的sum没有问题</li>
<li>关键函数（泛型+高阶函数）：<ul>
<li>递归概念的泛化：foldRight<ul>
<li>输入List输出一个『值』</li>
<li>可以使用该函数代替递归</li>
</ul>
</li>
<li>foldLeft的实现</li>
<li>难点理解：使用foldRight实现foldLeft<ul>
<li>结合了函数作为初始值</li>
<li>理解调用链</li>
</ul>
</li>
<li>foldRight对比Stream实现的foldRight</li>
</ul>
</li>
</ul>
</li>
<li>代数数据类型ADT的理解<ul>
<li>计算代数数据类型的个数</li>
<li>从模式匹配的角度理解</li>
</ul>
</li>
<li>Tree：如何设计一个函数数据结构中的函数，从具体到抽象。</li>
</ul>
<blockquote>
<p>本书第一部分中，除了List的定义的函数都是在外部的伴生对象里以独立函数的形式提供，其他的结构（Option，Stream，State）都尽量把相关方法放在了接口中。（List没有特殊的原因，只是示例，一般都应该在接口里定义）</p>
</blockquote>
<h3 id="定义函数式数据结构：List"><a href="#定义函数式数据结构：List" class="headerlink" title="定义函数式数据结构：List"></a>定义函数式数据结构：List</h3><p>实现一个List:</p>
<ul>
<li>sealed Trait List[+A]</li>
<li>Nil定义</li>
<li>Cons定义：一个经典递归结构，可以实现链表，树等常见函数式数据结构 </li>
<li>型变—协变</li>
<li>伴生对象—apply—函数可变参数</li>
</ul>
<p>涉及的技术细节如下</p>
<h4 id="scala定义class-trait"><a href="#scala定义class-trait" class="headerlink" title="scala定义class/trait"></a>scala定义class/trait</h4><ul>
<li>空trait、class：可以直接 <code>trait xxx</code> <code>class xxx</code> 定义没有任何方法的空trait和class，一般作为基类。</li>
<li>class和object都可以extend trait或者baseClass</li>
<li>具有多个trait时，<code>class test extend trait1 with trait2 with trait3</code></li>
<li>trait支持在里面实现函数，定义val</li>
</ul>
<h4 id="Nothing的使用"><a href="#Nothing的使用" class="headerlink" title="Nothing的使用"></a>Nothing的使用</h4><p>参考<a href="https://www.cnblogs.com/moonandstar08/p/5759137.html" target="_blank" rel="noopener">这篇</a>，对比了Scala常见的『空』</p>
<ul>
<li>Nothing是一个Trait,Nothing是没有实例的</li>
<li>Nothing是所有类的子类</li>
<li>所以<strong>它可以赋值给任何类型</strong>，配合协变，可以赋值给人以容器 —&gt; <code>List[String] = List[Nothing]()</code></li>
<li>Nothing比较适合用来定义基类容器—-&gt;Nil就是List[Nothing]，那么Nil就可以当做是一个空的String List，空的Int List，甚至使Any List。</li>
</ul>
<h4 id="case-object-vs-case-class"><a href="#case-object-vs-case-class" class="headerlink" title="case object vs case class"></a><code>case object</code> vs <code>case class</code></h4><ul>
<li>他们一个是object（对象），另一个是类</li>
<li>使用case（语法糖）使得两者自动有了一下方法<ul>
<li>主要目的是支持模式匹配</li>
<li>共同的方法：toString、hashCode、copy、equals方法 </li>
<li>case class多了 伴生object，且有apply方法和unapply实现参数case匹配</li>
</ul>
</li>
<li>形式上，<strong>class可以有构造参数</strong>，object由于是一个对象没有参数一说。</li>
<li>总结，虽然功能上<code>case object</code>基本可以被<code>case class</code>代替。但是实践的时候，<strong>当我们需要使用case类时（需要支持模式匹配功能/序列化时往往需要case类），如果case类有参数时我们选择<code>case class</code>，当case类没有参数时选择 <code>case object</code></strong>。<ul>
<li>原因：在没有参数时，使用<code>case object</code>的原因是，对于没参数的class，由于函数式编程要求immutable。<strong>所有该类是一个常量，只要一个单例共享数据</strong>就行！！</li>
</ul>
</li>
<li>参考文章：<a href="https://www.quora.com/Whats-the-difference-between-case-class-and-case-object-in-Scala" target="_blank" rel="noopener">https://www.quora.com/Whats-the-difference-between-case-class-and-case-object-in-Scala</a></li>
</ul>
<h4 id="用Python实现链表"><a href="#用Python实现链表" class="headerlink" title="用Python实现链表"></a>用Python实现链表</h4><p><a href="https://python.freelycode.com/contribution/detail/1021" target="_blank" rel="noopener">https://python.freelycode.com/contribution/detail/1021</a><br>同样是cons结构</p>
<h3 id="List的各种函数的实现"><a href="#List的各种函数的实现" class="headerlink" title="List的各种函数的实现"></a>List的各种函数的实现</h3><h4 id="基本知识：模式匹配"><a href="#基本知识：模式匹配" class="headerlink" title="基本知识：模式匹配"></a>基本知识：模式匹配</h4><p>定义：<strong>可以侵入到表达式的数据结构内部，对这个结构进行检验和提取子表达式。</strong></p>
<h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><p>List中减少赋值，对比tail与init（如何实现高效的init，需要改变数据结构，参考vector，使用了trie）  </p>
<h4 id="类型推导的改进"><a href="#类型推导的改进" class="headerlink" title="类型推导的改进"></a>类型推导的改进</h4><ul>
<li>为了使用匿名函数函数作为参数时的自动类型推导，我们需要柯里化（Scala的缺点导致的）</li>
<li>类型推导时，z是子类可能需要显示声明父类以至此后面的推导：z:List[Int]（参考foldRight）</li>
</ul>
<h4 id="基本函数的实现"><a href="#基本函数的实现" class="headerlink" title="基本函数的实现"></a>基本函数的实现</h4><p>实现基本函数sum，product</p>
<h4 id="泛化高阶函数的实现与应用"><a href="#泛化高阶函数的实现与应用" class="headerlink" title="泛化高阶函数的实现与应用"></a>泛化高阶函数的实现与应用</h4><p>重要实现：</p>
<ul>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter3/List.scala#L137-L171" target="_blank" rel="noopener"><strong>foldRight</strong>和foldLeft</a>（重要） &amp;&amp; 相关练习应用，如：<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter3/List.scala#L319-L321" target="_blank" rel="noopener">append</a><ul>
<li>难点：<ul>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter3/List.scala#L214-L296" target="_blank" rel="noopener">使用foldRight实现foldLeft</a>（参考习题，涉及使用函数对象作为初始值z）<br>思考（题3.7）：foldRight实现product时如何短路？如何优化product在乘以0时的效率：提前结束计算（或者用Stream的lazy来做）</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter3/List.scala#L393-L414" target="_blank" rel="noopener">filter的实现</a></li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter3/List.scala#L368-L391" target="_blank" rel="noopener">map的实现</a>（重要）—思考：foldRight与List结构的关系</li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter3/List.scala#L416-L430" target="_blank" rel="noopener">flatmap 的实现</a>（重要）:foldRight+append。对比Stream（Option，State不太一样）</li>
</ul>
<p>其他实现<br><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter3/List.scala#L467-L473" target="_blank" rel="noopener">zipWith</a></p>
<p>组合应用:</p>
<ul>
<li>链式调用List[A]：map map =&gt; List[C]</li>
<li>嵌套一层的List[List[A]：flatmap(map) ==&gt; List[B]</li>
<li>嵌套两层的List[List[List[A]]：flatmap (flatmap (map)) ==&gt; List[B]</li>
</ul>
<blockquote>
<p>flatmap后面的map在这里用链式调用也行。之所以嵌套调用，是为了和后面Option等应用兼容</p>
</blockquote>
<h4 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h4><p>（题3.24）<br><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter3/List.scala#L475-L502" target="_blank" rel="noopener">hasSubsequence</a>：使用if语句显式提前终止递归。写法不太『优美』，Stream有更好的写法，效率和提前终止类似</p>
<h3 id="标准库中的List"><a href="#标准库中的List" class="headerlink" title="标准库中的List"></a>标准库中的List</h3><ul>
<li>使用<code>::</code>代替<code>Cons</code></li>
<li><code>::</code>使用<code>:</code>结尾的操作符是有关联，机 <code>1::Nil</code>表示调用Nil的<code>::</code>方法，该方法内部调用<code>::(1,Nil）</code></li>
<li><code>case Cons(h,t)</code>变为<code>case h::t</code>   </li>
</ul>
<h3 id="树的数据结构"><a href="#树的数据结构" class="headerlink" title="树的数据结构"></a>树的数据结构</h3><ul>
<li>ADT的定义：代数数据类型，参考<a href="https://www.cnblogs.com/moonandstar08/p/5759137.html" target="_blank" rel="noopener">文章</a>，理解sum（对应类的继承，option），product类型（对应tuple，record）</li>
<li>书中<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/master/src/chapter3/Tree.scala" target="_blank" rel="noopener">Tree的实现</a><ul>
<li>只有叶子结点Leaf存储数据</li>
<li>分支节点Branch存在左右子树</li>
</ul>
</li>
<li>相关函数：<ul>
<li>具体函数：size(所有节点数量），maximum，depth，map</li>
<li><strong>抽象函数</strong>：fold的实现（对比List的FoldRight抽象）— 总结具体函数，有具体到抽象</li>
</ul>
</li>
</ul>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><ol>
<li>3.7 foldRight实现product时如何短路（第五章解答:使用Stream的foldRight）</li>
<li>3.24 如何高效实现hasSubsequence（第五章：使用Stream的tails方法）</li>
</ol>
<h2 id="不用异常来错误处理"><a href="#不用异常来错误处理" class="headerlink" title="不用异常来错误处理"></a>不用异常来错误处理</h2><p>核心理解：</p>
<ul>
<li>知道为什么要用Option这个函数式的方式处理异常，而不是Java的抛出异常</li>
<li>Option函数数据结构的定义：<strong>只包含一个元素的List</strong></li>
<li>Option函数定义 <ul>
<li>常见函数 map/flatmap</li>
<li>特有函数 getOrElse\orElse</li>
</ul>
</li>
<li>如何获得Option<ul>
<li>lift</li>
<li>Try</li>
</ul>
</li>
<li>Option转化为Java异常</li>
<li>常见pattern：<ul>
<li>1个输入，1个值输出链式处理：<code>func().map.getOrElse</code> ，其中func()返回一个Option</li>
<li>2个输入，1个值输出：<code>map2(op1,op2)(f)</code>，只要一个None，结果就是None</li>
<li>n个输入，1个值输出：只要一个None，结果就是None<ul>
<li><strong>for推导</strong> 或者 flatmap[*n] + map </li>
</ul>
</li>
<li>n个输入，n个输出（一个List输出）<ul>
<li>sequence：List[Option[A]===&gt;Option[List[A]]</li>
<li>traverse：List[Option[A]===&gt;Option[List[B]]</li>
</ul>
</li>
</ul>
</li>
<li>Either：保留了具体异常的Option（只能存一个异常）<ul>
<li>数据结构定义：理解互斥并集</li>
<li>获得Either的方法与Option类似类似</li>
<li>具有和Option相同的函数和用法</li>
</ul>
</li>
<li>可以存储多个异常的高级版本：Partial</li>
</ul>
<h3 id="抛出异常的问题"><a href="#抛出异常的问题" class="headerlink" title="抛出异常的问题"></a>抛出异常的问题</h3><p>参考示例4.1的例子，很容易发现下面的问题<br>抛出异常的缺点：</p>
<ul>
<li><strong>不是引用透明的！！</strong></li>
<li>不是类型安全的，由于没有在函数定义时声明，我们不知道是否内部会有异常。</li>
</ul>
<h3 id="除了抛出异常，还可以怎么做"><a href="#除了抛出异常，还可以怎么做" class="headerlink" title="除了抛出异常，还可以怎么做?"></a>除了抛出异常，还可以怎么做?</h3><p>我们还可以使用类似于C语言的方法：<strong>返回一个特定的普通值（或者默认值）来表示异常</strong>。<br>缺点也很明显</p>
<ul>
<li>易错，这个很容易被我们忽略，忘记处理。</li>
<li>容易产生模板代码，尤其是有很多个异常要判断时，要重复n次</li>
<li>难以描述多态类型。对于多态函数，很难找一个有意义的返回值表示错误。</li>
</ul>
<p>使用Option方案，也是基于返回普通值的方式，但是解决了上面的问题：</p>
<ul>
<li>易错：使用统一的Option类代表返回值，获得真实值必须get，不会忘记处理</li>
<li>模板代码：使用各种Option函数组合，map flatmap有效解决了模板代码</li>
<li>难以描述多态类：统一使用None代表错误</li>
<li>额外的优点是：可以<strong>推迟并且集中处理异常</strong></li>
</ul>
<blockquote>
<p>科普： 部分函数 VS 完全函数。抛出异常的函数就是部分函数，使用Option就是把部分函数转化为了完全函数。<br>部分函数的定义：对于一些输入没有结果的函数。例如：抛出异常的函数，case语句定义的函数。</p>
</blockquote>
<h3 id="Option数据类型定义-amp-amp-常用函数"><a href="#Option数据类型定义-amp-amp-常用函数" class="headerlink" title="Option数据类型定义 &amp;&amp; 常用函数"></a>Option数据类型定义 &amp;&amp; 常用函数</h3><ul>
<li>Option：只包含一个元素的List<ul>
<li>数据结构定义</li>
<li>常见函数 map/flatmap</li>
<li>特有函数 getOrElse\orElse</li>
</ul>
</li>
</ul>
<h3 id="Option使用模式分析"><a href="#Option使用模式分析" class="headerlink" title="Option使用模式分析"></a>Option使用模式分析</h3><p>Option的使用场景是什么？<br>使用在<strong>部分函数的返回值</strong>中，典型地</p>
<ul>
<li>可能抛出异常的函数：处理除0，参数判断等</li>
<li>可能返回空值的函数：查找数据等</li>
</ul>
<p>一旦我们把某个方法改造为返回Option的函数如<code>def func():Option[A]</code><br>我们可以使用<code>func().map(f).getOrElse</code> 这种模式处理并获得结果。<br>如果func()是一个数据库查询函数，</p>
<ul>
<li>map函数可以方便地对返回数据二次处理：如提取某些字段</li>
<li>getOrElse，会返回具体的值/统一设置默认值。如果有需求，也可以模式匹配判断是否是None来错误处理</li>
</ul>
<h4 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h4><ul>
<li>把方法改造为Option<ul>
<li>lift的概念<ul>
<li>可以<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter4/Option.scala#L64-L79" target="_blank" rel="noopener">lift函数</a>：把函数改造为，输入输出都是Option的函数。提升已经存在的任何函数到Option上下文，</li>
<li>可以提升PartialFunction（部分函数）为Option输出</li>
</ul>
</li>
<li>Try方法：把基于异常的方法改造成Option</li>
</ul>
</li>
<li>Option转化为抛出异常：<code>outputOpt.getOrElse(throw new Exception(&quot;fail&quot;))</code></li>
</ul>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>我们多某个Option对象，可以像处理List那样处理</p>
<ol>
<li>1个输入，1个值输出链式处理：<code>func().map.getOrElse</code> ，其中func()返回一个Option</li>
<li>2个输入，1个值输出：<code>map2(op1,op2)(f)</code>，只要一个None，结果就是None</li>
<li>n个输入，1个值输出：只要一个None，结果就是None<ul>
<li><strong>for推导</strong> 或者使用 flatmap[*n] + map （两者等价）</li>
</ul>
</li>
<li>n个输入，n个输出（一个List输出）<ul>
<li>sequence：List[Option[A]===&gt;Option[List[A]]，实现方法是list.foldright与map2组合</li>
<li>traverse：List[Option[A]===&gt;Option[List[B]]</li>
</ul>
</li>
</ol>
<p>我们可以把一个带着Option的调用过程（即把上面1/2/3合并）描述为：<br>从n个Option取出里面的值，来调用函数f(a1,a2…an)。任何一个a为None则结果为None<br>这都可以用<strong>for推导</strong> 来表示！！！</p>
<p>注意</p>
<ul>
<li>map2 map3 .. mapn：map2的实现：flatmap+map</li>
<li>for推导的实现：flatmap[*n] + map</li>
</ul>
<blockquote>
<p>一个常识：实现了map&amp;&amp;flatMap的对象可以支持for推导</p>
</blockquote>
<h3 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h3><ul>
<li>数据结构定义 Left（错误） Rihgt（正确）</li>
<li>Either有相同版本的函数</li>
<li>Either中只能存储一个Exception，对于上面的链式调用中出现多个Exception，无法存储所有的Exception，此时需要一个新的数据结果，类似的Left存储了Seq[Exception]。参考<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/master/src/chapter4/Partial.scala" target="_blank" rel="noopener">Partial</a></li>
</ul>
<h2 id="严格求值与惰性求值"><a href="#严格求值与惰性求值" class="headerlink" title="严格求值与惰性求值"></a>严格求值与惰性求值</h2><p>核心目标：实现一个更好的List—Stream（更高效）<br>核心理解：</p>
<ul>
<li>List的存在问题有哪些</li>
<li>严格求值与惰性求值的概念&amp;&amp;Scala中的实现<ul>
<li>Scala中默认都是严格求职</li>
<li>惰性求值多次执行的问题—lazy关键字</li>
</ul>
</li>
<li>惰性列表Stream的数据结构定义<ul>
<li>传名参数作为类的参数来延迟求值</li>
<li>智能构造器</li>
<li>Helper函数的定义：toList，take，方便debug</li>
</ul>
</li>
<li>Stream常见函数<ul>
<li>理解为什么foldRight为什么能延迟执行：对比List中的foldRight</li>
<li>其他函数（对标List）：map flatMap append（注意实现时参数应该是惰性的）</li>
</ul>
</li>
<li>理解串联函数时的惰性求值—一等循环（类比一等函数）<ul>
<li>优点：效率优化（提前终止）、内存优化（没有中间对象）</li>
</ul>
</li>
<li>Stream的应用<ul>
<li>使用Stream实现无限流<ul>
<li>栈安全问题（惰性列表也有栈安全问题！！）</li>
</ul>
</li>
<li>共递归 &amp;&amp; unfold<ul>
<li>共递归的含义，以及一些专业术语：守护递归、共结束</li>
<li><strong>对比foldRight与unfold的异同</strong></li>
</ul>
</li>
<li>tails方法<ul>
<li>hasSubsequence的实现优化</li>
<li>泛化方法：scanRight方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="List的一个问题"><a href="#List的一个问题" class="headerlink" title="List的一个问题"></a>List的一个问题</h3><p>观察下面的List的链式使用方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).map(_ + <span class="number">10</span>).filter(_ % <span class="number">2</span> == <span class="number">0</span>).map(_ * <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>有一个明显的效率问题，我们会：</p>
<ul>
<li>遍历List，生成+10的新List2</li>
<li>再次遍历List2，执行filter，生成List3</li>
<li>最后，再次遍历List3，生成最终结果</li>
</ul>
<p>然而，一个显而易见的优化方式是，合并这3个步骤成为单个函数。（虽然filter不是很好合并，这里从概念是上感受）我们希望这个步骤能自动完成</p>
<h3 id="严格与非严格求职"><a href="#严格与非严格求职" class="headerlink" title="严格与非严格求职"></a>严格与非严格求职</h3><ul>
<li>非严格求值是<strong>函数的一个属性</strong>，含义是：这个函数可以选择不对它的一个或多个<strong>参数</strong>求值。<ul>
<li>非严格求值只适用于<strong>函数参数</strong>，不能应用再类的参数，为此，我们需要对类的参数用函数表示，变相达到惰性的目的。</li>
<li>任何函数都是默认严格求值的</li>
</ul>
</li>
<li>实现非严格求值的方式 <ul>
<li>使用高阶函数作为未求值的参数—<code>def if2[A](cond:Boolean, onTrue: () =&gt; A, onFalse: () =&gt; A):A</code></li>
<li>使用Scala内置语法—<code>def if2[A](cond:Boolean, onTrue: =&gt; A, onFalse: =&gt; A):A</code></li>
</ul>
</li>
<li>惰性问题：每个参数引用的地方都会被求值一次，不会缓存参数求值的结果。<ul>
<li>解决：使用<code>lazy val</code> 来缓存：lazy表示：Scala会延迟对这个变量的求值 &amp;&amp; 缓存这个结果</li>
</ul>
</li>
</ul>
<h3 id="惰性列表Stream"><a href="#惰性列表Stream" class="headerlink" title="惰性列表Stream"></a>惰性列表Stream</h3><h4 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Stream</span>[+<span class="type">A</span>] </span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">Stream</span>[<span class="type">Nothing</span>]</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: (</span>) <span class="title">=&gt;</span> <span class="title">A</span>, <span class="title">t</span></span>: () =&gt; <span class="type">Stream</span>[<span class="type">A</span>]) <span class="keyword">extends</span> <span class="type">Stream</span>[<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">cons</span></span>[<span class="type">A</span>](h: =&gt; <span class="type">A</span>, t: =&gt; <span class="type">Stream</span>[<span class="type">A</span>]): <span class="type">Stream</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">val</span> h1 = h</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">val</span> t1 = t</span><br><span class="line">    <span class="type">Cons</span>(() =&gt; h1, () =&gt; t1)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">empty</span></span>[<span class="type">A</span>]: <span class="type">Stream</span>[<span class="type">A</span>] = <span class="type">Empty</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">A</span>](as: <span class="type">A</span>*): <span class="type">Stream</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (as.isEmpty) empty</span><br><span class="line">    <span class="keyword">else</span> cons(as.head, apply(as.tail: _*))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比List几个重要的不同点：</p>
<ul>
<li>Cons的类定义：使用了函数对象作为参数，达到延迟调用的目的（由于=&gt;语法不支持作为类的参数）</li>
<li>添加了辅助方法构造Empty和Cons。主要关注cons方法，目的是要是<ul>
<li>为了封装<strong>传名参数</strong>给Cons，</li>
<li>同时使用了lazy来缓存变量，确保h/t只运行一次。</li>
</ul>
</li>
</ul>
<h4 id="Helper函数"><a href="#Helper函数" class="headerlink" title="Helper函数"></a>Helper函数</h4><p>helper函数是从Stream中获取一部分数据的方法：</p>
<ul>
<li>toList：把Stream转化成List，是全量转化</li>
<li>take(n):Stream[A]：截取一般的Stream，返回的还是Stream，需要再toList获取实际值</li>
<li>drop(n):Stream[A]：类似take</li>
<li>takeWhile(p: A=&gt;Boolean):Stream[A]：加入了条件判断<br><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter5/Stream.scala#L16-L44" target="_blank" rel="noopener">参考代码</a></li>
</ul>
<h3 id="描述与求值的分离：Stream关键函数的实现"><a href="#描述与求值的分离：Stream关键函数的实现" class="headerlink" title="描述与求值的分离：Stream关键函数的实现"></a>描述与求值的分离：Stream关键函数的实现</h3><h4 id="理解Stream的FoldRight函数"><a href="#理解Stream的FoldRight函数" class="headerlink" title="理解Stream的FoldRight函数"></a>理解Stream的FoldRight函数</h4><p>对比Stream的foldRight和List的foldRight，<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter5/Stream.scala#L46-L73" target="_blank" rel="noopener">参考代码</a></p>
<ul>
<li>求值顺序不同<br>核心：由于f的第二个参数B变成了『延迟调用』，导致求值顺序不同，即，<ul>
<li>在List版本中会在执行f前先调用参数B部分的代码块</li>
<li>在Stream版本中在先执行f，再『按需』执行参数部分</li>
</ul>
</li>
<li>结果相同<br>核心：两个方法在结果上是完全等价的，典型的例子是如果用foldRight重新构造一个新的相同的List/Stream。产生的结果相同</li>
</ul>
<p>应用：可以使用Stream版本的<strong>FoldRight实现『中断』效果</strong>。提高类似exists、forAll函数的效率。一个极端的例子如下（没必要用这个方法实现）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">headOption_foldRight</span></span>(): <span class="type">Option</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">  foldRight(<span class="type">None</span>: <span class="type">Option</span>[<span class="type">A</span>])((x, _) =&gt; <span class="type">Some</span>(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stream的链式调用-amp-amp-优点—一等循环"><a href="#Stream的链式调用-amp-amp-优点—一等循环" class="headerlink" title="Stream的链式调用&amp;&amp;优点—一等循环"></a>Stream的链式调用&amp;&amp;优点—一等循环</h4><p>对应的，我们可以<strong>基于foldRight</strong>实现<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter5/Stream.scala#L105-L132" target="_blank" rel="noopener">Stream版本的map，flatMap，append等函数</a>。</p>
<p>这些惰性版本的函数有<strong>一个巨大的优势：一等循环（first-class loops）</strong>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stream</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).map(_ + <span class="number">10</span>).filter(_ %<span class="number">2</span> == <span class="number">0</span>).toList</span><br></pre></td></tr></table></figure></p>
<p>一等循环解决了本章开头的提出的问题：如何自动多个函数。当面执行上述代码时，在<code>map</code>调用后立即遍历<code>Stream</code>，在<code>filter</code>调用后也不会执行，而是在最后<code>toList</code>时实际发生操作。你会发现<strong>循环延迟执行</strong>。最终，只在一次循环中完成了多步计算（相当于自动合并了）。</p>
<p>一个有趣的应用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然filter的含义是过滤整个链表，但是由于是惰性求值，我们只用了head，所以过滤出head之后就不会往后遍历了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">Option</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">  filter(p).headOption()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Stream应用：无限流"><a href="#Stream应用：无限流" class="headerlink" title="Stream应用：无限流"></a>Stream应用：无限流</h3><p>因为Stream的惰性（增量）的特点，可以用它来实现一个无限长度的Stream<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constant</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">Stream</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> repeat: <span class="type">Stream</span>[<span class="type">A</span>] = <span class="type">Stream</span>.cons(a, repeat)</span><br><span class="line">  repeat</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> ones: <span class="type">Stream</span>[<span class="type">Int</span>] = constant(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>另外一个有趣的应用是里有无限流生成一个<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter5/Stream.scala#L301-L307" target="_blank" rel="noopener">无限斐波那契数列</a></p>
<h3 id="Stream应用：共递归-amp-amp-unfold"><a href="#Stream应用：共递归-amp-amp-unfold" class="headerlink" title="Stream应用：共递归 &amp;&amp; unfold"></a>Stream应用：共递归 &amp;&amp; unfold</h3><p>unfold是这么一个函数：</p>
<ul>
<li>Input:<ul>
<li>一个状态转化函数：状态=&gt;(值，新状态)</li>
<li>一个初始状态</li>
</ul>
</li>
<li>Output:<ul>
<li>生成一个Stream</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unfold</span></span>[<span class="type">A</span>, <span class="type">S</span>](z: <span class="type">S</span>)(f: <span class="type">S</span> =&gt; <span class="type">Option</span>[(<span class="type">A</span>, <span class="type">S</span>)]): <span class="type">Stream</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">  f(z) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; empty[<span class="type">A</span>] <span class="comment">// 如果新状态为None，这结束</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>((a, s)) =&gt; <span class="type">Stream</span>.cons(a, unfold(s)(f))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unfold就是共递归函数。<br>对比『递归』与『共递归』：</p>
<ul>
<li>递归：每一步都指向一个更小的范围，最终结束 —&gt; foldRight</li>
<li>共递归：每一步产生数据以及状态，不断生产新的值。（生产数据的能力由新的状态控制）—&gt; unfold</li>
</ul>
<p>共递归也叫守护递归，生成能力（f控制的的结束）也叫共结束</p>
<p>unfold的应用</p>
<ul>
<li>使用unfold实现无限流</li>
<li>当初始状态z为Stream时，可以对该Stream进行遍历—&gt;<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter5/Stream.scala#L144-L163" target="_blank" rel="noopener">实现map、take、takeWhile等函数</a>，以及<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter5/Stream.scala#L165-L171" target="_blank" rel="noopener">zipWith</a></li>
</ul>
<p><strong>对比foldRight和unfold（参考书笔记p65）</strong></p>
<h3 id="Stream应用：tails函数实现hasSubsequence"><a href="#Stream应用：tails函数实现hasSubsequence" class="headerlink" title="Stream应用：tails函数实现hasSubsequence"></a>Stream应用：tails函数实现hasSubsequence</h3><ul>
<li>tails函数：生成Stream的所有后缀。<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter5/Stream.scala#L203-L209" target="_blank" rel="noopener">使用unfold实现</a></li>
<li>用tails实现hasSubsequence<ul>
<li>实现<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter5/Stream.scala#L211-L213" target="_blank" rel="noopener">简洁明了</a>。</li>
<li>理解为什么tails实现hasSubsequence是高效的（相比List的tails高效，对比List的hasSubsequence实现效率相同）：惰性</li>
</ul>
</li>
<li>tails的泛化scanRight，对每一个后缀（tails）执行foldRight，直接用tails+foldRight实现比较低效（要迭代len(tails)次），建议<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter5/Stream.scala#L214-L232" target="_blank" rel="noopener">使用foldRight直接实现</a></li>
</ul>
<h2 id="纯函数式状态"><a href="#纯函数式状态" class="headerlink" title="纯函数式状态"></a>纯函数式状态</h2><p>这章很难理解，慢慢体会。建议状态转化函数（Rand/State）类比Option。<br>核心：使用函数式编程实现带状态的编程</p>
<p>理解：</p>
<ul>
<li>以随机数生成器为例：随机数生成器的特点<ul>
<li>副作用的方式的随机数生成器</li>
<li>纯函数式的随机数生成器<ul>
<li>效率问题</li>
</ul>
</li>
</ul>
</li>
<li>如何转化待状态的方法==&gt;纯函数式<ul>
<li>通用的转化方法</li>
<li>带状态API的例子—其他随机数生成器：生成随机的double，随机的pair等</li>
</ul>
</li>
<li>抽象状态：更好的API<ul>
<li>随机数的例子：Rand—优点：避免显示传递RNG（对比上面的实现）<ul>
<li>传递状态：<ul>
<li>unit：不修改状态，传递输出值</li>
<li>map：不修改状态，只修改输出值</li>
</ul>
</li>
<li>组合状态行为：map2<ul>
<li>sequence的实现 List[Rand[A]]=&gt;Rand[List[A]]</li>
</ul>
</li>
<li>嵌套状态行为：flatmap—-从另一个角度理解：由于返回的是函数，如果是相同的函数，则是递归函数<ul>
<li>flatmap实现map,map2</li>
</ul>
</li>
</ul>
</li>
<li>通用实现：State<ul>
<li>常见参数 map map2 flatmap sequence   </li>
</ul>
</li>
</ul>
</li>
<li>纯函数命令编程：无副作用的维护状态<ul>
<li>flatmap[*n]+map组合==&gt;for推导</li>
<li>使用函数式方法修改任意状态：<strong>modify方法</strong>的定义<ul>
<li>get</li>
<li>set</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="副作用版本的随机数生成器"><a href="#副作用版本的随机数生成器" class="headerlink" title="副作用版本的随机数生成器"></a>副作用版本的随机数生成器</h3><p>Scala函数库 <code>scala.until.Random</code>就是一个带副作用的随机函数<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rng= <span class="keyword">new</span> scala.util.<span class="type">Random</span> <span class="comment">// 可以用带种子的版本</span></span><br><span class="line">rng.nextInt </span><br><span class="line">rng.nextInt <span class="comment">// 返回不同的值</span></span><br></pre></td></tr></table></figure></p>
<p>缺点：<br>我们很难预测得到的值，就很难测试&amp;&amp;复现bug。因为即使相同Random的种子，我们还必须保证调用<code>nextInt</code>的次数相同（伪随机）。本质上，是<code>Random</code>内部封装了一个状态，每次我们调用nextInt时，他内部会存储这个状态（副作用）<br>我补充：<br>有状态更困难的是在并发的时候，对共享状态的变化不可控！容易导致难以复现bug。</p>
<h3 id="纯函数版本的随机数生成器"><a href="#纯函数版本的随机数生成器" class="headerlink" title="纯函数版本的随机数生成器"></a>纯函数版本的随机数生成器</h3><p>核心：<strong>显示</strong> 传递状态，把状态和值一起返回。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RNG</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">nextInt</span></span>: (<span class="type">Int</span>, <span class="type">RNG</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种做法导致我们不行每次使用新的RNG对象来生成随机数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rng = <span class="type">SimpleRNG</span>(<span class="number">22</span>)</span><br><span class="line"><span class="keyword">val</span> (n1,rng1) = rng.nextInt</span><br><span class="line"><span class="keyword">val</span> (n2,rng2) = rng1.nextInt <span class="comment">// 注意这里用的上面的新的RNG对象rng1</span></span><br></pre></td></tr></table></figure>
<p>其中<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L8-L20" target="_blank" rel="noopener">SimpleRNG实现</a>使用了『线性同余生成器』<br>优点是：对于某个确定的RNG实例，每次调用都会返回相同的值。</p>
<p>上面我们成功改造了nextInt为『纯函数式』的实现。其实这个改造方法是通用的。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带副作用的版本，s就是共享的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> s:<span class="type">FooState</span> = ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>: <span class="type">Bar</span> <span class="comment">// 假设，他是一个会改变s的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">baz</span></span>: <span class="type">Int</span> <span class="comment">// 假设，他是一个会改变s的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯函数的版本</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>: (<span class="type">Bar</span>, <span class="type">Foo</span>) <span class="comment">// Foo包含了新状态</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">baz</span></span>: (<span class="type">Int</span>, <span class="type">Foo</span>) <span class="comment">// Foo包含了新状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>一个效率问题：我们返回的状态是一个新的值（<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L8-L20" target="_blank" rel="noopener">SimpleRNG实现</a>），相当于拷贝了一个值。相比与『副作用』的版本，直接修改内存中的状态，比较低效。有两种办法：</p>
<ul>
<li>使用高效的函数式数据结构？</li>
<li><strong>在第四章会以一种『引用透明』的方式修改内存</strong>。</li>
</ul>
</blockquote>
<h3 id="用纯函数实现带有状态的API"><a href="#用纯函数实现带有状态的API" class="headerlink" title="用纯函数实现带有状态的API"></a>用纯函数实现带有状态的API</h3><p>核心：<strong>实现输入状态，输出（新）状态的函数式API</strong>。</p>
<p>我继续用随机数生成器作为例子，上面我们实现了RNG中的nextInt方法，我建议分下来看：</p>
<ul>
<li>把RNG看出一个纯的状态存储器（什么SimpleRNG存了seed 22）</li>
<li>把RNG里面的nextInt方法拿出去，<strong>nextInt改成独立的状态转换函数</strong>：RNG=&gt;(value,RNG)。因为上面nextInt的输入状态其实就是包裹nextInt的RNG对象。</li>
</ul>
<p>目的：我们接着实现和状态相关的其他状态转换API：<strong>与改造后的nextInt类似，所有API函数都需要接受一个状态，输出一个新状态</strong>，这样我们就可以链式地传递状态了。</p>
<blockquote>
<p>另一个角度看：都改造成放在RNG类里面的方法也是可以的</p>
</blockquote>
<p>我们这里还是<strong>基于之前的nextInt</strong>（在RNG类里面的）那个，来实现其他随机数生成器：</p>
<ul>
<li>生成随机的（Int，Int）的数字Pair</li>
<li>0-max的正整数随机数。</li>
</ul>
<p>这些函数都是：<strong>输入是一个RNG（实现了nextInt的）。用它生成新的值和状态，然后对生成的值进行处理，返回处理后值&amp;&amp;刚才生成的状态。</strong><br>即：RNG=&gt;(value,RNG)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nonNegativeInt</span></span>(rng: <span class="type">RNG</span>): (<span class="type">Int</span>, <span class="type">RNG</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> (n1, rng1) = rng.nextInt</span><br><span class="line">  <span class="keyword">val</span> n = <span class="keyword">if</span> (n1 &lt; <span class="number">0</span>) -(n1 + <span class="number">1</span>) <span class="keyword">else</span> n1 <span class="comment">// 仅仅转换了生成是数字，依然有上面的状态</span></span><br><span class="line">  (n, rng1)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomPair</span></span>(rng: <span class="type">RNG</span>): ((<span class="type">Int</span>, <span class="type">Int</span>), <span class="type">RNG</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> (n1, rng1) = rng.nextInt</span><br><span class="line">  <span class="keyword">val</span> (n2, rng2) = rng1.nextInt <span class="comment">// 注意状态的串联</span></span><br><span class="line">  ((n1, n2), rng2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的随机数生成器有很多，<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L40-L91" target="_blank" rel="noopener">参考github</a></p>
<p>可以发现这些所有的实现有<strong>通用的模式</strong>：<br><code>RNG=&gt;(value,RNG)</code>，这里的<code>RNG</code>可以理解成状态，它就是一个值，与nextInt无关，nextInt看成一个无关的函数就行，输入是seed输出一个数）</p>
<blockquote>
<p>注：书中的随机数的例子不好理解，RNG本质就是个状态，夹杂了nextInt方法实在令人费解，不如最后的一到习题中的状态定义。</p>
</blockquote>
<h3 id="更好方法实现带状态的API"><a href="#更好方法实现带状态的API" class="headerlink" title="更好方法实现带状态的API"></a>更好方法实现带状态的API</h3><p>核心：上面实现的<code>nonNegativeInt</code>， <code>randomPair</code>方法比较『笨』，实现这两个方法都用到了nextInt，都是显示传递了rng状态。如果我们已经实现了一个状态函数，其他的函数可以由它衍生而来。具体来说，直接由生成的随机数Int的函数，得到nonNegativeInt或者randomPair。而不是每次都要调用nextInt，然后传递状态。因此我们需要：</p>
<ul>
<li>抽象出上面的函数</li>
<li>定义一些辅助函数，帮助传递状态</li>
</ul>
<p>我们把<code>RNG=&gt;(value,RNG)</code>这个<strong>函数</strong>，看做一个整体定义为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Rand</span>[+<span class="type">A</span>] </span>= <span class="type">RNG</span> =&gt; (<span class="type">A</span>, <span class="type">RNG</span>)</span><br></pre></td></tr></table></figure></p>
<p>一定注意：<strong>他是个函数</strong>！！！</p>
<p>首先，把生成随机数int的函数改造为符合<code>RNG=&gt;(value,RNG)</code>的<strong>状态转换函数</strong>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> int: <span class="type">Rand</span>[<span class="type">Int</span>] = rng =&gt; rng.nextInt <span class="comment">// 注意理解int与nextInt函数的不同</span></span><br></pre></td></tr></table></figure>
<p>定义unit函数，返回常量值与状态</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">Rand</span>[<span class="type">A</span>] = rng =&gt; (a, rng)</span><br></pre></td></tr></table></figure>
<p>下面我们基于这个<code>int</code>函数可以生成<code>nonNegativeInt</code> <code>randomDouble</code>等等。可以使用map函数可以帮助我们实现<strong>状态/函数之间的转化—<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L102-L107" target="_blank" rel="noopener">map</a></strong>（输入是函数，输出也是函数）：</p>
<ul>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L114" target="_blank" rel="noopener">nonNegativeInt</a>：map(int)(f)（函数本身的变换）Rand[Int]==&gt; Rand[Int]</li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L116" target="_blank" rel="noopener">double</a>：map(int)(f)（函数本身的变换）Rand[Int]==&gt; Rand[Double]</li>
</ul>
<p>我们还可以把多个<strong>状态/函数组合起来—<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L118-L125" target="_blank" rel="noopener">map2</a></strong>：</p>
<ul>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L127-L129" target="_blank" rel="noopener">both</a>：用map2来组合两个状态，生成状态Pair</li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L131-L133" target="_blank" rel="noopener">randomPair</a>：map2(int,int)(f)（函数的组合）Rand[Int]==&gt; Rand[(Int,Int)]</li>
<li><strong><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L137-L158" target="_blank" rel="noopener">sequence</a></strong>：3种实现方法，见下面的State，关注执行顺序，为什么他们都是是可行的。— 本质：函数链</li>
</ul>
<p>除此之外，还有<strong>状态/函数的嵌套—<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L164-L178" target="_blank" rel="noopener">flatmap</a></strong>：</p>
<ul>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L180-L188" target="_blank" rel="noopener">nonNegativeLessThan</a>：生成不小于某个数的正整数，应用了flatmap的可以表示嵌套函数的思想</li>
<li>使用flatMap实现<ul>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L190-L194" target="_blank" rel="noopener">map</a>：里有unit</li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/RNG.scala#L196-L203" target="_blank" rel="noopener">map2</a>：使用flatmap实现map2.map3…mapn</li>
</ul>
</li>
</ul>
<h3 id="通用状态行为数据类型"><a href="#通用状态行为数据类型" class="headerlink" title="通用状态行为数据类型"></a>通用状态行为数据类型</h3><p>我们泛化Rand，定义了更通用的类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本质上是一个函数</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">State</span>[<span class="type">S</span>, +<span class="type">A</span>] </span>= <span class="type">S</span> =&gt; (<span class="type">A</span>, <span class="type">S</span>)</span><br></pre></td></tr></table></figure>
<p><strong>为了后续支持for推导</strong>，我们使用另一种<strong>等价的表示方法</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用class内的函数对象(run变量)来代表上面的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span>[<span class="type">S</span>, +<span class="type">A</span>](<span class="params">run: <span class="type">S</span> =&gt; (<span class="type">A</span>, <span class="type">S</span></span>)) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">map</span> </span>= ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span> </span>= ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rand的定义</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Rand</span>[+<span class="type">A</span>] </span>= <span class="type">State</span>[<span class="type">RNG</span>, <span class="type">A</span>]</span><br></pre></td></tr></table></figure>
<p>相似的，我们可以对State实现在上面Rand里面实现的所有函数。因为使用了<code>run</code>来代表函数，因此有些差别。</p>
<ul>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/State.scala#L24-L32" target="_blank" rel="noopener">map</a></li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/State.scala#L34-L42" target="_blank" rel="noopener">map2</a></li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/State.scala#L44-L50" target="_blank" rel="noopener">flatMap</a></li>
<li>sequence<ul>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/State.scala#L105-L112" target="_blank" rel="noopener">foldRight</a> </li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/State.scala#L118-L129" target="_blank" rel="noopener">loop</a> </li>
<li><a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/State.scala#L138-L139" target="_blank" rel="noopener">reverse+foldLeft</a></li>
</ul>
</li>
</ul>
<h3 id="纯函数式命令编程"><a href="#纯函数式命令编程" class="headerlink" title="纯函数式命令编程"></a>纯函数式命令编程</h3><h4 id="for推导"><a href="#for推导" class="headerlink" title="for推导"></a>for推导</h4><p>当上面的State对象实现了map、flatMap时，我们可以使用for的语法糖</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ns: <span class="type">Rand</span>[<span class="type">List</span>[<span class="type">Int</span>]] =</span><br><span class="line">	int.flatMap(x =&gt;</span><br><span class="line">                int.flatMap( y=&gt;</span><br><span class="line">                            ints(x).map(xs =&gt;  <span class="comment">// ints为生成x个随机整数</span></span><br><span class="line">                                       xs.map(_ % y))</span><br><span class="line">                           )</span><br><span class="line">               )</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">val</span> ns: <span class="type">Rand</span>[<span class="type">List</span>[<span class="type">Int</span>]] = <span class="keyword">for</span> &#123;</span><br><span class="line">    x &lt;- int</span><br><span class="line">    y &lt;- int</span><br><span class="line">    xs &lt;- int(x)</span><br><span class="line">&#125; <span class="keyword">yield</span> xs.map(_ % y)</span><br></pre></td></tr></table></figure>
<h4 id="状态修改"><a href="#状态修改" class="headerlink" title="状态修改"></a>状态修改</h4><p>modify的基本的想法是，</p>
<ul>
<li>get方法：看成一个函数，把State[S,A]中的A部分设置为状态S <code>State(s=&gt;(s,s))</code></li>
<li>对get进行flatMap，获得存储的状态S（flatMap只能获取到A部分，这就是get的作用），此时可以对状态进行修改。</li>
<li>set(S)方法：看成一个函数，修改State[S,A]中的S，返回<code>State(_ =&gt; ((), s))</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span></span>[<span class="type">S</span>]: <span class="type">State</span>[<span class="type">S</span>, <span class="type">S</span>] = <span class="type">State</span>(s =&gt; (s, s))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span></span>[<span class="type">S</span>](s: <span class="type">S</span>): <span class="type">State</span>[<span class="type">S</span>, <span class="type">Unit</span>] = <span class="type">State</span>(_ =&gt; ((), s))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span></span>[<span class="type">S</span>](f: <span class="type">S</span> =&gt; <span class="type">S</span>): <span class="type">State</span>[<span class="type">S</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">  get.flatMap(s1 =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> x = set(f(s1))</span><br><span class="line">    x</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p>基于上面定义的函数我们可以实现一个有限自动机状态机</p>
<ul>
<li>输入：List[Intput] </li>
<li>输出：新的State（函数）<br>总体上：每个Input对一个的状态转换函数State，按n个输入的Input的顺序进行组合（sequence），最后输出一个新的状态转换函数。我们使用这个函数时（即传入参数&amp;&amp;调用），能直接产出最终的状态结果。</li>
</ul>
<p>一个例子（书中练习）投币的机器(p61 6.11)<br>练习<a href="https://github.com/muzhi1991/learn-fp-in-scala/blob/28ed9e5cbae3f588ae6ec07fce4f3a01183710ab/src/chapter6/Machine.scala" target="_blank" rel="noopener">参考</a></p>
<ul>
<li>simulateMachine：书中的答案—十分精巧</li>
<li>simulate：我自己的实现</li>
</ul>
<ul>
<li>定义函数式数据结构<ul>
<li>实现一个List:<ul>
<li>sealed Trait List[+A]</li>
<li>Nil定义</li>
<li>Cons定义：一个经典递归结构，可以实现链表，树等常见函数式数据结构 </li>
<li>型变—协变</li>
<li>伴生对象—apply—函数可变参数</li>
</ul>
</li>
<li>各种函数的实现<ul>
<li>模式匹配—定义：<strong>可以侵入到表达式的数据结构内部，对这个结构进行检验和提取子表达式。</strong><ul>
<li>实现基本函数sum，product</li>
</ul>
</li>
<li>数据共享，List中减少赋值，对比tail与init（如何实现高效的init，需要改变数据结构，参考vector，使用了trie）</li>
<li>类型推到的改进：<ul>
<li>为了使用匿名函数函数作为参数时的自动类型推导，我们需要柯里化（Scala的缺点导致的）</li>
<li>类型推导时，z是子类可能需要显示声明父类以至此后面的推导：z:List[Int]（参考foldRight）</li>
</ul>
</li>
<li>基本函数sum，product的<strong>泛化</strong>为高阶函数—&gt;<strong>foldRight</strong>和foldLeft &amp;&amp; 相关练习应用</li>
<li>难点：<ul>
<li>使用foldRight实现foldLeft（参考习题，涉及使用函数对象作为初始值z）</li>
</ul>
</li>
</ul>
</li>
<li>标准库中的List：<ul>
<li>使用<code>::</code>代替<code>Cons</code></li>
<li><code>::</code>使用<code>:</code>结尾的操作符是有关联，机 <code>1::Nil</code>表示调用Nil的<code>::</code>方法，该方法内部调用<code>::(1,Nil）</code></li>
<li><code>case Cons(h,t)</code>变为<code>case h::t</code></li>
</ul>
</li>
<li>有一些方法使用函数实现不高效：hasSubsequence函数需要<strong>递归循环</strong>？</li>
<li>树的数据结构<ul>
<li>ADT的定义：代数数据类型，参考<a href="https://www.cnblogs.com/moonandstar08/p/5759137.html" target="_blank" rel="noopener">文章</a>，理解sum（对应类的继承，option），product类型（对应tuple，record）</li>
<li>书中Tree<ul>
<li>只有叶子结点Leaf存储数据</li>
<li>分支节点Branch存在左右子树</li>
</ul>
</li>
<li>相关函数：<ul>
<li>具体函数：size(所有节点数量），maximum，depth，map</li>
<li><strong>抽象函数</strong>：fold的实现（对比List的FoldRight抽象）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其他：</p>
<h3 id="总结：重要的抽象函数"><a href="#总结：重要的抽象函数" class="headerlink" title="总结：重要的抽象函数"></a>总结：重要的抽象函数</h3><ul>
<li>单值数据结构(Option,State)：<ul>
<li>map：同数据结构的转化</li>
<li>flatmap：嵌套数据结构的转化</li>
<li>单值数据结构的List：<ul>
<li>sequence</li>
<li>traverse</li>
</ul>
</li>
</ul>
</li>
<li>多值数据结构(List,Stream)<ul>
<li>map：同数据结构的转化</li>
<li>flatmap：嵌套数据结构的转化</li>
<li>foldRight：一组值到一个值的转化</li>
</ul>
</li>
</ul>
<p>如果把函数式编程看成一个数据的pipeline</p>
<ul>
<li>map：再pipe内一个一个阶段的处理数据</li>
<li>flatmap：接入合并新的pipe数据</li>
<li>compse：接口的适配？</li>
</ul>
<p>关注分离：</p>
<ul>
<li>一等函数（函数作为变量）：分离了『运算逻辑』与『运算的执行』</li>
<li>Option：分离『实际发生的错误』和『错误处理』</li>
<li>Stream：分离函数的『描述』与『求值』</li>
</ul>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="https://t.me/mltalk">
                <span class="icon">
                  <i class="fa fa-telegram"></i>
                </span>

                <span class="label">机器学习碎碎念</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Scala/" rel="tag"># Scala</a>
              <a href="/tags/函数式编程/" rel="tag"># 函数式编程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/02/21/spark-version-release-way/" rel="prev" title="Spark项目发布模式&&各个版本特性（持续更新）">
      <i class="fa fa-chevron-left"></i> Spark项目发布模式&&各个版本特性（持续更新）
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/04/02/fp-scala-part2/" rel="next" title="Scala函数式编程-Part2">
      Scala函数式编程-Part2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview"><span class="nav-number">1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是函数式编程"><span class="nav-number">2.</span> <span class="nav-text">什么是函数式编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程"><span class="nav-number">3.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#scala的程序的基本组成"><span class="nav-number">3.1.</span> <span class="nav-text">scala的程序的基本组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块-amp-amp-对象-amp-amp-命名空间"><span class="nav-number">3.2.</span> <span class="nav-text">模块 &amp;&amp; 对象 &amp;&amp; 命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高阶函数"><span class="nav-number">3.3.</span> <span class="nav-text">高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#练习"><span class="nav-number">3.3.1.</span> <span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态函数（泛型函数）"><span class="nav-number">3.4.</span> <span class="nav-text">多态函数（泛型函数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过类型实现多态"><span class="nav-number">3.5.</span> <span class="nav-text">通过类型实现多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他技巧"><span class="nav-number">3.6.</span> <span class="nav-text">其他技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式数据结构"><span class="nav-number">4.</span> <span class="nav-text">函数式数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义函数式数据结构：List"><span class="nav-number">4.1.</span> <span class="nav-text">定义函数式数据结构：List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#scala定义class-trait"><span class="nav-number">4.1.1.</span> <span class="nav-text">scala定义class/trait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nothing的使用"><span class="nav-number">4.1.2.</span> <span class="nav-text">Nothing的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#case-object-vs-case-class"><span class="nav-number">4.1.3.</span> <span class="nav-text">case object vs case class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用Python实现链表"><span class="nav-number">4.1.4.</span> <span class="nav-text">用Python实现链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List的各种函数的实现"><span class="nav-number">4.2.</span> <span class="nav-text">List的各种函数的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本知识：模式匹配"><span class="nav-number">4.2.1.</span> <span class="nav-text">基本知识：模式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据共享"><span class="nav-number">4.2.2.</span> <span class="nav-text">数据共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型推导的改进"><span class="nav-number">4.2.3.</span> <span class="nav-text">类型推导的改进</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本函数的实现"><span class="nav-number">4.2.4.</span> <span class="nav-text">基本函数的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛化高阶函数的实现与应用"><span class="nav-number">4.2.5.</span> <span class="nav-text">泛化高阶函数的实现与应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#效率问题"><span class="nav-number">4.2.6.</span> <span class="nav-text">效率问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准库中的List"><span class="nav-number">4.3.</span> <span class="nav-text">标准库中的List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树的数据结构"><span class="nav-number">4.4.</span> <span class="nav-text">树的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遗留问题"><span class="nav-number">4.5.</span> <span class="nav-text">遗留问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不用异常来错误处理"><span class="nav-number">5.</span> <span class="nav-text">不用异常来错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抛出异常的问题"><span class="nav-number">5.1.</span> <span class="nav-text">抛出异常的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#除了抛出异常，还可以怎么做"><span class="nav-number">5.2.</span> <span class="nav-text">除了抛出异常，还可以怎么做?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Option数据类型定义-amp-amp-常用函数"><span class="nav-number">5.3.</span> <span class="nav-text">Option数据类型定义 &amp;&amp; 常用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Option使用模式分析"><span class="nav-number">5.4.</span> <span class="nav-text">Option使用模式分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#转化"><span class="nav-number">5.4.1.</span> <span class="nav-text">转化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理"><span class="nav-number">5.4.2.</span> <span class="nav-text">错误处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Either"><span class="nav-number">5.5.</span> <span class="nav-text">Either</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#严格求值与惰性求值"><span class="nav-number">6.</span> <span class="nav-text">严格求值与惰性求值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List的一个问题"><span class="nav-number">6.1.</span> <span class="nav-text">List的一个问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#严格与非严格求职"><span class="nav-number">6.2.</span> <span class="nav-text">严格与非严格求职</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#惰性列表Stream"><span class="nav-number">6.3.</span> <span class="nav-text">惰性列表Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构定义"><span class="nav-number">6.3.1.</span> <span class="nav-text">数据结构定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Helper函数"><span class="nav-number">6.3.2.</span> <span class="nav-text">Helper函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述与求值的分离：Stream关键函数的实现"><span class="nav-number">6.4.</span> <span class="nav-text">描述与求值的分离：Stream关键函数的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#理解Stream的FoldRight函数"><span class="nav-number">6.4.1.</span> <span class="nav-text">理解Stream的FoldRight函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream的链式调用-amp-amp-优点—一等循环"><span class="nav-number">6.4.2.</span> <span class="nav-text">Stream的链式调用&amp;&amp;优点—一等循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream应用：无限流"><span class="nav-number">6.5.</span> <span class="nav-text">Stream应用：无限流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream应用：共递归-amp-amp-unfold"><span class="nav-number">6.6.</span> <span class="nav-text">Stream应用：共递归 &amp;&amp; unfold</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream应用：tails函数实现hasSubsequence"><span class="nav-number">6.7.</span> <span class="nav-text">Stream应用：tails函数实现hasSubsequence</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纯函数式状态"><span class="nav-number">7.</span> <span class="nav-text">纯函数式状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#副作用版本的随机数生成器"><span class="nav-number">7.1.</span> <span class="nav-text">副作用版本的随机数生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纯函数版本的随机数生成器"><span class="nav-number">7.2.</span> <span class="nav-text">纯函数版本的随机数生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用纯函数实现带有状态的API"><span class="nav-number">7.3.</span> <span class="nav-text">用纯函数实现带有状态的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更好方法实现带状态的API"><span class="nav-number">7.4.</span> <span class="nav-text">更好方法实现带状态的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用状态行为数据类型"><span class="nav-number">7.5.</span> <span class="nav-text">通用状态行为数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纯函数式命令编程"><span class="nav-number">7.6.</span> <span class="nav-text">纯函数式命令编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for推导"><span class="nav-number">7.6.1.</span> <span class="nav-text">for推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态修改"><span class="nav-number">7.6.2.</span> <span class="nav-text">状态修改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有限状态机"><span class="nav-number">7.7.</span> <span class="nav-text">有限状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：重要的抽象函数"><span class="nav-number">7.8.</span> <span class="nav-text">总结：重要的抽象函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">limuzhi</p>
  <div class="site-description" itemprop="description">something about tech, android etc...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/muzhi1991" title="GitHub → https://github.com/muzhi1991" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:muzhi1991@gmail.com" title="E-Mail → mailto:muzhi1991@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/muzhi1991" title="Twitter → https://twitter.com/muzhi1991" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.chenyupeng.com/" title="https://www.chenyupeng.com/" rel="noopener" target="_blank">陈玉鹏的个人空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://macshuo.com/" title="http://macshuo.com/" rel="noopener" target="_blank">MacTalk</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">limuzhi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'G5HLDFmPsllxIjax4F2JTLnl-gzGzoHsz',
      appKey     : 'A5PTgbvpJwjPlcBJ3Brl8rDs',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
